using Rubberduck.Inspections.Abstract;
using System;
using System.Linq;
using Rubberduck.Parsing;
using Rubberduck.VBEditor;
using Rubberduck.Inspections.Resources;
using Rubberduck.Parsing.Grammar;
using Rubberduck.Parsing.Symbols;
using System.Windows.Forms;
using Rubberduck.UI.Refactorings;
using Rubberduck.Common;
using System.Text.RegularExpressions;
using System.Collections.Generic;

namespace Rubberduck.Inspections.QuickFixes
{
    public class AssignedByValParameterQuickFix : QuickFixBase
    {
        private readonly Declaration _target;
        private string _localCopyVariableName;
        private bool _isQuickFixUnitTest;
        private string[] _originalProcCodeLines;

        public AssignedByValParameterQuickFix(Declaration target, QualifiedSelection selection)
            : base(target.Context, selection, InspectionsUI.AssignedByValParameterQuickFix)
        {
            _target = target;
            _isQuickFixUnitTest = false;
            _localCopyVariableName = SuggestedName();
            _originalProcCodeLines = GetProcedureLines();
        }

        public override bool CanFixInModule { get { return false; } }
        public override bool CanFixInProject { get { return false; } }

        //This function exists solely to support unit testing 
        public void TESTONLY_FixUsingAutoGeneratedName()
        {
            //Prevent the popup dialog and forces the use of the AutoSuggestedName
            _isQuickFixUnitTest = true;

            Fix();
        }

        public override void Fix()
        {

            SetLocalCopyVariableName();

            if (IsCancelled) { return; }

            ModifyBlockToUseLocalCopyVariable();
        }

        private void SetLocalCopyVariableName()
        {
            using (var view = new AssignedByValParameterQuickFixDialog(_originalProcCodeLines))
            {
                view.Target = _target;
                view.NewName = SuggestedName();
                if (!_isQuickFixUnitTest)
                {
                    view.ShowDialog();
                    IsCancelled = view.DialogResult == DialogResult.Cancel;
                }
                if (!IsCancelled)
                {
                    _localCopyVariableName = view.NewName;
                }
            }
        }

        private void ModifyBlockToUseLocalCopyVariable()
        {
            if(!CheckLocalVariableNameIsValidForUpdate())
            {
                return;
            }

            ReplaceAssignedByValParameterReferences();

            AddDeclarationAndAssignment();
        }
        private bool CheckLocalVariableNameIsValidForUpdate()
        {
            if (_localCopyVariableName.Equals(string.Empty))
            {
                return false;
            }
            var validator = new VariableNameValidator(_localCopyVariableName);
            if (_originalProcCodeLines.Any(c => validator.IsFoundIn(c)))
            {
                return false;
            }
            return validator.IsValidName();
        }

        private void ReplaceAssignedByValParameterReferences()
        {
            var moduleLines = GetAllModuleLines();
            foreach (IdentifierReference idRef in _target.References)
            {
                var zbIndex = idRef.Selection.StartLine - 1;  //moduleLines is zero-based index
                var newStatement = ReplaceByValReferencesInLine(moduleLines[zbIndex]);
                var module = Selection.QualifiedName.Component.CodeModule;
                module.ReplaceLine(idRef.Selection.StartLine, newStatement);
            }
        }

        private void AddDeclarationAndAssignment()
        {
            var startLine = Selection.Selection.StartLine;
            var module = Selection.QualifiedName.Component.CodeModule;
            module.InsertLines(++startLine, BuildLocalCopyDeclaration());
            module.InsertLines(++startLine, BuildLocalCopyAssignment());
        }

        private string ReplaceByValReferencesInLine(string input)
        {
            const string noAdjacentLettersNumbersOrUnderscores = "([^0-9a-zA-Z_])";

            //variable surrounded by spaces or at the end of a line
            string newStatement;
            string pattern = "(\\s)" + _target.IdentifierName + "(\\s|\\z)";
            string replacement = "$1" + _localCopyVariableName + "$2";
            Regex rgx = new Regex(pattern);
            newStatement = rgx.Replace(input, replacement);

            //variable starts the line
            replacement = _localCopyVariableName + "$1";
            pattern = "^" + _target.IdentifierName + noAdjacentLettersNumbersOrUnderscores;
            rgx = new Regex(pattern);
            newStatement = rgx.Replace(newStatement, replacement);

            //variable name is surrounded by braces, brackets, etc
            pattern = noAdjacentLettersNumbersOrUnderscores + _target.IdentifierName + noAdjacentLettersNumbersOrUnderscores;
            replacement = "$1" + _localCopyVariableName + "$2";
            rgx = new Regex(pattern);
            newStatement = rgx.Replace(newStatement, replacement);

            return newStatement;
        }
        private string BuildLocalCopyDeclaration()
        {
            return Tokens.Dim + " " + _localCopyVariableName + " " + Tokens.As 
                + " " + _target.AsTypeName;
        }

        private string BuildLocalCopyAssignment()
        {
            return (SymbolList.ValueTypes.Contains(_target.AsTypeName) ? string.Empty : Tokens.Set + " ") 
                + _localCopyVariableName + " = " + _target.IdentifierName;
        }
        
        private string[] GetAllModuleLines()
        {
            var moduleContent = Context.Start.InputStream.ToString();
            string[] newLine = { "\r\n" };
            return moduleContent.Split(newLine, StringSplitOptions.None);
        }

        private string[] GetProcedureLines()
        {
            var parserRuleCtxt = (Antlr4.Runtime.ParserRuleContext)Context.Parent.Parent;

            int startLine = parserRuleCtxt.Start.Line;
            int endLine = parserRuleCtxt.Stop.Line;

            var moduleContent = Context.Start.InputStream.ToString();
            string[] newLine = { "\r\n" };
            var moduleLines =  moduleContent.Split(newLine, StringSplitOptions.None);

            var procLines = new List<string>();
            for( int zbIndex = startLine - 1; zbIndex < endLine; zbIndex++)
            {
                procLines.Add(moduleLines[zbIndex]);
            }
            return procLines.ToArray();
        }

        private string SuggestedName()
        {
            return "x" + _target.IdentifierName.CapitalizeFirstLetter();
        }
    }
}
