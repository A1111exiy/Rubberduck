//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.3
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Users\Splinter\Documents\Visual Studio 2015\Projects\RubberduckParserTest\RubberduckParserTest\VBAExpressionParser.g4 by ANTLR 4.3

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

namespace Rubberduck.Parsing.Binding {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.3")]
[System.CLSCompliant(false)]
public partial class VBAExpressionParser : Parser {
	public const int
		PRINT=166, ELSEIF=93, CBYTE=5, CLOSE=69, STATIC=196, MINUS=230, OPTION_EXPLICIT=159, 
		L_SQUARE_BRACKET=241, SETATTR=192, DOEVENTS=21, HASHENDIF=240, DATELITERAL=248, 
		ERROR=107, NOTHING=151, EACH=91, SUB=200, FILECOPY=115, STOP=198, LPAREN=228, 
		MID=144, CVERR=19, BEEP=58, AS=56, END_PROPERTY=98, AT=45, DATABASE=71, 
		GOSUB=121, CSNG=15, HASHCONST=236, CHDIR=66, POW=234, DOLLAR=47, PROPERTY_LET=169, 
		THEN=203, XOR=220, EXIT_FOR=110, DEFINT=79, HASHIF=237, UNLOCK=210, CALL=64, 
		LOCK_READ=139, SET=191, LOCK_READ_WRITE=141, ABS=1, LSET=142, RAISEEVENT=176, 
		MIDBTYPESUFFIX=32, SEEK=188, LONG=133, CBOOL=4, LIB=136, DIM=88, APPEND=55, 
		MKDIR=145, OPEN=156, DIV=222, PROPERTY_SET=170, CDBL=8, PERCENT=46, SENDKEYS=190, 
		END_SELECT=99, STRING=199, HASHELSEIF=238, SGN=37, REM=180, TO=205, DEFDBL=77, 
		BYVAL=61, FRIEND=116, LOOP=134, DELETESETTING=87, CLASS=68, DO=89, VARIANT=212, 
		END_WITH=102, DEFBOOL=74, OPTIONAL=157, ADDRESSOF=50, CONST=70, RSET=185, 
		INTEGER=129, CDEC=9, REMCOMMENT=250, ATTRIBUTE=53, OUTPUT=163, FOR=117, 
		PTRSAFE=171, EQ=224, BOOLEAN=60, CIRCLE=11, NAME=147, END_FUNCTION=96, 
		DEFSNG=84, DEFBYTE=75, NOT=150, CINT=10, SAVESETTING=187, END=103, PRESERVE=165, 
		ON_LOCAL_ERROR=155, FLOATLITERAL=246, HASHELSE=239, LOAD=131, BINARY=59, 
		LENB=28, RETURN=183, EXCLAMATIONPOINT=42, NEXT=148, GLOBAL=120, INPUTB=24, 
		IDENTIFIER=255, WS=254, EMPTY=94, CURRENCY=17, CCUR=6, MOD=146, WITHEVENTS=218, 
		COLON=40, DEFLNGLNG=81, STEP=197, TIME=204, OPTION_BASE=158, GT=226, PUT=173, 
		WITH=217, CSTR=16, LOCK_WRITE=140, LINE_CONTINUATION=256, TYPEOF=208, 
		DEFVAR=86, RMDIR=184, DEFLNG=80, UBOUND=38, FALSE=114, ERRORCHAR=258, 
		UNDERSCORE=253, INTEGERLITERAL=247, END_IF=97, LOCK=132, TEXT=202, SINGLEQUOTE=252, 
		SAVEPICTURE=186, MULT=231, SEMICOLON=41, BYTE=63, HEXLITERAL=245, ELSE=92, 
		IF=123, TYPE=207, AMPERSAND=48, DEFLNGPTR=82, ENUM=104, DEFOBJ=83, IN=126, 
		CHDRIVE=67, OPTION=34, DOT=43, EXIT_DO=109, GUIDLITERAL=257, IS=128, EQV=105, 
		WEND=214, FUNCTION=118, HASH=44, CASE=65, GEQ=225, GET=119, PUBLIC=172, 
		ON_ERROR=154, EXIT=22, MIDB=31, END_ENUM=95, GOTO=122, INTDIV=223, LONGPTR=30, 
		WIDTH=216, BEGIN=57, EXIT_SUB=113, ASSIGN=221, COMMENT=251, WRITE=219, 
		RANDOMIZE=175, DOUBLE=90, EXIT_PROPERTY=112, COMMA=39, RANDOM=174, PROPERTY_GET=168, 
		SELECT=189, PRIVATE=167, ERASE=106, TAB=201, BYREF=62, VERSION=213, NEQ=232, 
		END_TYPE=101, KILL=130, NEW=149, ARRAY=3, INPUT=127, SINGLE=194, UNLOAD=209, 
		ALIAS=51, SPC=195, LT=229, RESET=181, END_SUB=100, EVENT=108, READ_WRITE=178, 
		OPTION_COMPARE=160, ME=143, SCALE=36, CDATE=7, MIDTYPESUFFIX=33, NULL=152, 
		NEWLINE=249, TRUE=206, RPAREN=235, APPACTIVATE=54, IMP=124, STRINGLITERAL=243, 
		OCTLITERAL=244, READ=177, DATE=72, LIKE=137, AND=52, OPTION_PRIVATE_MODULE=161, 
		CLNGLNG=13, PLUS=233, ANY=2, RESUME=182, INT=25, SHARED=193, EXIT_FUNCTION=111, 
		PSET=35, ACCESS=49, LINE_INPUT=138, ON=153, OR=162, PARAMARRAY=164, LBOUND=26, 
		R_SQUARE_BRACKET=242, IMPLEMENTS=125, UNTIL=211, DEBUG=20, DEFCUR=78, 
		CLNGPTR=14, LONGLONG=29, DECLARE=73, DEFDATE=76, FIX=23, LEN=27, REDIM=179, 
		LEQ=227, DEFSTR=85, LET=135, WHILE=215, CVAR=18, CLNG=12, FOREIGNNAME=259, 
		OBJECT=260;
	public static readonly string[] tokenNames = {
		"<INVALID>", "ABS", "ANY", "ARRAY", "CBOOL", "CBYTE", "CCUR", "CDATE", 
		"CDBL", "CDEC", "CINT", "CIRCLE", "CLNG", "CLNGLNG", "CLNGPTR", "CSNG", 
		"CSTR", "CURRENCY", "CVAR", "CVERR", "DEBUG", "DOEVENTS", "EXIT", "FIX", 
		"INPUTB", "INT", "LBOUND", "LEN", "LENB", "LONGLONG", "LONGPTR", "MIDB", 
		"MIDBTYPESUFFIX", "MIDTYPESUFFIX", "OPTION", "PSET", "SCALE", "SGN", "UBOUND", 
		"','", "':'", "';'", "'!'", "'.'", "'#'", "'@'", "'%'", "'$'", "'&'", 
		"ACCESS", "ADDRESSOF", "ALIAS", "AND", "ATTRIBUTE", "APPACTIVATE", "APPEND", 
		"AS", "BEGIN", "BEEP", "BINARY", "BOOLEAN", "BYVAL", "BYREF", "BYTE", 
		"CALL", "CASE", "CHDIR", "CHDRIVE", "CLASS", "CLOSE", "CONST", "DATABASE", 
		"DATE", "DECLARE", "DEFBOOL", "DEFBYTE", "DEFDATE", "DEFDBL", "DEFCUR", 
		"DEFINT", "DEFLNG", "DEFLNGLNG", "DEFLNGPTR", "DEFOBJ", "DEFSNG", "DEFSTR", 
		"DEFVAR", "DELETESETTING", "DIM", "DO", "DOUBLE", "EACH", "ELSE", "ELSEIF", 
		"EMPTY", "END_ENUM", "END_FUNCTION", "END_IF", "END_PROPERTY", "END_SELECT", 
		"END_SUB", "END_TYPE", "END_WITH", "END", "ENUM", "EQV", "ERASE", "ERROR", 
		"EVENT", "EXIT_DO", "EXIT_FOR", "EXIT_FUNCTION", "EXIT_PROPERTY", "EXIT_SUB", 
		"FALSE", "FILECOPY", "FRIEND", "FOR", "FUNCTION", "GET", "GLOBAL", "GOSUB", 
		"GOTO", "IF", "IMP", "IMPLEMENTS", "IN", "INPUT", "IS", "INTEGER", "KILL", 
		"LOAD", "LOCK", "LONG", "LOOP", "LET", "LIB", "LIKE", "LINE_INPUT", "LOCK_READ", 
		"LOCK_WRITE", "LOCK_READ_WRITE", "LSET", "ME", "MID", "MKDIR", "MOD", 
		"NAME", "NEXT", "NEW", "NOT", "NOTHING", "NULL", "ON", "ON_ERROR", "ON_LOCAL_ERROR", 
		"OPEN", "OPTIONAL", "OPTION_BASE", "OPTION_EXPLICIT", "OPTION_COMPARE", 
		"OPTION_PRIVATE_MODULE", "OR", "OUTPUT", "PARAMARRAY", "PRESERVE", "PRINT", 
		"PRIVATE", "PROPERTY_GET", "PROPERTY_LET", "PROPERTY_SET", "PTRSAFE", 
		"PUBLIC", "PUT", "RANDOM", "RANDOMIZE", "RAISEEVENT", "READ", "READ_WRITE", 
		"REDIM", "REM", "RESET", "RESUME", "RETURN", "RMDIR", "RSET", "SAVEPICTURE", 
		"SAVESETTING", "SEEK", "SELECT", "SENDKEYS", "SET", "SETATTR", "SHARED", 
		"SINGLE", "SPC", "STATIC", "STEP", "STOP", "STRING", "SUB", "TAB", "TEXT", 
		"THEN", "TIME", "TO", "TRUE", "TYPE", "TYPEOF", "UNLOAD", "UNLOCK", "UNTIL", 
		"VARIANT", "VERSION", "WEND", "WHILE", "WIDTH", "WITH", "WITHEVENTS", 
		"WRITE", "XOR", "':='", "'/'", "'\\'", "'='", "GEQ", "'>'", "LEQ", "'('", 
		"'<'", "'-'", "'*'", "NEQ", "'+'", "'^'", "')'", "HASHCONST", "HASHIF", 
		"HASHELSEIF", "HASHELSE", "HASHENDIF", "'['", "']'", "STRINGLITERAL", 
		"OCTLITERAL", "HEXLITERAL", "FLOATLITERAL", "INTEGERLITERAL", "DATELITERAL", 
		"NEWLINE", "REMCOMMENT", "COMMENT", "'''", "'_'", "WS", "IDENTIFIER", 
		"LINE_CONTINUATION", "GUIDLITERAL", "ERRORCHAR", "FOREIGNNAME", "OBJECT"
	};
	public const int
		RULE_startRule = 0, RULE_unrestrictedName = 1, RULE_name = 2, RULE_reservedIdentifierName = 3, 
		RULE_reservedUntypedName = 4, RULE_reservedTypedName = 5, RULE_untypedName = 6, 
		RULE_typedName = 7, RULE_typedNameValue = 8, RULE_typeSuffix = 9, RULE_optionCompareArgument = 10, 
		RULE_builtInType = 11, RULE_expression = 12, RULE_literalExpression = 13, 
		RULE_numberLiteral = 14, RULE_parenthesizedExpression = 15, RULE_typeOfIsExpression = 16, 
		RULE_newExpression = 17, RULE_lExpression = 18, RULE_memberAccessExpression = 19, 
		RULE_indexExpression = 20, RULE_dictionaryAccessExpression = 21, RULE_argumentList = 22, 
		RULE_positionalOrNamedArgumentList = 23, RULE_positionalArgument = 24, 
		RULE_requiredPositionalArgument = 25, RULE_namedArgumentList = 26, RULE_namedArgument = 27, 
		RULE_argumentExpression = 28, RULE_simpleNameExpression = 29, RULE_instanceExpression = 30, 
		RULE_withExpression = 31, RULE_withMemberAccessExpression = 32, RULE_withDictionaryAccessExpression = 33, 
		RULE_constantExpression = 34, RULE_typeExpression = 35, RULE_definedTypeExpression = 36, 
		RULE_addressOfExpression = 37, RULE_procedurePointerExpression = 38, RULE_reservedIdentifier = 39, 
		RULE_statementKeyword = 40, RULE_remKeyword = 41, RULE_markerKeyword = 42, 
		RULE_operatorIdentifier = 43, RULE_reservedName = 44, RULE_reservedProcedureName = 45, 
		RULE_specialForm = 46, RULE_reservedTypeIdentifier = 47, RULE_literalIdentifier = 48, 
		RULE_booleanLiteralIdentifier = 49, RULE_objectLiteralIdentifier = 50, 
		RULE_variantLiteralIdentifier = 51, RULE_whiteSpace = 52;
	public static readonly string[] ruleNames = {
		"startRule", "unrestrictedName", "name", "reservedIdentifierName", "reservedUntypedName", 
		"reservedTypedName", "untypedName", "typedName", "typedNameValue", "typeSuffix", 
		"optionCompareArgument", "builtInType", "expression", "literalExpression", 
		"numberLiteral", "parenthesizedExpression", "typeOfIsExpression", "newExpression", 
		"lExpression", "memberAccessExpression", "indexExpression", "dictionaryAccessExpression", 
		"argumentList", "positionalOrNamedArgumentList", "positionalArgument", 
		"requiredPositionalArgument", "namedArgumentList", "namedArgument", "argumentExpression", 
		"simpleNameExpression", "instanceExpression", "withExpression", "withMemberAccessExpression", 
		"withDictionaryAccessExpression", "constantExpression", "typeExpression", 
		"definedTypeExpression", "addressOfExpression", "procedurePointerExpression", 
		"reservedIdentifier", "statementKeyword", "remKeyword", "markerKeyword", 
		"operatorIdentifier", "reservedName", "reservedProcedureName", "specialForm", 
		"reservedTypeIdentifier", "literalIdentifier", "booleanLiteralIdentifier", 
		"objectLiteralIdentifier", "variantLiteralIdentifier", "whiteSpace"
	};

	public override string GrammarFileName { get { return "VBAExpressionParser.g4"; } }

	public override string[] TokenNames { get { return tokenNames; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public VBAExpressionParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class StartRuleContext : ParserRuleContext {
		public ITerminalNode Eof() { return GetToken(VBAExpressionParser.Eof, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public StartRuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_startRule; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterStartRule(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitStartRule(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStartRule(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StartRuleContext startRule() {
		StartRuleContext _localctx = new StartRuleContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_startRule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 106; expression(0);
			State = 107; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnrestrictedNameContext : ParserRuleContext {
		public ReservedIdentifierNameContext reservedIdentifierName() {
			return GetRuleContext<ReservedIdentifierNameContext>(0);
		}
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public UnrestrictedNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unrestrictedName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterUnrestrictedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitUnrestrictedName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnrestrictedName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnrestrictedNameContext unrestrictedName() {
		UnrestrictedNameContext _localctx = new UnrestrictedNameContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_unrestrictedName);
		try {
			State = 111;
			switch ( Interpreter.AdaptivePredict(_input,0,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 109; name();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 110; reservedIdentifierName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NameContext : ParserRuleContext {
		public TypedNameContext typedName() {
			return GetRuleContext<TypedNameContext>(0);
		}
		public UntypedNameContext untypedName() {
			return GetRuleContext<UntypedNameContext>(0);
		}
		public NameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NameContext name() {
		NameContext _localctx = new NameContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_name);
		try {
			State = 115;
			switch ( Interpreter.AdaptivePredict(_input,1,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 113; untypedName();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 114; typedName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedIdentifierNameContext : ParserRuleContext {
		public ReservedTypedNameContext reservedTypedName() {
			return GetRuleContext<ReservedTypedNameContext>(0);
		}
		public ReservedUntypedNameContext reservedUntypedName() {
			return GetRuleContext<ReservedUntypedNameContext>(0);
		}
		public ReservedIdentifierNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedIdentifierName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedIdentifierName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedIdentifierName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedIdentifierName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedIdentifierNameContext reservedIdentifierName() {
		ReservedIdentifierNameContext _localctx = new ReservedIdentifierNameContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_reservedIdentifierName);
		try {
			State = 119;
			switch ( Interpreter.AdaptivePredict(_input,2,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 117; reservedUntypedName();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 118; reservedTypedName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedUntypedNameContext : ParserRuleContext {
		public ReservedIdentifierContext reservedIdentifier() {
			return GetRuleContext<ReservedIdentifierContext>(0);
		}
		public ReservedUntypedNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedUntypedName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedUntypedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedUntypedName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedUntypedName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedUntypedNameContext reservedUntypedName() {
		ReservedUntypedNameContext _localctx = new ReservedUntypedNameContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_reservedUntypedName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 121; reservedIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedTypedNameContext : ParserRuleContext {
		public TypeSuffixContext typeSuffix() {
			return GetRuleContext<TypeSuffixContext>(0);
		}
		public ReservedIdentifierContext reservedIdentifier() {
			return GetRuleContext<ReservedIdentifierContext>(0);
		}
		public ReservedTypedNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedTypedName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedTypedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedTypedName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedTypedName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedTypedNameContext reservedTypedName() {
		ReservedTypedNameContext _localctx = new ReservedTypedNameContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_reservedTypedName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 123; reservedIdentifier();
			State = 124; typeSuffix();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UntypedNameContext : ParserRuleContext {
		public ITerminalNode FOREIGNNAME() { return GetToken(VBAExpressionParser.FOREIGNNAME, 0); }
		public SpecialFormContext specialForm() {
			return GetRuleContext<SpecialFormContext>(0);
		}
		public ITerminalNode OBJECT() { return GetToken(VBAExpressionParser.OBJECT, 0); }
		public OptionCompareArgumentContext optionCompareArgument() {
			return GetRuleContext<OptionCompareArgumentContext>(0);
		}
		public ITerminalNode IDENTIFIER() { return GetToken(VBAExpressionParser.IDENTIFIER, 0); }
		public ReservedProcedureNameContext reservedProcedureName() {
			return GetRuleContext<ReservedProcedureNameContext>(0);
		}
		public UntypedNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_untypedName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterUntypedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitUntypedName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUntypedName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UntypedNameContext untypedName() {
		UntypedNameContext _localctx = new UntypedNameContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_untypedName);
		try {
			State = 132;
			switch ( Interpreter.AdaptivePredict(_input,3,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 126; Match(IDENTIFIER);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 127; Match(FOREIGNNAME);
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 128; reservedProcedureName();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 129; specialForm();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 130; optionCompareArgument();
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 131; Match(OBJECT);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypedNameContext : ParserRuleContext {
		public TypeSuffixContext typeSuffix() {
			return GetRuleContext<TypeSuffixContext>(0);
		}
		public TypedNameValueContext typedNameValue() {
			return GetRuleContext<TypedNameValueContext>(0);
		}
		public TypedNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typedName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterTypedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitTypedName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypedName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypedNameContext typedName() {
		TypedNameContext _localctx = new TypedNameContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_typedName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 134; typedNameValue();
			State = 135; typeSuffix();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypedNameValueContext : ParserRuleContext {
		public SpecialFormContext specialForm() {
			return GetRuleContext<SpecialFormContext>(0);
		}
		public ITerminalNode OBJECT() { return GetToken(VBAExpressionParser.OBJECT, 0); }
		public OptionCompareArgumentContext optionCompareArgument() {
			return GetRuleContext<OptionCompareArgumentContext>(0);
		}
		public ITerminalNode IDENTIFIER() { return GetToken(VBAExpressionParser.IDENTIFIER, 0); }
		public ReservedProcedureNameContext reservedProcedureName() {
			return GetRuleContext<ReservedProcedureNameContext>(0);
		}
		public TypedNameValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typedNameValue; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterTypedNameValue(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitTypedNameValue(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypedNameValue(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypedNameValueContext typedNameValue() {
		TypedNameValueContext _localctx = new TypedNameValueContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_typedNameValue);
		try {
			State = 142;
			switch ( Interpreter.AdaptivePredict(_input,4,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 137; Match(IDENTIFIER);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 138; reservedProcedureName();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 139; specialForm();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 140; optionCompareArgument();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 141; Match(OBJECT);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeSuffixContext : ParserRuleContext {
		public ITerminalNode AT() { return GetToken(VBAExpressionParser.AT, 0); }
		public ITerminalNode DOLLAR() { return GetToken(VBAExpressionParser.DOLLAR, 0); }
		public ITerminalNode EXCLAMATIONPOINT() { return GetToken(VBAExpressionParser.EXCLAMATIONPOINT, 0); }
		public ITerminalNode AMPERSAND() { return GetToken(VBAExpressionParser.AMPERSAND, 0); }
		public ITerminalNode PERCENT() { return GetToken(VBAExpressionParser.PERCENT, 0); }
		public ITerminalNode POW() { return GetToken(VBAExpressionParser.POW, 0); }
		public ITerminalNode HASH() { return GetToken(VBAExpressionParser.HASH, 0); }
		public TypeSuffixContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeSuffix; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterTypeSuffix(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitTypeSuffix(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeSuffix(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeSuffixContext typeSuffix() {
		TypeSuffixContext _localctx = new TypeSuffixContext(_ctx, State);
		EnterRule(_localctx, 18, RULE_typeSuffix);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 144;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << EXCLAMATIONPOINT) | (1L << HASH) | (1L << AT) | (1L << PERCENT) | (1L << DOLLAR) | (1L << AMPERSAND))) != 0) || _la==POW) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OptionCompareArgumentContext : ParserRuleContext {
		public ITerminalNode TEXT() { return GetToken(VBAExpressionParser.TEXT, 0); }
		public ITerminalNode DATABASE() { return GetToken(VBAExpressionParser.DATABASE, 0); }
		public ITerminalNode BINARY() { return GetToken(VBAExpressionParser.BINARY, 0); }
		public OptionCompareArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_optionCompareArgument; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterOptionCompareArgument(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitOptionCompareArgument(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOptionCompareArgument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OptionCompareArgumentContext optionCompareArgument() {
		OptionCompareArgumentContext _localctx = new OptionCompareArgumentContext(_ctx, State);
		EnterRule(_localctx, 20, RULE_optionCompareArgument);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 146;
			_la = _input.La(1);
			if ( !(_la==BINARY || _la==DATABASE || _la==TEXT) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BuiltInTypeContext : ParserRuleContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode OBJECT() { return GetToken(VBAExpressionParser.OBJECT, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ReservedTypeIdentifierContext reservedTypeIdentifier() {
			return GetRuleContext<ReservedTypeIdentifierContext>(0);
		}
		public ITerminalNode L_SQUARE_BRACKET() { return GetToken(VBAExpressionParser.L_SQUARE_BRACKET, 0); }
		public ITerminalNode R_SQUARE_BRACKET() { return GetToken(VBAExpressionParser.R_SQUARE_BRACKET, 0); }
		public BuiltInTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_builtInType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterBuiltInType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitBuiltInType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltInType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BuiltInTypeContext builtInType() {
		BuiltInTypeContext _localctx = new BuiltInTypeContext(_ctx, State);
		EnterRule(_localctx, 22, RULE_builtInType);
		int _la;
		try {
			State = 169;
			switch ( Interpreter.AdaptivePredict(_input,9,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 148; reservedTypeIdentifier();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 149; Match(L_SQUARE_BRACKET);
				State = 151;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 150; whiteSpace();
					}
				}

				State = 153; reservedTypeIdentifier();
				State = 155;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 154; whiteSpace();
					}
				}

				State = 157; Match(R_SQUARE_BRACKET);
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 159; Match(OBJECT);
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 160; Match(L_SQUARE_BRACKET);
				State = 162;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 161; whiteSpace();
					}
				}

				State = 164; Match(OBJECT);
				State = 166;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 165; whiteSpace();
					}
				}

				State = 168; Match(R_SQUARE_BRACKET);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
	 
		public ExpressionContext() { }
		public virtual void CopyFrom(ExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class UnaryMinusOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public ITerminalNode MINUS() { return GetToken(VBAExpressionParser.MINUS, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public UnaryMinusOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterUnaryMinusOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitUnaryMinusOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryMinusOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NewExprContext : ExpressionContext {
		public NewExpressionContext newExpression() {
			return GetRuleContext<NewExpressionContext>(0);
		}
		public NewExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterNewExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitNewExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNewExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PowOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode POW() { return GetToken(VBAExpressionParser.POW, 0); }
		public PowOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterPowOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitPowOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPowOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AddOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode PLUS() { return GetToken(VBAExpressionParser.PLUS, 0); }
		public ITerminalNode MINUS() { return GetToken(VBAExpressionParser.MINUS, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public AddOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterAddOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitAddOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAddOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TypeOfIsExprContext : ExpressionContext {
		public TypeOfIsExpressionContext typeOfIsExpression() {
			return GetRuleContext<TypeOfIsExpressionContext>(0);
		}
		public TypeOfIsExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterTypeOfIsExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitTypeOfIsExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeOfIsExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class IntDivOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode INTDIV() { return GetToken(VBAExpressionParser.INTDIV, 0); }
		public IntDivOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterIntDivOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitIntDivOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIntDivOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalImpOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode IMP() { return GetToken(VBAExpressionParser.IMP, 0); }
		public LogicalImpOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLogicalImpOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLogicalImpOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalImpOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ConcatOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode AMPERSAND() { return GetToken(VBAExpressionParser.AMPERSAND, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ConcatOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterConcatOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitConcatOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConcatOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ModOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode MOD() { return GetToken(VBAExpressionParser.MOD, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ModOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterModOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitModOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LExprContext : ExpressionContext {
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public LExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MultOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode MULT() { return GetToken(VBAExpressionParser.MULT, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode DIV() { return GetToken(VBAExpressionParser.DIV, 0); }
		public MultOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterMultOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitMultOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalXorOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode XOR() { return GetToken(VBAExpressionParser.XOR, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public LogicalXorOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLogicalXorOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLogicalXorOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalXorOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalAndOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode AND() { return GetToken(VBAExpressionParser.AND, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public LogicalAndOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLogicalAndOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLogicalAndOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalAndOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalOrOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode OR() { return GetToken(VBAExpressionParser.OR, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public LogicalOrOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLogicalOrOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLogicalOrOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalOrOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RelationalOpContext : ExpressionContext {
		public ITerminalNode GEQ() { return GetToken(VBAExpressionParser.GEQ, 0); }
		public ITerminalNode NEQ() { return GetToken(VBAExpressionParser.NEQ, 0); }
		public ITerminalNode IS() { return GetToken(VBAExpressionParser.IS, 0); }
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode LEQ() { return GetToken(VBAExpressionParser.LEQ, 0); }
		public ITerminalNode LT() { return GetToken(VBAExpressionParser.LT, 0); }
		public ITerminalNode GT() { return GetToken(VBAExpressionParser.GT, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode EQ() { return GetToken(VBAExpressionParser.EQ, 0); }
		public ITerminalNode LIKE() { return GetToken(VBAExpressionParser.LIKE, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public RelationalOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterRelationalOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitRelationalOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelationalOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalEqvOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode EQV() { return GetToken(VBAExpressionParser.EQV, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public LogicalEqvOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLogicalEqvOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLogicalEqvOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalEqvOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ParenthesizedExprContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode LPAREN() { return GetToken(VBAExpressionParser.LPAREN, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode RPAREN() { return GetToken(VBAExpressionParser.RPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ParenthesizedExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterParenthesizedExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitParenthesizedExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParenthesizedExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LiteralExprContext : ExpressionContext {
		public LiteralExpressionContext literalExpression() {
			return GetRuleContext<LiteralExpressionContext>(0);
		}
		public LiteralExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLiteralExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLiteralExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteralExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalNotOpContext : ExpressionContext {
		public ITerminalNode NOT() { return GetToken(VBAExpressionParser.NOT, 0); }
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public LogicalNotOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLogicalNotOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLogicalNotOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalNotOp(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		return expression(0);
	}

	private ExpressionContext expression(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		ExpressionContext _localctx = new ExpressionContext(_ctx, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 24;
		EnterRecursionRule(_localctx, 24, RULE_expression, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 196;
			switch (_input.La(1)) {
			case MINUS:
				{
				_localctx = new UnaryMinusOpContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;

				State = 172; Match(MINUS);
				State = 174;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 173; whiteSpace();
					}
				}

				State = 176; expression(14);
				}
				break;
			case NOT:
				{
				_localctx = new LogicalNotOpContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 177; Match(NOT);
				State = 179;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 178; whiteSpace();
					}
				}

				State = 181; expression(7);
				}
				break;
			case ABS:
			case ARRAY:
			case CBOOL:
			case CBYTE:
			case CCUR:
			case CDATE:
			case CDBL:
			case CDEC:
			case CINT:
			case CIRCLE:
			case CLNG:
			case CLNGLNG:
			case CLNGPTR:
			case CSNG:
			case CSTR:
			case CVAR:
			case CVERR:
			case DEBUG:
			case DOEVENTS:
			case FIX:
			case INPUTB:
			case INT:
			case LBOUND:
			case LEN:
			case LENB:
			case MIDB:
			case MIDBTYPESUFFIX:
			case MIDTYPESUFFIX:
			case PSET:
			case SCALE:
			case SGN:
			case UBOUND:
			case EXCLAMATIONPOINT:
			case DOT:
			case BINARY:
			case DATABASE:
			case INPUT:
			case ME:
			case MID:
			case TEXT:
			case IDENTIFIER:
			case FOREIGNNAME:
			case OBJECT:
				{
				_localctx = new LExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 182; lExpression(0);
				}
				break;
			case LPAREN:
				{
				_localctx = new ParenthesizedExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 183; Match(LPAREN);
				State = 185;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 184; whiteSpace();
					}
				}

				State = 187; expression(0);
				State = 189;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 188; whiteSpace();
					}
				}

				State = 191; Match(RPAREN);
				}
				break;
			case TYPEOF:
				{
				_localctx = new TypeOfIsExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 193; typeOfIsExpression();
				}
				break;
			case NEW:
				{
				_localctx = new NewExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 194; newExpression();
				}
				break;
			case EMPTY:
			case FALSE:
			case NOTHING:
			case NULL:
			case TRUE:
			case STRINGLITERAL:
			case OCTLITERAL:
			case HEXLITERAL:
			case FLOATLITERAL:
			case INTEGERLITERAL:
			case DATELITERAL:
				{
				_localctx = new LiteralExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 195; literalExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			_ctx.stop = _input.Lt(-1);
			State = 308;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,40,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 306;
					switch ( Interpreter.AdaptivePredict(_input,39,_ctx) ) {
					case 1:
						{
						_localctx = new PowOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 198;
						if (!(Precpred(_ctx, 15))) throw new FailedPredicateException(this, "Precpred(_ctx, 15)");
						State = 200;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 199; whiteSpace();
							}
						}

						State = 202; Match(POW);
						State = 204;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 203; whiteSpace();
							}
						}

						State = 206; expression(16);
						}
						break;

					case 2:
						{
						_localctx = new MultOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 207;
						if (!(Precpred(_ctx, 13))) throw new FailedPredicateException(this, "Precpred(_ctx, 13)");
						State = 209;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 208; whiteSpace();
							}
						}

						State = 211;
						_la = _input.La(1);
						if ( !(_la==DIV || _la==MULT) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						State = 213;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 212; whiteSpace();
							}
						}

						State = 215; expression(14);
						}
						break;

					case 3:
						{
						_localctx = new IntDivOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 216;
						if (!(Precpred(_ctx, 12))) throw new FailedPredicateException(this, "Precpred(_ctx, 12)");
						State = 218;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 217; whiteSpace();
							}
						}

						State = 220; Match(INTDIV);
						State = 222;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 221; whiteSpace();
							}
						}

						State = 224; expression(13);
						}
						break;

					case 4:
						{
						_localctx = new ModOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 225;
						if (!(Precpred(_ctx, 11))) throw new FailedPredicateException(this, "Precpred(_ctx, 11)");
						State = 227;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 226; whiteSpace();
							}
						}

						State = 229; Match(MOD);
						State = 231;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 230; whiteSpace();
							}
						}

						State = 233; expression(12);
						}
						break;

					case 5:
						{
						_localctx = new AddOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 234;
						if (!(Precpred(_ctx, 10))) throw new FailedPredicateException(this, "Precpred(_ctx, 10)");
						State = 236;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 235; whiteSpace();
							}
						}

						State = 238;
						_la = _input.La(1);
						if ( !(_la==MINUS || _la==PLUS) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						State = 240;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 239; whiteSpace();
							}
						}

						State = 242; expression(11);
						}
						break;

					case 6:
						{
						_localctx = new ConcatOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 243;
						if (!(Precpred(_ctx, 9))) throw new FailedPredicateException(this, "Precpred(_ctx, 9)");
						State = 245;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 244; whiteSpace();
							}
						}

						State = 247; Match(AMPERSAND);
						State = 249;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 248; whiteSpace();
							}
						}

						State = 251; expression(10);
						}
						break;

					case 7:
						{
						_localctx = new RelationalOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 252;
						if (!(Precpred(_ctx, 8))) throw new FailedPredicateException(this, "Precpred(_ctx, 8)");
						State = 254;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 253; whiteSpace();
							}
						}

						State = 256;
						_la = _input.La(1);
						if ( !(_la==IS || _la==LIKE || ((((_la - 224)) & ~0x3f) == 0 && ((1L << (_la - 224)) & ((1L << (EQ - 224)) | (1L << (GEQ - 224)) | (1L << (GT - 224)) | (1L << (LEQ - 224)) | (1L << (LT - 224)) | (1L << (NEQ - 224)))) != 0)) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						State = 258;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 257; whiteSpace();
							}
						}

						State = 260; expression(9);
						}
						break;

					case 8:
						{
						_localctx = new LogicalAndOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 261;
						if (!(Precpred(_ctx, 6))) throw new FailedPredicateException(this, "Precpred(_ctx, 6)");
						State = 263;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 262; whiteSpace();
							}
						}

						State = 265; Match(AND);
						State = 267;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 266; whiteSpace();
							}
						}

						State = 269; expression(7);
						}
						break;

					case 9:
						{
						_localctx = new LogicalOrOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 270;
						if (!(Precpred(_ctx, 5))) throw new FailedPredicateException(this, "Precpred(_ctx, 5)");
						State = 272;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 271; whiteSpace();
							}
						}

						State = 274; Match(OR);
						State = 276;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 275; whiteSpace();
							}
						}

						State = 278; expression(6);
						}
						break;

					case 10:
						{
						_localctx = new LogicalXorOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 279;
						if (!(Precpred(_ctx, 4))) throw new FailedPredicateException(this, "Precpred(_ctx, 4)");
						State = 281;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 280; whiteSpace();
							}
						}

						State = 283; Match(XOR);
						State = 285;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 284; whiteSpace();
							}
						}

						State = 287; expression(5);
						}
						break;

					case 11:
						{
						_localctx = new LogicalEqvOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 288;
						if (!(Precpred(_ctx, 3))) throw new FailedPredicateException(this, "Precpred(_ctx, 3)");
						State = 290;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 289; whiteSpace();
							}
						}

						State = 292; Match(EQV);
						State = 294;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 293; whiteSpace();
							}
						}

						State = 296; expression(4);
						}
						break;

					case 12:
						{
						_localctx = new LogicalImpOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 297;
						if (!(Precpred(_ctx, 2))) throw new FailedPredicateException(this, "Precpred(_ctx, 2)");
						State = 299;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 298; whiteSpace();
							}
						}

						State = 301; Match(IMP);
						State = 303;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 302; whiteSpace();
							}
						}

						State = 305; expression(3);
						}
						break;
					}
					} 
				}
				State = 310;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,40,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class LiteralExpressionContext : ParserRuleContext {
		public ITerminalNode STRINGLITERAL() { return GetToken(VBAExpressionParser.STRINGLITERAL, 0); }
		public TypeSuffixContext typeSuffix() {
			return GetRuleContext<TypeSuffixContext>(0);
		}
		public ITerminalNode DATELITERAL() { return GetToken(VBAExpressionParser.DATELITERAL, 0); }
		public NumberLiteralContext numberLiteral() {
			return GetRuleContext<NumberLiteralContext>(0);
		}
		public LiteralIdentifierContext literalIdentifier() {
			return GetRuleContext<LiteralIdentifierContext>(0);
		}
		public LiteralExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literalExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLiteralExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLiteralExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteralExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralExpressionContext literalExpression() {
		LiteralExpressionContext _localctx = new LiteralExpressionContext(_ctx, State);
		EnterRule(_localctx, 26, RULE_literalExpression);
		try {
			State = 318;
			switch (_input.La(1)) {
			case OCTLITERAL:
			case HEXLITERAL:
			case FLOATLITERAL:
			case INTEGERLITERAL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 311; numberLiteral();
				}
				break;
			case DATELITERAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 312; Match(DATELITERAL);
				}
				break;
			case STRINGLITERAL:
				EnterOuterAlt(_localctx, 3);
				{
				State = 313; Match(STRINGLITERAL);
				}
				break;
			case EMPTY:
			case FALSE:
			case NOTHING:
			case NULL:
			case TRUE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 314; literalIdentifier();
				State = 316;
				switch ( Interpreter.AdaptivePredict(_input,41,_ctx) ) {
				case 1:
					{
					State = 315; typeSuffix();
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumberLiteralContext : ParserRuleContext {
		public ITerminalNode INTEGERLITERAL() { return GetToken(VBAExpressionParser.INTEGERLITERAL, 0); }
		public ITerminalNode FLOATLITERAL() { return GetToken(VBAExpressionParser.FLOATLITERAL, 0); }
		public ITerminalNode HEXLITERAL() { return GetToken(VBAExpressionParser.HEXLITERAL, 0); }
		public ITerminalNode OCTLITERAL() { return GetToken(VBAExpressionParser.OCTLITERAL, 0); }
		public NumberLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numberLiteral; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterNumberLiteral(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitNumberLiteral(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumberLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumberLiteralContext numberLiteral() {
		NumberLiteralContext _localctx = new NumberLiteralContext(_ctx, State);
		EnterRule(_localctx, 28, RULE_numberLiteral);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 320;
			_la = _input.La(1);
			if ( !(((((_la - 244)) & ~0x3f) == 0 && ((1L << (_la - 244)) & ((1L << (OCTLITERAL - 244)) | (1L << (HEXLITERAL - 244)) | (1L << (FLOATLITERAL - 244)) | (1L << (INTEGERLITERAL - 244)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParenthesizedExpressionContext : ParserRuleContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode LPAREN() { return GetToken(VBAExpressionParser.LPAREN, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode RPAREN() { return GetToken(VBAExpressionParser.RPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ParenthesizedExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parenthesizedExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterParenthesizedExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitParenthesizedExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParenthesizedExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParenthesizedExpressionContext parenthesizedExpression() {
		ParenthesizedExpressionContext _localctx = new ParenthesizedExpressionContext(_ctx, State);
		EnterRule(_localctx, 30, RULE_parenthesizedExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 322; Match(LPAREN);
			State = 324;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 323; whiteSpace();
				}
			}

			State = 326; expression(0);
			State = 328;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 327; whiteSpace();
				}
			}

			State = 330; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeOfIsExpressionContext : ParserRuleContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode IS() { return GetToken(VBAExpressionParser.IS, 0); }
		public ITerminalNode TYPEOF() { return GetToken(VBAExpressionParser.TYPEOF, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public TypeExpressionContext typeExpression() {
			return GetRuleContext<TypeExpressionContext>(0);
		}
		public TypeOfIsExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeOfIsExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterTypeOfIsExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitTypeOfIsExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeOfIsExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeOfIsExpressionContext typeOfIsExpression() {
		TypeOfIsExpressionContext _localctx = new TypeOfIsExpressionContext(_ctx, State);
		EnterRule(_localctx, 32, RULE_typeOfIsExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 332; Match(TYPEOF);
			State = 333; whiteSpace();
			State = 334; expression(0);
			State = 335; whiteSpace();
			State = 336; Match(IS);
			State = 337; whiteSpace();
			State = 338; typeExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NewExpressionContext : ParserRuleContext {
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public ITerminalNode NEW() { return GetToken(VBAExpressionParser.NEW, 0); }
		public TypeExpressionContext typeExpression() {
			return GetRuleContext<TypeExpressionContext>(0);
		}
		public NewExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_newExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterNewExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitNewExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNewExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NewExpressionContext newExpression() {
		NewExpressionContext _localctx = new NewExpressionContext(_ctx, State);
		EnterRule(_localctx, 34, RULE_newExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 340; Match(NEW);
			State = 341; whiteSpace();
			State = 342; typeExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LExpressionContext : ParserRuleContext {
		public LExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lExpression; } }
	 
		public LExpressionContext() { }
		public virtual void CopyFrom(LExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class IndexExprContext : LExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode LPAREN() { return GetToken(VBAExpressionParser.LPAREN, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode RPAREN() { return GetToken(VBAExpressionParser.RPAREN, 0); }
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public ArgumentListContext argumentList() {
			return GetRuleContext<ArgumentListContext>(0);
		}
		public IndexExprContext(LExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterIndexExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitIndexExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndexExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SimpleNameExprContext : LExpressionContext {
		public SimpleNameExpressionContext simpleNameExpression() {
			return GetRuleContext<SimpleNameExpressionContext>(0);
		}
		public SimpleNameExprContext(LExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterSimpleNameExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitSimpleNameExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleNameExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MemberAccessExprContext : LExpressionContext {
		public ITerminalNode DOT() { return GetToken(VBAExpressionParser.DOT, 0); }
		public ITerminalNode LINE_CONTINUATION() { return GetToken(VBAExpressionParser.LINE_CONTINUATION, 0); }
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public MemberAccessExprContext(LExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterMemberAccessExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitMemberAccessExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemberAccessExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class InstanceExprContext : LExpressionContext {
		public InstanceExpressionContext instanceExpression() {
			return GetRuleContext<InstanceExpressionContext>(0);
		}
		public InstanceExprContext(LExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterInstanceExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitInstanceExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInstanceExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class WithExprContext : LExpressionContext {
		public WithExpressionContext withExpression() {
			return GetRuleContext<WithExpressionContext>(0);
		}
		public WithExprContext(LExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterWithExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitWithExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWithExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DictionaryAccessExprContext : LExpressionContext {
		public IReadOnlyList<ITerminalNode> LINE_CONTINUATION() { return GetTokens(VBAExpressionParser.LINE_CONTINUATION); }
		public ITerminalNode EXCLAMATIONPOINT() { return GetToken(VBAExpressionParser.EXCLAMATIONPOINT, 0); }
		public ITerminalNode LINE_CONTINUATION(int i) {
			return GetToken(VBAExpressionParser.LINE_CONTINUATION, i);
		}
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public DictionaryAccessExprContext(LExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterDictionaryAccessExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitDictionaryAccessExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDictionaryAccessExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LExpressionContext lExpression() {
		return lExpression(0);
	}

	private LExpressionContext lExpression(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		LExpressionContext _localctx = new LExpressionContext(_ctx, _parentState);
		LExpressionContext _prevctx = _localctx;
		int _startState = 36;
		EnterRecursionRule(_localctx, 36, RULE_lExpression, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 348;
			switch (_input.La(1)) {
			case ME:
				{
				_localctx = new InstanceExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;

				State = 345; instanceExpression();
				}
				break;
			case ABS:
			case ARRAY:
			case CBOOL:
			case CBYTE:
			case CCUR:
			case CDATE:
			case CDBL:
			case CDEC:
			case CINT:
			case CIRCLE:
			case CLNG:
			case CLNGLNG:
			case CLNGPTR:
			case CSNG:
			case CSTR:
			case CVAR:
			case CVERR:
			case DEBUG:
			case DOEVENTS:
			case FIX:
			case INPUTB:
			case INT:
			case LBOUND:
			case LEN:
			case LENB:
			case MIDB:
			case MIDBTYPESUFFIX:
			case MIDTYPESUFFIX:
			case PSET:
			case SCALE:
			case SGN:
			case UBOUND:
			case BINARY:
			case DATABASE:
			case INPUT:
			case MID:
			case TEXT:
			case IDENTIFIER:
			case FOREIGNNAME:
			case OBJECT:
				{
				_localctx = new SimpleNameExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 346; simpleNameExpression();
				}
				break;
			case EXCLAMATIONPOINT:
			case DOT:
				{
				_localctx = new WithExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 347; withExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			_ctx.stop = _input.Lt(-1);
			State = 389;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,52,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 387;
					switch ( Interpreter.AdaptivePredict(_input,51,_ctx) ) {
					case 1:
						{
						_localctx = new IndexExprContext(new LExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_lExpression);
						State = 350;
						if (!(Precpred(_ctx, 9))) throw new FailedPredicateException(this, "Precpred(_ctx, 9)");
						State = 352;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 351; whiteSpace();
							}
						}

						State = 354; Match(LPAREN);
						State = 356;
						switch ( Interpreter.AdaptivePredict(_input,47,_ctx) ) {
						case 1:
							{
							State = 355; whiteSpace();
							}
							break;
						}
						State = 359;
						switch ( Interpreter.AdaptivePredict(_input,48,_ctx) ) {
						case 1:
							{
							State = 358; argumentList();
							}
							break;
						}
						State = 362;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 361; whiteSpace();
							}
						}

						State = 364; Match(RPAREN);
						}
						break;

					case 2:
						{
						_localctx = new MemberAccessExprContext(new LExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_lExpression);
						State = 365;
						if (!(Precpred(_ctx, 8))) throw new FailedPredicateException(this, "Precpred(_ctx, 8)");
						State = 366; Match(DOT);
						State = 367; unrestrictedName();
						}
						break;

					case 3:
						{
						_localctx = new MemberAccessExprContext(new LExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_lExpression);
						State = 368;
						if (!(Precpred(_ctx, 7))) throw new FailedPredicateException(this, "Precpred(_ctx, 7)");
						State = 369; Match(LINE_CONTINUATION);
						State = 371;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 370; whiteSpace();
							}
						}

						State = 373; Match(DOT);
						State = 374; unrestrictedName();
						}
						break;

					case 4:
						{
						_localctx = new DictionaryAccessExprContext(new LExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_lExpression);
						State = 375;
						if (!(Precpred(_ctx, 6))) throw new FailedPredicateException(this, "Precpred(_ctx, 6)");
						State = 376; Match(EXCLAMATIONPOINT);
						State = 377; unrestrictedName();
						}
						break;

					case 5:
						{
						_localctx = new DictionaryAccessExprContext(new LExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_lExpression);
						State = 378;
						if (!(Precpred(_ctx, 5))) throw new FailedPredicateException(this, "Precpred(_ctx, 5)");
						State = 379; Match(LINE_CONTINUATION);
						State = 380; Match(EXCLAMATIONPOINT);
						State = 381; unrestrictedName();
						}
						break;

					case 6:
						{
						_localctx = new DictionaryAccessExprContext(new LExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_lExpression);
						State = 382;
						if (!(Precpred(_ctx, 4))) throw new FailedPredicateException(this, "Precpred(_ctx, 4)");
						State = 383; Match(LINE_CONTINUATION);
						State = 384; Match(EXCLAMATIONPOINT);
						State = 385; Match(LINE_CONTINUATION);
						State = 386; unrestrictedName();
						}
						break;
					}
					} 
				}
				State = 391;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,52,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class MemberAccessExpressionContext : ParserRuleContext {
		public ITerminalNode DOT() { return GetToken(VBAExpressionParser.DOT, 0); }
		public ITerminalNode LINE_CONTINUATION() { return GetToken(VBAExpressionParser.LINE_CONTINUATION, 0); }
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public MemberAccessExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_memberAccessExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterMemberAccessExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitMemberAccessExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemberAccessExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MemberAccessExpressionContext memberAccessExpression() {
		MemberAccessExpressionContext _localctx = new MemberAccessExpressionContext(_ctx, State);
		EnterRule(_localctx, 38, RULE_memberAccessExpression);
		int _la;
		try {
			State = 404;
			switch ( Interpreter.AdaptivePredict(_input,54,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 392; lExpression(0);
				State = 393; Match(DOT);
				State = 394; unrestrictedName();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 396; lExpression(0);
				State = 397; Match(LINE_CONTINUATION);
				State = 399;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 398; whiteSpace();
					}
				}

				State = 401; Match(DOT);
				State = 402; unrestrictedName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexExpressionContext : ParserRuleContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode LPAREN() { return GetToken(VBAExpressionParser.LPAREN, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode RPAREN() { return GetToken(VBAExpressionParser.RPAREN, 0); }
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public ArgumentListContext argumentList() {
			return GetRuleContext<ArgumentListContext>(0);
		}
		public IndexExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterIndexExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitIndexExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndexExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IndexExpressionContext indexExpression() {
		IndexExpressionContext _localctx = new IndexExpressionContext(_ctx, State);
		EnterRule(_localctx, 40, RULE_indexExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 406; lExpression(0);
			State = 408;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 407; whiteSpace();
				}
			}

			State = 410; Match(LPAREN);
			State = 412;
			switch ( Interpreter.AdaptivePredict(_input,56,_ctx) ) {
			case 1:
				{
				State = 411; whiteSpace();
				}
				break;
			}
			State = 415;
			switch ( Interpreter.AdaptivePredict(_input,57,_ctx) ) {
			case 1:
				{
				State = 414; argumentList();
				}
				break;
			}
			State = 418;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 417; whiteSpace();
				}
			}

			State = 420; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DictionaryAccessExpressionContext : ParserRuleContext {
		public IReadOnlyList<ITerminalNode> LINE_CONTINUATION() { return GetTokens(VBAExpressionParser.LINE_CONTINUATION); }
		public ITerminalNode EXCLAMATIONPOINT() { return GetToken(VBAExpressionParser.EXCLAMATIONPOINT, 0); }
		public ITerminalNode LINE_CONTINUATION(int i) {
			return GetToken(VBAExpressionParser.LINE_CONTINUATION, i);
		}
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public DictionaryAccessExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dictionaryAccessExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterDictionaryAccessExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitDictionaryAccessExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDictionaryAccessExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DictionaryAccessExpressionContext dictionaryAccessExpression() {
		DictionaryAccessExpressionContext _localctx = new DictionaryAccessExpressionContext(_ctx, State);
		EnterRule(_localctx, 42, RULE_dictionaryAccessExpression);
		try {
			State = 437;
			switch ( Interpreter.AdaptivePredict(_input,59,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 422; lExpression(0);
				State = 423; Match(EXCLAMATIONPOINT);
				State = 424; unrestrictedName();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 426; lExpression(0);
				State = 427; Match(LINE_CONTINUATION);
				State = 428; Match(EXCLAMATIONPOINT);
				State = 429; unrestrictedName();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 431; lExpression(0);
				State = 432; Match(LINE_CONTINUATION);
				State = 433; Match(EXCLAMATIONPOINT);
				State = 434; Match(LINE_CONTINUATION);
				State = 435; unrestrictedName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentListContext : ParserRuleContext {
		public PositionalOrNamedArgumentListContext positionalOrNamedArgumentList() {
			return GetRuleContext<PositionalOrNamedArgumentListContext>(0);
		}
		public ArgumentListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argumentList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterArgumentList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitArgumentList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgumentList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentListContext argumentList() {
		ArgumentListContext _localctx = new ArgumentListContext(_ctx, State);
		EnterRule(_localctx, 44, RULE_argumentList);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 439; positionalOrNamedArgumentList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PositionalOrNamedArgumentListContext : ParserRuleContext {
		public RequiredPositionalArgumentContext requiredPositionalArgument() {
			return GetRuleContext<RequiredPositionalArgumentContext>(0);
		}
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public IReadOnlyList<ITerminalNode> COMMA() { return GetTokens(VBAExpressionParser.COMMA); }
		public IReadOnlyList<PositionalArgumentContext> positionalArgument() {
			return GetRuleContexts<PositionalArgumentContext>();
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public NamedArgumentListContext namedArgumentList() {
			return GetRuleContext<NamedArgumentListContext>(0);
		}
		public ITerminalNode COMMA(int i) {
			return GetToken(VBAExpressionParser.COMMA, i);
		}
		public PositionalArgumentContext positionalArgument(int i) {
			return GetRuleContext<PositionalArgumentContext>(i);
		}
		public PositionalOrNamedArgumentListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_positionalOrNamedArgumentList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterPositionalOrNamedArgumentList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitPositionalOrNamedArgumentList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPositionalOrNamedArgumentList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PositionalOrNamedArgumentListContext positionalOrNamedArgumentList() {
		PositionalOrNamedArgumentListContext _localctx = new PositionalOrNamedArgumentListContext(_ctx, State);
		EnterRule(_localctx, 46, RULE_positionalOrNamedArgumentList);
		int _la;
		try {
			int _alt;
			State = 473;
			switch ( Interpreter.AdaptivePredict(_input,68,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 453;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,63,_ctx);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 442;
						_la = _input.La(1);
						if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ABS) | (1L << ARRAY) | (1L << CBOOL) | (1L << CBYTE) | (1L << CCUR) | (1L << CDATE) | (1L << CDBL) | (1L << CDEC) | (1L << CINT) | (1L << CIRCLE) | (1L << CLNG) | (1L << CLNGLNG) | (1L << CLNGPTR) | (1L << CSNG) | (1L << CSTR) | (1L << CVAR) | (1L << CVERR) | (1L << DEBUG) | (1L << DOEVENTS) | (1L << FIX) | (1L << INPUTB) | (1L << INT) | (1L << LBOUND) | (1L << LEN) | (1L << LENB) | (1L << MIDB) | (1L << MIDBTYPESUFFIX) | (1L << MIDTYPESUFFIX) | (1L << PSET) | (1L << SCALE) | (1L << SGN) | (1L << UBOUND) | (1L << EXCLAMATIONPOINT) | (1L << DOT) | (1L << ADDRESSOF) | (1L << BINARY) | (1L << BYVAL))) != 0) || ((((_la - 71)) & ~0x3f) == 0 && ((1L << (_la - 71)) & ((1L << (DATABASE - 71)) | (1L << (EMPTY - 71)) | (1L << (FALSE - 71)) | (1L << (INPUT - 71)))) != 0) || ((((_la - 143)) & ~0x3f) == 0 && ((1L << (_la - 143)) & ((1L << (ME - 143)) | (1L << (MID - 143)) | (1L << (NEW - 143)) | (1L << (NOT - 143)) | (1L << (NOTHING - 143)) | (1L << (NULL - 143)) | (1L << (TEXT - 143)) | (1L << (TRUE - 143)))) != 0) || ((((_la - 208)) & ~0x3f) == 0 && ((1L << (_la - 208)) & ((1L << (TYPEOF - 208)) | (1L << (LPAREN - 208)) | (1L << (MINUS - 208)) | (1L << (STRINGLITERAL - 208)) | (1L << (OCTLITERAL - 208)) | (1L << (HEXLITERAL - 208)) | (1L << (FLOATLITERAL - 208)) | (1L << (INTEGERLITERAL - 208)) | (1L << (DATELITERAL - 208)) | (1L << (IDENTIFIER - 208)) | (1L << (FOREIGNNAME - 208)) | (1L << (OBJECT - 208)))) != 0)) {
							{
							State = 441; positionalArgument();
							}
						}

						State = 445;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 444; whiteSpace();
							}
						}

						State = 447; Match(COMMA);
						State = 449;
						switch ( Interpreter.AdaptivePredict(_input,62,_ctx) ) {
						case 1:
							{
							State = 448; whiteSpace();
							}
							break;
						}
						}
						} 
					}
					State = 455;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,63,_ctx);
				}
				State = 456; requiredPositionalArgument();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 469;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,67,_ctx);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 458;
						_la = _input.La(1);
						if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ABS) | (1L << ARRAY) | (1L << CBOOL) | (1L << CBYTE) | (1L << CCUR) | (1L << CDATE) | (1L << CDBL) | (1L << CDEC) | (1L << CINT) | (1L << CIRCLE) | (1L << CLNG) | (1L << CLNGLNG) | (1L << CLNGPTR) | (1L << CSNG) | (1L << CSTR) | (1L << CVAR) | (1L << CVERR) | (1L << DEBUG) | (1L << DOEVENTS) | (1L << FIX) | (1L << INPUTB) | (1L << INT) | (1L << LBOUND) | (1L << LEN) | (1L << LENB) | (1L << MIDB) | (1L << MIDBTYPESUFFIX) | (1L << MIDTYPESUFFIX) | (1L << PSET) | (1L << SCALE) | (1L << SGN) | (1L << UBOUND) | (1L << EXCLAMATIONPOINT) | (1L << DOT) | (1L << ADDRESSOF) | (1L << BINARY) | (1L << BYVAL))) != 0) || ((((_la - 71)) & ~0x3f) == 0 && ((1L << (_la - 71)) & ((1L << (DATABASE - 71)) | (1L << (EMPTY - 71)) | (1L << (FALSE - 71)) | (1L << (INPUT - 71)))) != 0) || ((((_la - 143)) & ~0x3f) == 0 && ((1L << (_la - 143)) & ((1L << (ME - 143)) | (1L << (MID - 143)) | (1L << (NEW - 143)) | (1L << (NOT - 143)) | (1L << (NOTHING - 143)) | (1L << (NULL - 143)) | (1L << (TEXT - 143)) | (1L << (TRUE - 143)))) != 0) || ((((_la - 208)) & ~0x3f) == 0 && ((1L << (_la - 208)) & ((1L << (TYPEOF - 208)) | (1L << (LPAREN - 208)) | (1L << (MINUS - 208)) | (1L << (STRINGLITERAL - 208)) | (1L << (OCTLITERAL - 208)) | (1L << (HEXLITERAL - 208)) | (1L << (FLOATLITERAL - 208)) | (1L << (INTEGERLITERAL - 208)) | (1L << (DATELITERAL - 208)) | (1L << (IDENTIFIER - 208)) | (1L << (FOREIGNNAME - 208)) | (1L << (OBJECT - 208)))) != 0)) {
							{
							State = 457; positionalArgument();
							}
						}

						State = 461;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 460; whiteSpace();
							}
						}

						State = 463; Match(COMMA);
						State = 465;
						switch ( Interpreter.AdaptivePredict(_input,66,_ctx) ) {
						case 1:
							{
							State = 464; whiteSpace();
							}
							break;
						}
						}
						} 
					}
					State = 471;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,67,_ctx);
				}
				State = 472; namedArgumentList();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PositionalArgumentContext : ParserRuleContext {
		public ArgumentExpressionContext argumentExpression() {
			return GetRuleContext<ArgumentExpressionContext>(0);
		}
		public PositionalArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_positionalArgument; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterPositionalArgument(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitPositionalArgument(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPositionalArgument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PositionalArgumentContext positionalArgument() {
		PositionalArgumentContext _localctx = new PositionalArgumentContext(_ctx, State);
		EnterRule(_localctx, 48, RULE_positionalArgument);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 475; argumentExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RequiredPositionalArgumentContext : ParserRuleContext {
		public ArgumentExpressionContext argumentExpression() {
			return GetRuleContext<ArgumentExpressionContext>(0);
		}
		public RequiredPositionalArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_requiredPositionalArgument; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterRequiredPositionalArgument(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitRequiredPositionalArgument(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRequiredPositionalArgument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RequiredPositionalArgumentContext requiredPositionalArgument() {
		RequiredPositionalArgumentContext _localctx = new RequiredPositionalArgumentContext(_ctx, State);
		EnterRule(_localctx, 50, RULE_requiredPositionalArgument);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 477; argumentExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NamedArgumentListContext : ParserRuleContext {
		public IReadOnlyList<NamedArgumentContext> namedArgument() {
			return GetRuleContexts<NamedArgumentContext>();
		}
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public IReadOnlyList<ITerminalNode> COMMA() { return GetTokens(VBAExpressionParser.COMMA); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public NamedArgumentContext namedArgument(int i) {
			return GetRuleContext<NamedArgumentContext>(i);
		}
		public ITerminalNode COMMA(int i) {
			return GetToken(VBAExpressionParser.COMMA, i);
		}
		public NamedArgumentListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_namedArgumentList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterNamedArgumentList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitNamedArgumentList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNamedArgumentList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NamedArgumentListContext namedArgumentList() {
		NamedArgumentListContext _localctx = new NamedArgumentListContext(_ctx, State);
		EnterRule(_localctx, 52, RULE_namedArgumentList);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 479; namedArgument();
			State = 490;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,71,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 481;
					_la = _input.La(1);
					if (_la==WS || _la==LINE_CONTINUATION) {
						{
						State = 480; whiteSpace();
						}
					}

					State = 483; Match(COMMA);
					State = 485;
					_la = _input.La(1);
					if (_la==WS || _la==LINE_CONTINUATION) {
						{
						State = 484; whiteSpace();
						}
					}

					State = 487; namedArgument();
					}
					} 
				}
				State = 492;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,71,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NamedArgumentContext : ParserRuleContext {
		public ITerminalNode ASSIGN() { return GetToken(VBAExpressionParser.ASSIGN, 0); }
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ArgumentExpressionContext argumentExpression() {
			return GetRuleContext<ArgumentExpressionContext>(0);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public NamedArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_namedArgument; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterNamedArgument(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitNamedArgument(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNamedArgument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NamedArgumentContext namedArgument() {
		NamedArgumentContext _localctx = new NamedArgumentContext(_ctx, State);
		EnterRule(_localctx, 54, RULE_namedArgument);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 493; unrestrictedName();
			State = 495;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 494; whiteSpace();
				}
			}

			State = 497; Match(ASSIGN);
			State = 499;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 498; whiteSpace();
				}
			}

			State = 501; argumentExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentExpressionContext : ParserRuleContext {
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public AddressOfExpressionContext addressOfExpression() {
			return GetRuleContext<AddressOfExpressionContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode BYVAL() { return GetToken(VBAExpressionParser.BYVAL, 0); }
		public ArgumentExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argumentExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterArgumentExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitArgumentExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgumentExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentExpressionContext argumentExpression() {
		ArgumentExpressionContext _localctx = new ArgumentExpressionContext(_ctx, State);
		EnterRule(_localctx, 56, RULE_argumentExpression);
		int _la;
		try {
			State = 509;
			switch (_input.La(1)) {
			case ABS:
			case ARRAY:
			case CBOOL:
			case CBYTE:
			case CCUR:
			case CDATE:
			case CDBL:
			case CDEC:
			case CINT:
			case CIRCLE:
			case CLNG:
			case CLNGLNG:
			case CLNGPTR:
			case CSNG:
			case CSTR:
			case CVAR:
			case CVERR:
			case DEBUG:
			case DOEVENTS:
			case FIX:
			case INPUTB:
			case INT:
			case LBOUND:
			case LEN:
			case LENB:
			case MIDB:
			case MIDBTYPESUFFIX:
			case MIDTYPESUFFIX:
			case PSET:
			case SCALE:
			case SGN:
			case UBOUND:
			case EXCLAMATIONPOINT:
			case DOT:
			case BINARY:
			case BYVAL:
			case DATABASE:
			case EMPTY:
			case FALSE:
			case INPUT:
			case ME:
			case MID:
			case NEW:
			case NOT:
			case NOTHING:
			case NULL:
			case TEXT:
			case TRUE:
			case TYPEOF:
			case LPAREN:
			case MINUS:
			case STRINGLITERAL:
			case OCTLITERAL:
			case HEXLITERAL:
			case FLOATLITERAL:
			case INTEGERLITERAL:
			case DATELITERAL:
			case IDENTIFIER:
			case FOREIGNNAME:
			case OBJECT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 505;
				_la = _input.La(1);
				if (_la==BYVAL) {
					{
					State = 503; Match(BYVAL);
					State = 504; whiteSpace();
					}
				}

				State = 507; expression(0);
				}
				break;
			case ADDRESSOF:
				EnterOuterAlt(_localctx, 2);
				{
				State = 508; addressOfExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleNameExpressionContext : ParserRuleContext {
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public SimpleNameExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleNameExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterSimpleNameExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitSimpleNameExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleNameExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SimpleNameExpressionContext simpleNameExpression() {
		SimpleNameExpressionContext _localctx = new SimpleNameExpressionContext(_ctx, State);
		EnterRule(_localctx, 58, RULE_simpleNameExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 511; name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InstanceExpressionContext : ParserRuleContext {
		public ITerminalNode ME() { return GetToken(VBAExpressionParser.ME, 0); }
		public InstanceExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_instanceExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterInstanceExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitInstanceExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInstanceExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InstanceExpressionContext instanceExpression() {
		InstanceExpressionContext _localctx = new InstanceExpressionContext(_ctx, State);
		EnterRule(_localctx, 60, RULE_instanceExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 513; Match(ME);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithExpressionContext : ParserRuleContext {
		public WithDictionaryAccessExpressionContext withDictionaryAccessExpression() {
			return GetRuleContext<WithDictionaryAccessExpressionContext>(0);
		}
		public WithMemberAccessExpressionContext withMemberAccessExpression() {
			return GetRuleContext<WithMemberAccessExpressionContext>(0);
		}
		public WithExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterWithExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitWithExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWithExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WithExpressionContext withExpression() {
		WithExpressionContext _localctx = new WithExpressionContext(_ctx, State);
		EnterRule(_localctx, 62, RULE_withExpression);
		try {
			State = 517;
			switch (_input.La(1)) {
			case DOT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 515; withMemberAccessExpression();
				}
				break;
			case EXCLAMATIONPOINT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 516; withDictionaryAccessExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithMemberAccessExpressionContext : ParserRuleContext {
		public ITerminalNode DOT() { return GetToken(VBAExpressionParser.DOT, 0); }
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public WithMemberAccessExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withMemberAccessExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterWithMemberAccessExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitWithMemberAccessExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWithMemberAccessExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WithMemberAccessExpressionContext withMemberAccessExpression() {
		WithMemberAccessExpressionContext _localctx = new WithMemberAccessExpressionContext(_ctx, State);
		EnterRule(_localctx, 64, RULE_withMemberAccessExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 519; Match(DOT);
			State = 520; unrestrictedName();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithDictionaryAccessExpressionContext : ParserRuleContext {
		public ITerminalNode EXCLAMATIONPOINT() { return GetToken(VBAExpressionParser.EXCLAMATIONPOINT, 0); }
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public WithDictionaryAccessExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withDictionaryAccessExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterWithDictionaryAccessExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitWithDictionaryAccessExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWithDictionaryAccessExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WithDictionaryAccessExpressionContext withDictionaryAccessExpression() {
		WithDictionaryAccessExpressionContext _localctx = new WithDictionaryAccessExpressionContext(_ctx, State);
		EnterRule(_localctx, 66, RULE_withDictionaryAccessExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 522; Match(EXCLAMATIONPOINT);
			State = 523; unrestrictedName();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstantExpressionContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ConstantExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constantExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterConstantExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitConstantExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstantExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstantExpressionContext constantExpression() {
		ConstantExpressionContext _localctx = new ConstantExpressionContext(_ctx, State);
		EnterRule(_localctx, 68, RULE_constantExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 525; expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeExpressionContext : ParserRuleContext {
		public DefinedTypeExpressionContext definedTypeExpression() {
			return GetRuleContext<DefinedTypeExpressionContext>(0);
		}
		public BuiltInTypeContext builtInType() {
			return GetRuleContext<BuiltInTypeContext>(0);
		}
		public TypeExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterTypeExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitTypeExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeExpressionContext typeExpression() {
		TypeExpressionContext _localctx = new TypeExpressionContext(_ctx, State);
		EnterRule(_localctx, 70, RULE_typeExpression);
		try {
			State = 529;
			switch ( Interpreter.AdaptivePredict(_input,77,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 527; builtInType();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 528; definedTypeExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DefinedTypeExpressionContext : ParserRuleContext {
		public MemberAccessExpressionContext memberAccessExpression() {
			return GetRuleContext<MemberAccessExpressionContext>(0);
		}
		public SimpleNameExpressionContext simpleNameExpression() {
			return GetRuleContext<SimpleNameExpressionContext>(0);
		}
		public DefinedTypeExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_definedTypeExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterDefinedTypeExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitDefinedTypeExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDefinedTypeExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DefinedTypeExpressionContext definedTypeExpression() {
		DefinedTypeExpressionContext _localctx = new DefinedTypeExpressionContext(_ctx, State);
		EnterRule(_localctx, 72, RULE_definedTypeExpression);
		try {
			State = 533;
			switch ( Interpreter.AdaptivePredict(_input,78,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 531; simpleNameExpression();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 532; memberAccessExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AddressOfExpressionContext : ParserRuleContext {
		public ITerminalNode ADDRESSOF() { return GetToken(VBAExpressionParser.ADDRESSOF, 0); }
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public ProcedurePointerExpressionContext procedurePointerExpression() {
			return GetRuleContext<ProcedurePointerExpressionContext>(0);
		}
		public AddressOfExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_addressOfExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterAddressOfExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitAddressOfExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAddressOfExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AddressOfExpressionContext addressOfExpression() {
		AddressOfExpressionContext _localctx = new AddressOfExpressionContext(_ctx, State);
		EnterRule(_localctx, 74, RULE_addressOfExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 535; Match(ADDRESSOF);
			State = 536; whiteSpace();
			State = 537; procedurePointerExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProcedurePointerExpressionContext : ParserRuleContext {
		public MemberAccessExpressionContext memberAccessExpression() {
			return GetRuleContext<MemberAccessExpressionContext>(0);
		}
		public SimpleNameExpressionContext simpleNameExpression() {
			return GetRuleContext<SimpleNameExpressionContext>(0);
		}
		public ProcedurePointerExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedurePointerExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterProcedurePointerExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitProcedurePointerExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProcedurePointerExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProcedurePointerExpressionContext procedurePointerExpression() {
		ProcedurePointerExpressionContext _localctx = new ProcedurePointerExpressionContext(_ctx, State);
		EnterRule(_localctx, 76, RULE_procedurePointerExpression);
		try {
			State = 541;
			switch ( Interpreter.AdaptivePredict(_input,79,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 539; memberAccessExpression();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 540; simpleNameExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedIdentifierContext : ParserRuleContext {
		public MarkerKeywordContext markerKeyword() {
			return GetRuleContext<MarkerKeywordContext>(0);
		}
		public SpecialFormContext specialForm() {
			return GetRuleContext<SpecialFormContext>(0);
		}
		public ReservedTypeIdentifierContext reservedTypeIdentifier() {
			return GetRuleContext<ReservedTypeIdentifierContext>(0);
		}
		public OperatorIdentifierContext operatorIdentifier() {
			return GetRuleContext<OperatorIdentifierContext>(0);
		}
		public RemKeywordContext remKeyword() {
			return GetRuleContext<RemKeywordContext>(0);
		}
		public ReservedNameContext reservedName() {
			return GetRuleContext<ReservedNameContext>(0);
		}
		public StatementKeywordContext statementKeyword() {
			return GetRuleContext<StatementKeywordContext>(0);
		}
		public LiteralIdentifierContext literalIdentifier() {
			return GetRuleContext<LiteralIdentifierContext>(0);
		}
		public ReservedIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedIdentifierContext reservedIdentifier() {
		ReservedIdentifierContext _localctx = new ReservedIdentifierContext(_ctx, State);
		EnterRule(_localctx, 78, RULE_reservedIdentifier);
		try {
			State = 551;
			switch ( Interpreter.AdaptivePredict(_input,80,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 543; statementKeyword();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 544; markerKeyword();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 545; operatorIdentifier();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 546; specialForm();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 547; reservedName();
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 548; literalIdentifier();
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 549; remKeyword();
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 550; reservedTypeIdentifier();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementKeywordContext : ParserRuleContext {
		public ITerminalNode CASE() { return GetToken(VBAExpressionParser.CASE, 0); }
		public ITerminalNode DEFOBJ() { return GetToken(VBAExpressionParser.DEFOBJ, 0); }
		public ITerminalNode ELSE() { return GetToken(VBAExpressionParser.ELSE, 0); }
		public ITerminalNode LOCK_WRITE() { return GetToken(VBAExpressionParser.LOCK_WRITE, 0); }
		public ITerminalNode IF() { return GetToken(VBAExpressionParser.IF, 0); }
		public ITerminalNode RESET() { return GetToken(VBAExpressionParser.RESET, 0); }
		public ITerminalNode ERASE() { return GetToken(VBAExpressionParser.ERASE, 0); }
		public ITerminalNode WRITE(int i) {
			return GetToken(VBAExpressionParser.WRITE, i);
		}
		public ITerminalNode END_SELECT() { return GetToken(VBAExpressionParser.END_SELECT, 0); }
		public ITerminalNode ON_ERROR() { return GetToken(VBAExpressionParser.ON_ERROR, 0); }
		public ITerminalNode END_IF() { return GetToken(VBAExpressionParser.END_IF, 0); }
		public ITerminalNode RAISEEVENT() { return GetToken(VBAExpressionParser.RAISEEVENT, 0); }
		public ITerminalNode STOP() { return GetToken(VBAExpressionParser.STOP, 0); }
		public ITerminalNode SHARED() { return GetToken(VBAExpressionParser.SHARED, 0); }
		public ITerminalNode APPEND() { return GetToken(VBAExpressionParser.APPEND, 0); }
		public ITerminalNode PRIVATE() { return GetToken(VBAExpressionParser.PRIVATE, 0); }
		public ITerminalNode DEFBYTE() { return GetToken(VBAExpressionParser.DEFBYTE, 0); }
		public ITerminalNode DEFSNG() { return GetToken(VBAExpressionParser.DEFSNG, 0); }
		public ITerminalNode GOSUB() { return GetToken(VBAExpressionParser.GOSUB, 0); }
		public ITerminalNode RETURN() { return GetToken(VBAExpressionParser.RETURN, 0); }
		public ITerminalNode ENUM() { return GetToken(VBAExpressionParser.ENUM, 0); }
		public ITerminalNode LOCK() { return GetToken(VBAExpressionParser.LOCK, 0); }
		public ITerminalNode GLOBAL() { return GetToken(VBAExpressionParser.GLOBAL, 0); }
		public ITerminalNode WEND() { return GetToken(VBAExpressionParser.WEND, 0); }
		public ITerminalNode DEFSTR() { return GetToken(VBAExpressionParser.DEFSTR, 0); }
		public ITerminalNode DEFLNGLNG() { return GetToken(VBAExpressionParser.DEFLNGLNG, 0); }
		public ITerminalNode DEFVAR() { return GetToken(VBAExpressionParser.DEFVAR, 0); }
		public ITerminalNode EXIT_DO() { return GetToken(VBAExpressionParser.EXIT_DO, 0); }
		public ITerminalNode EVENT() { return GetToken(VBAExpressionParser.EVENT, 0); }
		public ITerminalNode CONST() { return GetToken(VBAExpressionParser.CONST, 0); }
		public ITerminalNode ELSEIF() { return GetToken(VBAExpressionParser.ELSEIF, 0); }
		public ITerminalNode PRINT() { return GetToken(VBAExpressionParser.PRINT, 0); }
		public ITerminalNode DEFINT() { return GetToken(VBAExpressionParser.DEFINT, 0); }
		public ITerminalNode SUB() { return GetToken(VBAExpressionParser.SUB, 0); }
		public ITerminalNode FOR() { return GetToken(VBAExpressionParser.FOR, 0); }
		public ITerminalNode LSET() { return GetToken(VBAExpressionParser.LSET, 0); }
		public ITerminalNode WIDTH() { return GetToken(VBAExpressionParser.WIDTH, 0); }
		public ITerminalNode INPUT() { return GetToken(VBAExpressionParser.INPUT, 0); }
		public ITerminalNode STEP() { return GetToken(VBAExpressionParser.STEP, 0); }
		public ITerminalNode SEEK() { return GetToken(VBAExpressionParser.SEEK, 0); }
		public ITerminalNode BINARY() { return GetToken(VBAExpressionParser.BINARY, 0); }
		public ITerminalNode RANDOM() { return GetToken(VBAExpressionParser.RANDOM, 0); }
		public ITerminalNode LOOP() { return GetToken(VBAExpressionParser.LOOP, 0); }
		public ITerminalNode DEFCUR() { return GetToken(VBAExpressionParser.DEFCUR, 0); }
		public ITerminalNode PUBLIC() { return GetToken(VBAExpressionParser.PUBLIC, 0); }
		public ITerminalNode DEFDATE() { return GetToken(VBAExpressionParser.DEFDATE, 0); }
		public ITerminalNode PUT() { return GetToken(VBAExpressionParser.PUT, 0); }
		public ITerminalNode LET() { return GetToken(VBAExpressionParser.LET, 0); }
		public ITerminalNode FRIEND() { return GetToken(VBAExpressionParser.FRIEND, 0); }
		public ITerminalNode TYPE() { return GetToken(VBAExpressionParser.TYPE, 0); }
		public ITerminalNode ERROR() { return GetToken(VBAExpressionParser.ERROR, 0); }
		public ITerminalNode CALL() { return GetToken(VBAExpressionParser.CALL, 0); }
		public ITerminalNode READ() { return GetToken(VBAExpressionParser.READ, 0); }
		public ITerminalNode DEFBOOL() { return GetToken(VBAExpressionParser.DEFBOOL, 0); }
		public ITerminalNode OPEN() { return GetToken(VBAExpressionParser.OPEN, 0); }
		public ITerminalNode STATIC() { return GetToken(VBAExpressionParser.STATIC, 0); }
		public ITerminalNode LOCK_READ() { return GetToken(VBAExpressionParser.LOCK_READ, 0); }
		public ITerminalNode DO() { return GetToken(VBAExpressionParser.DO, 0); }
		public ITerminalNode DIM() { return GetToken(VBAExpressionParser.DIM, 0); }
		public ITerminalNode OPTION() { return GetToken(VBAExpressionParser.OPTION, 0); }
		public ITerminalNode CLOSE() { return GetToken(VBAExpressionParser.CLOSE, 0); }
		public ITerminalNode OUTPUT() { return GetToken(VBAExpressionParser.OUTPUT, 0); }
		public ITerminalNode LINE_INPUT() { return GetToken(VBAExpressionParser.LINE_INPUT, 0); }
		public ITerminalNode DEFLNG() { return GetToken(VBAExpressionParser.DEFLNG, 0); }
		public ITerminalNode IMPLEMENTS() { return GetToken(VBAExpressionParser.IMPLEMENTS, 0); }
		public ITerminalNode ON() { return GetToken(VBAExpressionParser.ON, 0); }
		public ITerminalNode WITH() { return GetToken(VBAExpressionParser.WITH, 0); }
		public ITerminalNode ACCESS() { return GetToken(VBAExpressionParser.ACCESS, 0); }
		public ITerminalNode EXIT_SUB() { return GetToken(VBAExpressionParser.EXIT_SUB, 0); }
		public ITerminalNode DECLARE() { return GetToken(VBAExpressionParser.DECLARE, 0); }
		public ITerminalNode LOCK_READ_WRITE() { return GetToken(VBAExpressionParser.LOCK_READ_WRITE, 0); }
		public ITerminalNode RESUME() { return GetToken(VBAExpressionParser.RESUME, 0); }
		public IReadOnlyList<ITerminalNode> WRITE() { return GetTokens(VBAExpressionParser.WRITE); }
		public ITerminalNode DEFLNGPTR() { return GetToken(VBAExpressionParser.DEFLNGPTR, 0); }
		public ITerminalNode WHILE() { return GetToken(VBAExpressionParser.WHILE, 0); }
		public ITerminalNode EXIT() { return GetToken(VBAExpressionParser.EXIT, 0); }
		public ITerminalNode GET() { return GetToken(VBAExpressionParser.GET, 0); }
		public ITerminalNode EXIT_FOR() { return GetToken(VBAExpressionParser.EXIT_FOR, 0); }
		public ITerminalNode DEFDBL() { return GetToken(VBAExpressionParser.DEFDBL, 0); }
		public ITerminalNode NEXT() { return GetToken(VBAExpressionParser.NEXT, 0); }
		public ITerminalNode FUNCTION() { return GetToken(VBAExpressionParser.FUNCTION, 0); }
		public ITerminalNode END_WITH() { return GetToken(VBAExpressionParser.END_WITH, 0); }
		public ITerminalNode RSET() { return GetToken(VBAExpressionParser.RSET, 0); }
		public ITerminalNode GOTO() { return GetToken(VBAExpressionParser.GOTO, 0); }
		public ITerminalNode REDIM() { return GetToken(VBAExpressionParser.REDIM, 0); }
		public ITerminalNode EXIT_PROPERTY() { return GetToken(VBAExpressionParser.EXIT_PROPERTY, 0); }
		public ITerminalNode END() { return GetToken(VBAExpressionParser.END, 0); }
		public ITerminalNode SELECT() { return GetToken(VBAExpressionParser.SELECT, 0); }
		public ITerminalNode EXIT_FUNCTION() { return GetToken(VBAExpressionParser.EXIT_FUNCTION, 0); }
		public ITerminalNode READ_WRITE() { return GetToken(VBAExpressionParser.READ_WRITE, 0); }
		public ITerminalNode UNLOCK() { return GetToken(VBAExpressionParser.UNLOCK, 0); }
		public ITerminalNode SET() { return GetToken(VBAExpressionParser.SET, 0); }
		public StatementKeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statementKeyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterStatementKeyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitStatementKeyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatementKeyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementKeywordContext statementKeyword() {
		StatementKeywordContext _localctx = new StatementKeywordContext(_ctx, State);
		EnterRule(_localctx, 80, RULE_statementKeyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 553;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << EXIT) | (1L << OPTION) | (1L << ACCESS) | (1L << APPEND) | (1L << BINARY))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CASE - 64)) | (1L << (CLOSE - 64)) | (1L << (CONST - 64)) | (1L << (DECLARE - 64)) | (1L << (DEFBOOL - 64)) | (1L << (DEFBYTE - 64)) | (1L << (DEFDATE - 64)) | (1L << (DEFDBL - 64)) | (1L << (DEFCUR - 64)) | (1L << (DEFINT - 64)) | (1L << (DEFLNG - 64)) | (1L << (DEFLNGLNG - 64)) | (1L << (DEFLNGPTR - 64)) | (1L << (DEFOBJ - 64)) | (1L << (DEFSNG - 64)) | (1L << (DEFSTR - 64)) | (1L << (DEFVAR - 64)) | (1L << (DIM - 64)) | (1L << (DO - 64)) | (1L << (ELSE - 64)) | (1L << (ELSEIF - 64)) | (1L << (END_IF - 64)) | (1L << (END_SELECT - 64)) | (1L << (END_WITH - 64)) | (1L << (END - 64)) | (1L << (ENUM - 64)) | (1L << (ERASE - 64)) | (1L << (ERROR - 64)) | (1L << (EVENT - 64)) | (1L << (EXIT_DO - 64)) | (1L << (EXIT_FOR - 64)) | (1L << (EXIT_FUNCTION - 64)) | (1L << (EXIT_PROPERTY - 64)) | (1L << (EXIT_SUB - 64)) | (1L << (FRIEND - 64)) | (1L << (FOR - 64)) | (1L << (FUNCTION - 64)) | (1L << (GET - 64)) | (1L << (GLOBAL - 64)) | (1L << (GOSUB - 64)) | (1L << (GOTO - 64)) | (1L << (IF - 64)) | (1L << (IMPLEMENTS - 64)) | (1L << (INPUT - 64)))) != 0) || ((((_la - 132)) & ~0x3f) == 0 && ((1L << (_la - 132)) & ((1L << (LOCK - 132)) | (1L << (LOOP - 132)) | (1L << (LET - 132)) | (1L << (LINE_INPUT - 132)) | (1L << (LOCK_READ - 132)) | (1L << (LOCK_WRITE - 132)) | (1L << (LOCK_READ_WRITE - 132)) | (1L << (LSET - 132)) | (1L << (NEXT - 132)) | (1L << (ON - 132)) | (1L << (ON_ERROR - 132)) | (1L << (OPEN - 132)) | (1L << (OUTPUT - 132)) | (1L << (PRINT - 132)) | (1L << (PRIVATE - 132)) | (1L << (PUBLIC - 132)) | (1L << (PUT - 132)) | (1L << (RANDOM - 132)) | (1L << (RAISEEVENT - 132)) | (1L << (READ - 132)) | (1L << (READ_WRITE - 132)) | (1L << (REDIM - 132)) | (1L << (RESET - 132)) | (1L << (RESUME - 132)) | (1L << (RETURN - 132)) | (1L << (RSET - 132)) | (1L << (SEEK - 132)) | (1L << (SELECT - 132)) | (1L << (SET - 132)) | (1L << (SHARED - 132)))) != 0) || ((((_la - 196)) & ~0x3f) == 0 && ((1L << (_la - 196)) & ((1L << (STATIC - 196)) | (1L << (STEP - 196)) | (1L << (STOP - 196)) | (1L << (SUB - 196)) | (1L << (TYPE - 196)) | (1L << (UNLOCK - 196)) | (1L << (WEND - 196)) | (1L << (WHILE - 196)) | (1L << (WIDTH - 196)) | (1L << (WITH - 196)) | (1L << (WRITE - 196)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RemKeywordContext : ParserRuleContext {
		public ITerminalNode REM() { return GetToken(VBAExpressionParser.REM, 0); }
		public RemKeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_remKeyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterRemKeyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitRemKeyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRemKeyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RemKeywordContext remKeyword() {
		RemKeywordContext _localctx = new RemKeywordContext(_ctx, State);
		EnterRule(_localctx, 82, RULE_remKeyword);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 555; Match(REM);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MarkerKeywordContext : ParserRuleContext {
		public ITerminalNode CASE() { return GetToken(VBAExpressionParser.CASE, 0); }
		public ITerminalNode ELSE() { return GetToken(VBAExpressionParser.ELSE, 0); }
		public ITerminalNode THEN() { return GetToken(VBAExpressionParser.THEN, 0); }
		public ITerminalNode WRITE() { return GetToken(VBAExpressionParser.WRITE, 0); }
		public ITerminalNode PRESERVE() { return GetToken(VBAExpressionParser.PRESERVE, 0); }
		public ITerminalNode SPC() { return GetToken(VBAExpressionParser.SPC, 0); }
		public ITerminalNode TO() { return GetToken(VBAExpressionParser.TO, 0); }
		public ITerminalNode EACH() { return GetToken(VBAExpressionParser.EACH, 0); }
		public ITerminalNode SHARED() { return GetToken(VBAExpressionParser.SHARED, 0); }
		public ITerminalNode ANY() { return GetToken(VBAExpressionParser.ANY, 0); }
		public ITerminalNode NEW() { return GetToken(VBAExpressionParser.NEW, 0); }
		public ITerminalNode AS() { return GetToken(VBAExpressionParser.AS, 0); }
		public ITerminalNode BYVAL() { return GetToken(VBAExpressionParser.BYVAL, 0); }
		public ITerminalNode IN() { return GetToken(VBAExpressionParser.IN, 0); }
		public ITerminalNode TAB() { return GetToken(VBAExpressionParser.TAB, 0); }
		public ITerminalNode BYREF() { return GetToken(VBAExpressionParser.BYREF, 0); }
		public ITerminalNode OPTIONAL() { return GetToken(VBAExpressionParser.OPTIONAL, 0); }
		public ITerminalNode UNTIL() { return GetToken(VBAExpressionParser.UNTIL, 0); }
		public ITerminalNode PARAMARRAY() { return GetToken(VBAExpressionParser.PARAMARRAY, 0); }
		public ITerminalNode WITHEVENTS() { return GetToken(VBAExpressionParser.WITHEVENTS, 0); }
		public MarkerKeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_markerKeyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterMarkerKeyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitMarkerKeyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMarkerKeyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MarkerKeywordContext markerKeyword() {
		MarkerKeywordContext _localctx = new MarkerKeywordContext(_ctx, State);
		EnterRule(_localctx, 84, RULE_markerKeyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 557;
			_la = _input.La(1);
			if ( !(((((_la - 2)) & ~0x3f) == 0 && ((1L << (_la - 2)) & ((1L << (ANY - 2)) | (1L << (AS - 2)) | (1L << (BYVAL - 2)) | (1L << (BYREF - 2)) | (1L << (CASE - 2)))) != 0) || ((((_la - 91)) & ~0x3f) == 0 && ((1L << (_la - 91)) & ((1L << (EACH - 91)) | (1L << (ELSE - 91)) | (1L << (IN - 91)) | (1L << (NEW - 91)))) != 0) || ((((_la - 157)) & ~0x3f) == 0 && ((1L << (_la - 157)) & ((1L << (OPTIONAL - 157)) | (1L << (PARAMARRAY - 157)) | (1L << (PRESERVE - 157)) | (1L << (SHARED - 157)) | (1L << (SPC - 157)) | (1L << (TAB - 157)) | (1L << (THEN - 157)) | (1L << (TO - 157)) | (1L << (UNTIL - 157)) | (1L << (WITHEVENTS - 157)) | (1L << (WRITE - 157)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OperatorIdentifierContext : ParserRuleContext {
		public ITerminalNode NOT() { return GetToken(VBAExpressionParser.NOT, 0); }
		public ITerminalNode IS() { return GetToken(VBAExpressionParser.IS, 0); }
		public ITerminalNode XOR() { return GetToken(VBAExpressionParser.XOR, 0); }
		public ITerminalNode EQV() { return GetToken(VBAExpressionParser.EQV, 0); }
		public ITerminalNode ADDRESSOF() { return GetToken(VBAExpressionParser.ADDRESSOF, 0); }
		public ITerminalNode AND() { return GetToken(VBAExpressionParser.AND, 0); }
		public ITerminalNode TYPEOF() { return GetToken(VBAExpressionParser.TYPEOF, 0); }
		public ITerminalNode LIKE() { return GetToken(VBAExpressionParser.LIKE, 0); }
		public ITerminalNode MOD() { return GetToken(VBAExpressionParser.MOD, 0); }
		public ITerminalNode OR() { return GetToken(VBAExpressionParser.OR, 0); }
		public ITerminalNode IMP() { return GetToken(VBAExpressionParser.IMP, 0); }
		public ITerminalNode NEW() { return GetToken(VBAExpressionParser.NEW, 0); }
		public OperatorIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_operatorIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterOperatorIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitOperatorIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOperatorIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OperatorIdentifierContext operatorIdentifier() {
		OperatorIdentifierContext _localctx = new OperatorIdentifierContext(_ctx, State);
		EnterRule(_localctx, 86, RULE_operatorIdentifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 559;
			_la = _input.La(1);
			if ( !(_la==ADDRESSOF || _la==AND || ((((_la - 105)) & ~0x3f) == 0 && ((1L << (_la - 105)) & ((1L << (EQV - 105)) | (1L << (IMP - 105)) | (1L << (IS - 105)) | (1L << (LIKE - 105)) | (1L << (MOD - 105)) | (1L << (NEW - 105)) | (1L << (NOT - 105)) | (1L << (OR - 105)))) != 0) || _la==TYPEOF || _la==XOR) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedNameContext : ParserRuleContext {
		public ITerminalNode ME() { return GetToken(VBAExpressionParser.ME, 0); }
		public ReservedProcedureNameContext reservedProcedureName() {
			return GetRuleContext<ReservedProcedureNameContext>(0);
		}
		public ReservedNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedNameContext reservedName() {
		ReservedNameContext _localctx = new ReservedNameContext(_ctx, State);
		EnterRule(_localctx, 88, RULE_reservedName);
		try {
			State = 563;
			switch (_input.La(1)) {
			case ME:
				EnterOuterAlt(_localctx, 1);
				{
				State = 561; Match(ME);
				}
				break;
			case ABS:
			case CBOOL:
			case CBYTE:
			case CCUR:
			case CDATE:
			case CDBL:
			case CDEC:
			case CINT:
			case CLNG:
			case CLNGLNG:
			case CLNGPTR:
			case CSNG:
			case CSTR:
			case CVAR:
			case CVERR:
			case DEBUG:
			case DOEVENTS:
			case FIX:
			case INT:
			case LEN:
			case LENB:
			case MIDB:
			case MIDBTYPESUFFIX:
			case MIDTYPESUFFIX:
			case PSET:
			case SCALE:
			case SGN:
			case MID:
				EnterOuterAlt(_localctx, 2);
				{
				State = 562; reservedProcedureName();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedProcedureNameContext : ParserRuleContext {
		public ITerminalNode CSTR() { return GetToken(VBAExpressionParser.CSTR, 0); }
		public ITerminalNode CLNGLNG() { return GetToken(VBAExpressionParser.CLNGLNG, 0); }
		public ITerminalNode CDATE() { return GetToken(VBAExpressionParser.CDATE, 0); }
		public ITerminalNode CINT() { return GetToken(VBAExpressionParser.CINT, 0); }
		public ITerminalNode ABS() { return GetToken(VBAExpressionParser.ABS, 0); }
		public ITerminalNode INT() { return GetToken(VBAExpressionParser.INT, 0); }
		public ITerminalNode LENB() { return GetToken(VBAExpressionParser.LENB, 0); }
		public ITerminalNode SCALE() { return GetToken(VBAExpressionParser.SCALE, 0); }
		public ITerminalNode MIDTYPESUFFIX() { return GetToken(VBAExpressionParser.MIDTYPESUFFIX, 0); }
		public ITerminalNode DEBUG() { return GetToken(VBAExpressionParser.DEBUG, 0); }
		public ITerminalNode CLNGPTR() { return GetToken(VBAExpressionParser.CLNGPTR, 0); }
		public ITerminalNode DOEVENTS() { return GetToken(VBAExpressionParser.DOEVENTS, 0); }
		public ITerminalNode MID() { return GetToken(VBAExpressionParser.MID, 0); }
		public ITerminalNode CDEC() { return GetToken(VBAExpressionParser.CDEC, 0); }
		public ITerminalNode MIDB() { return GetToken(VBAExpressionParser.MIDB, 0); }
		public ITerminalNode CSNG() { return GetToken(VBAExpressionParser.CSNG, 0); }
		public ITerminalNode LEN() { return GetToken(VBAExpressionParser.LEN, 0); }
		public ITerminalNode CCUR() { return GetToken(VBAExpressionParser.CCUR, 0); }
		public ITerminalNode CBOOL() { return GetToken(VBAExpressionParser.CBOOL, 0); }
		public ITerminalNode MIDBTYPESUFFIX() { return GetToken(VBAExpressionParser.MIDBTYPESUFFIX, 0); }
		public ITerminalNode SGN() { return GetToken(VBAExpressionParser.SGN, 0); }
		public ITerminalNode CBYTE() { return GetToken(VBAExpressionParser.CBYTE, 0); }
		public ITerminalNode PSET() { return GetToken(VBAExpressionParser.PSET, 0); }
		public ITerminalNode CVERR() { return GetToken(VBAExpressionParser.CVERR, 0); }
		public ITerminalNode FIX() { return GetToken(VBAExpressionParser.FIX, 0); }
		public ITerminalNode CDBL() { return GetToken(VBAExpressionParser.CDBL, 0); }
		public ITerminalNode CVAR() { return GetToken(VBAExpressionParser.CVAR, 0); }
		public ITerminalNode CLNG() { return GetToken(VBAExpressionParser.CLNG, 0); }
		public ReservedProcedureNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedProcedureName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedProcedureName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedProcedureName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedProcedureName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedProcedureNameContext reservedProcedureName() {
		ReservedProcedureNameContext _localctx = new ReservedProcedureNameContext(_ctx, State);
		EnterRule(_localctx, 90, RULE_reservedProcedureName);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 565;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ABS) | (1L << CBOOL) | (1L << CBYTE) | (1L << CCUR) | (1L << CDATE) | (1L << CDBL) | (1L << CDEC) | (1L << CINT) | (1L << CLNG) | (1L << CLNGLNG) | (1L << CLNGPTR) | (1L << CSNG) | (1L << CSTR) | (1L << CVAR) | (1L << CVERR) | (1L << DEBUG) | (1L << DOEVENTS) | (1L << FIX) | (1L << INT) | (1L << LEN) | (1L << LENB) | (1L << MIDB) | (1L << MIDBTYPESUFFIX) | (1L << MIDTYPESUFFIX) | (1L << PSET) | (1L << SCALE) | (1L << SGN))) != 0) || _la==MID) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SpecialFormContext : ParserRuleContext {
		public ITerminalNode INPUTB() { return GetToken(VBAExpressionParser.INPUTB, 0); }
		public ITerminalNode SCALE() { return GetToken(VBAExpressionParser.SCALE, 0); }
		public ITerminalNode ARRAY() { return GetToken(VBAExpressionParser.ARRAY, 0); }
		public ITerminalNode LBOUND() { return GetToken(VBAExpressionParser.LBOUND, 0); }
		public ITerminalNode UBOUND() { return GetToken(VBAExpressionParser.UBOUND, 0); }
		public ITerminalNode INPUT() { return GetToken(VBAExpressionParser.INPUT, 0); }
		public ITerminalNode CIRCLE() { return GetToken(VBAExpressionParser.CIRCLE, 0); }
		public SpecialFormContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_specialForm; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterSpecialForm(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitSpecialForm(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSpecialForm(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SpecialFormContext specialForm() {
		SpecialFormContext _localctx = new SpecialFormContext(_ctx, State);
		EnterRule(_localctx, 92, RULE_specialForm);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 567;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ARRAY) | (1L << CIRCLE) | (1L << INPUTB) | (1L << LBOUND) | (1L << SCALE) | (1L << UBOUND))) != 0) || _la==INPUT) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedTypeIdentifierContext : ParserRuleContext {
		public ITerminalNode INTEGER() { return GetToken(VBAExpressionParser.INTEGER, 0); }
		public ITerminalNode LONGLONG() { return GetToken(VBAExpressionParser.LONGLONG, 0); }
		public ITerminalNode LONG() { return GetToken(VBAExpressionParser.LONG, 0); }
		public ITerminalNode VARIANT() { return GetToken(VBAExpressionParser.VARIANT, 0); }
		public ITerminalNode LONGPTR() { return GetToken(VBAExpressionParser.LONGPTR, 0); }
		public ITerminalNode BYTE() { return GetToken(VBAExpressionParser.BYTE, 0); }
		public ITerminalNode STRING() { return GetToken(VBAExpressionParser.STRING, 0); }
		public ITerminalNode BOOLEAN() { return GetToken(VBAExpressionParser.BOOLEAN, 0); }
		public ITerminalNode DATE() { return GetToken(VBAExpressionParser.DATE, 0); }
		public ITerminalNode CURRENCY() { return GetToken(VBAExpressionParser.CURRENCY, 0); }
		public ITerminalNode DOUBLE() { return GetToken(VBAExpressionParser.DOUBLE, 0); }
		public ITerminalNode SINGLE() { return GetToken(VBAExpressionParser.SINGLE, 0); }
		public ReservedTypeIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedTypeIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedTypeIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedTypeIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedTypeIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedTypeIdentifierContext reservedTypeIdentifier() {
		ReservedTypeIdentifierContext _localctx = new ReservedTypeIdentifierContext(_ctx, State);
		EnterRule(_localctx, 94, RULE_reservedTypeIdentifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 569;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << CURRENCY) | (1L << LONGLONG) | (1L << LONGPTR) | (1L << BOOLEAN) | (1L << BYTE))) != 0) || ((((_la - 72)) & ~0x3f) == 0 && ((1L << (_la - 72)) & ((1L << (DATE - 72)) | (1L << (DOUBLE - 72)) | (1L << (INTEGER - 72)) | (1L << (LONG - 72)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (SINGLE - 194)) | (1L << (STRING - 194)) | (1L << (VARIANT - 194)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralIdentifierContext : ParserRuleContext {
		public ObjectLiteralIdentifierContext objectLiteralIdentifier() {
			return GetRuleContext<ObjectLiteralIdentifierContext>(0);
		}
		public BooleanLiteralIdentifierContext booleanLiteralIdentifier() {
			return GetRuleContext<BooleanLiteralIdentifierContext>(0);
		}
		public VariantLiteralIdentifierContext variantLiteralIdentifier() {
			return GetRuleContext<VariantLiteralIdentifierContext>(0);
		}
		public LiteralIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literalIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLiteralIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLiteralIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteralIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralIdentifierContext literalIdentifier() {
		LiteralIdentifierContext _localctx = new LiteralIdentifierContext(_ctx, State);
		EnterRule(_localctx, 96, RULE_literalIdentifier);
		try {
			State = 574;
			switch (_input.La(1)) {
			case FALSE:
			case TRUE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 571; booleanLiteralIdentifier();
				}
				break;
			case NOTHING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 572; objectLiteralIdentifier();
				}
				break;
			case EMPTY:
			case NULL:
				EnterOuterAlt(_localctx, 3);
				{
				State = 573; variantLiteralIdentifier();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BooleanLiteralIdentifierContext : ParserRuleContext {
		public ITerminalNode FALSE() { return GetToken(VBAExpressionParser.FALSE, 0); }
		public ITerminalNode TRUE() { return GetToken(VBAExpressionParser.TRUE, 0); }
		public BooleanLiteralIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_booleanLiteralIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterBooleanLiteralIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitBooleanLiteralIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBooleanLiteralIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BooleanLiteralIdentifierContext booleanLiteralIdentifier() {
		BooleanLiteralIdentifierContext _localctx = new BooleanLiteralIdentifierContext(_ctx, State);
		EnterRule(_localctx, 98, RULE_booleanLiteralIdentifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 576;
			_la = _input.La(1);
			if ( !(_la==FALSE || _la==TRUE) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectLiteralIdentifierContext : ParserRuleContext {
		public ITerminalNode NOTHING() { return GetToken(VBAExpressionParser.NOTHING, 0); }
		public ObjectLiteralIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectLiteralIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterObjectLiteralIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitObjectLiteralIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObjectLiteralIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ObjectLiteralIdentifierContext objectLiteralIdentifier() {
		ObjectLiteralIdentifierContext _localctx = new ObjectLiteralIdentifierContext(_ctx, State);
		EnterRule(_localctx, 100, RULE_objectLiteralIdentifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 578; Match(NOTHING);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariantLiteralIdentifierContext : ParserRuleContext {
		public ITerminalNode NULL() { return GetToken(VBAExpressionParser.NULL, 0); }
		public ITerminalNode EMPTY() { return GetToken(VBAExpressionParser.EMPTY, 0); }
		public VariantLiteralIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variantLiteralIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterVariantLiteralIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitVariantLiteralIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariantLiteralIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VariantLiteralIdentifierContext variantLiteralIdentifier() {
		VariantLiteralIdentifierContext _localctx = new VariantLiteralIdentifierContext(_ctx, State);
		EnterRule(_localctx, 102, RULE_variantLiteralIdentifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 580;
			_la = _input.La(1);
			if ( !(_la==EMPTY || _la==NULL) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhiteSpaceContext : ParserRuleContext {
		public ITerminalNode WS(int i) {
			return GetToken(VBAExpressionParser.WS, i);
		}
		public IReadOnlyList<ITerminalNode> WS() { return GetTokens(VBAExpressionParser.WS); }
		public IReadOnlyList<ITerminalNode> LINE_CONTINUATION() { return GetTokens(VBAExpressionParser.LINE_CONTINUATION); }
		public ITerminalNode LINE_CONTINUATION(int i) {
			return GetToken(VBAExpressionParser.LINE_CONTINUATION, i);
		}
		public WhiteSpaceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whiteSpace; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterWhiteSpace(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitWhiteSpace(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhiteSpace(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WhiteSpaceContext whiteSpace() {
		WhiteSpaceContext _localctx = new WhiteSpaceContext(_ctx, State);
		EnterRule(_localctx, 104, RULE_whiteSpace);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 583;
			_errHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 582;
					_la = _input.La(1);
					if ( !(_la==WS || _la==LINE_CONTINUATION) ) {
					_errHandler.RecoverInline(this);
					}
					Consume();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 585;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,83,_ctx);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 12: return expression_sempred((ExpressionContext)_localctx, predIndex);

		case 18: return lExpression_sempred((LExpressionContext)_localctx, predIndex);
		}
		return true;
	}
	private bool expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(_ctx, 15);

		case 1: return Precpred(_ctx, 13);

		case 2: return Precpred(_ctx, 12);

		case 3: return Precpred(_ctx, 11);

		case 4: return Precpred(_ctx, 10);

		case 5: return Precpred(_ctx, 9);

		case 6: return Precpred(_ctx, 8);

		case 7: return Precpred(_ctx, 6);

		case 8: return Precpred(_ctx, 5);

		case 9: return Precpred(_ctx, 4);

		case 10: return Precpred(_ctx, 3);

		case 11: return Precpred(_ctx, 2);
		}
		return true;
	}
	private bool lExpression_sempred(LExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 16: return Precpred(_ctx, 5);

		case 17: return Precpred(_ctx, 4);

		case 12: return Precpred(_ctx, 9);

		case 13: return Precpred(_ctx, 8);

		case 14: return Precpred(_ctx, 7);

		case 15: return Precpred(_ctx, 6);
		}
		return true;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3\x106\x24E\x4\x2"+
		"\t\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4"+
		"\t\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10"+
		"\t\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15"+
		"\x4\x16\t\x16\x4\x17\t\x17\x4\x18\t\x18\x4\x19\t\x19\x4\x1A\t\x1A\x4\x1B"+
		"\t\x1B\x4\x1C\t\x1C\x4\x1D\t\x1D\x4\x1E\t\x1E\x4\x1F\t\x1F\x4 \t \x4!"+
		"\t!\x4\"\t\"\x4#\t#\x4$\t$\x4%\t%\x4&\t&\x4\'\t\'\x4(\t(\x4)\t)\x4*\t"+
		"*\x4+\t+\x4,\t,\x4-\t-\x4.\t.\x4/\t/\x4\x30\t\x30\x4\x31\t\x31\x4\x32"+
		"\t\x32\x4\x33\t\x33\x4\x34\t\x34\x4\x35\t\x35\x4\x36\t\x36\x3\x2\x3\x2"+
		"\x3\x2\x3\x3\x3\x3\x5\x3r\n\x3\x3\x4\x3\x4\x5\x4v\n\x4\x3\x5\x3\x5\x5"+
		"\x5z\n\x5\x3\x6\x3\x6\x3\a\x3\a\x3\a\x3\b\x3\b\x3\b\x3\b\x3\b\x3\b\x5"+
		"\b\x87\n\b\x3\t\x3\t\x3\t\x3\n\x3\n\x3\n\x3\n\x3\n\x5\n\x91\n\n\x3\v\x3"+
		"\v\x3\f\x3\f\x3\r\x3\r\x3\r\x5\r\x9A\n\r\x3\r\x3\r\x5\r\x9E\n\r\x3\r\x3"+
		"\r\x3\r\x3\r\x3\r\x5\r\xA5\n\r\x3\r\x3\r\x5\r\xA9\n\r\x3\r\x5\r\xAC\n"+
		"\r\x3\xE\x3\xE\x3\xE\x5\xE\xB1\n\xE\x3\xE\x3\xE\x3\xE\x5\xE\xB6\n\xE\x3"+
		"\xE\x3\xE\x3\xE\x3\xE\x5\xE\xBC\n\xE\x3\xE\x3\xE\x5\xE\xC0\n\xE\x3\xE"+
		"\x3\xE\x3\xE\x3\xE\x3\xE\x5\xE\xC7\n\xE\x3\xE\x3\xE\x5\xE\xCB\n\xE\x3"+
		"\xE\x3\xE\x5\xE\xCF\n\xE\x3\xE\x3\xE\x3\xE\x5\xE\xD4\n\xE\x3\xE\x3\xE"+
		"\x5\xE\xD8\n\xE\x3\xE\x3\xE\x3\xE\x5\xE\xDD\n\xE\x3\xE\x3\xE\x5\xE\xE1"+
		"\n\xE\x3\xE\x3\xE\x3\xE\x5\xE\xE6\n\xE\x3\xE\x3\xE\x5\xE\xEA\n\xE\x3\xE"+
		"\x3\xE\x3\xE\x5\xE\xEF\n\xE\x3\xE\x3\xE\x5\xE\xF3\n\xE\x3\xE\x3\xE\x3"+
		"\xE\x5\xE\xF8\n\xE\x3\xE\x3\xE\x5\xE\xFC\n\xE\x3\xE\x3\xE\x3\xE\x5\xE"+
		"\x101\n\xE\x3\xE\x3\xE\x5\xE\x105\n\xE\x3\xE\x3\xE\x3\xE\x5\xE\x10A\n"+
		"\xE\x3\xE\x3\xE\x5\xE\x10E\n\xE\x3\xE\x3\xE\x3\xE\x5\xE\x113\n\xE\x3\xE"+
		"\x3\xE\x5\xE\x117\n\xE\x3\xE\x3\xE\x3\xE\x5\xE\x11C\n\xE\x3\xE\x3\xE\x5"+
		"\xE\x120\n\xE\x3\xE\x3\xE\x3\xE\x5\xE\x125\n\xE\x3\xE\x3\xE\x5\xE\x129"+
		"\n\xE\x3\xE\x3\xE\x3\xE\x5\xE\x12E\n\xE\x3\xE\x3\xE\x5\xE\x132\n\xE\x3"+
		"\xE\a\xE\x135\n\xE\f\xE\xE\xE\x138\v\xE\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF"+
		"\x5\xF\x13F\n\xF\x5\xF\x141\n\xF\x3\x10\x3\x10\x3\x11\x3\x11\x5\x11\x147"+
		"\n\x11\x3\x11\x3\x11\x5\x11\x14B\n\x11\x3\x11\x3\x11\x3\x12\x3\x12\x3"+
		"\x12\x3\x12\x3\x12\x3\x12\x3\x12\x3\x12\x3\x13\x3\x13\x3\x13\x3\x13\x3"+
		"\x14\x3\x14\x3\x14\x3\x14\x5\x14\x15F\n\x14\x3\x14\x3\x14\x5\x14\x163"+
		"\n\x14\x3\x14\x3\x14\x5\x14\x167\n\x14\x3\x14\x5\x14\x16A\n\x14\x3\x14"+
		"\x5\x14\x16D\n\x14\x3\x14\x3\x14\x3\x14\x3\x14\x3\x14\x3\x14\x3\x14\x5"+
		"\x14\x176\n\x14\x3\x14\x3\x14\x3\x14\x3\x14\x3\x14\x3\x14\x3\x14\x3\x14"+
		"\x3\x14\x3\x14\x3\x14\x3\x14\x3\x14\x3\x14\a\x14\x186\n\x14\f\x14\xE\x14"+
		"\x189\v\x14\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x5\x15\x192"+
		"\n\x15\x3\x15\x3\x15\x3\x15\x5\x15\x197\n\x15\x3\x16\x3\x16\x5\x16\x19B"+
		"\n\x16\x3\x16\x3\x16\x5\x16\x19F\n\x16\x3\x16\x5\x16\x1A2\n\x16\x3\x16"+
		"\x5\x16\x1A5\n\x16\x3\x16\x3\x16\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3"+
		"\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x5"+
		"\x17\x1B8\n\x17\x3\x18\x3\x18\x3\x19\x5\x19\x1BD\n\x19\x3\x19\x5\x19\x1C0"+
		"\n\x19\x3\x19\x3\x19\x5\x19\x1C4\n\x19\a\x19\x1C6\n\x19\f\x19\xE\x19\x1C9"+
		"\v\x19\x3\x19\x3\x19\x5\x19\x1CD\n\x19\x3\x19\x5\x19\x1D0\n\x19\x3\x19"+
		"\x3\x19\x5\x19\x1D4\n\x19\a\x19\x1D6\n\x19\f\x19\xE\x19\x1D9\v\x19\x3"+
		"\x19\x5\x19\x1DC\n\x19\x3\x1A\x3\x1A\x3\x1B\x3\x1B\x3\x1C\x3\x1C\x5\x1C"+
		"\x1E4\n\x1C\x3\x1C\x3\x1C\x5\x1C\x1E8\n\x1C\x3\x1C\a\x1C\x1EB\n\x1C\f"+
		"\x1C\xE\x1C\x1EE\v\x1C\x3\x1D\x3\x1D\x5\x1D\x1F2\n\x1D\x3\x1D\x3\x1D\x5"+
		"\x1D\x1F6\n\x1D\x3\x1D\x3\x1D\x3\x1E\x3\x1E\x5\x1E\x1FC\n\x1E\x3\x1E\x3"+
		"\x1E\x5\x1E\x200\n\x1E\x3\x1F\x3\x1F\x3 \x3 \x3!\x3!\x5!\x208\n!\x3\""+
		"\x3\"\x3\"\x3#\x3#\x3#\x3$\x3$\x3%\x3%\x5%\x214\n%\x3&\x3&\x5&\x218\n"+
		"&\x3\'\x3\'\x3\'\x3\'\x3(\x3(\x5(\x220\n(\x3)\x3)\x3)\x3)\x3)\x3)\x3)"+
		"\x3)\x5)\x22A\n)\x3*\x3*\x3+\x3+\x3,\x3,\x3-\x3-\x3.\x3.\x5.\x236\n.\x3"+
		"/\x3/\x3\x30\x3\x30\x3\x31\x3\x31\x3\x32\x3\x32\x3\x32\x5\x32\x241\n\x32"+
		"\x3\x33\x3\x33\x3\x34\x3\x34\x3\x35\x3\x35\x3\x36\x6\x36\x24A\n\x36\r"+
		"\x36\xE\x36\x24B\x3\x36\x2\x2\x4\x1A&\x37\x2\x2\x4\x2\x6\x2\b\x2\n\x2"+
		"\f\x2\xE\x2\x10\x2\x12\x2\x14\x2\x16\x2\x18\x2\x1A\x2\x1C\x2\x1E\x2 \x2"+
		"\"\x2$\x2&\x2(\x2*\x2,\x2.\x2\x30\x2\x32\x2\x34\x2\x36\x2\x38\x2:\x2<"+
		"\x2>\x2@\x2\x42\x2\x44\x2\x46\x2H\x2J\x2L\x2N\x2P\x2R\x2T\x2V\x2X\x2Z"+
		"\x2\\\x2^\x2`\x2\x62\x2\x64\x2\x66\x2h\x2j\x2\x2\x11\x5\x2,,.\x32\xEC"+
		"\xEC\x5\x2==II\xCC\xCC\x4\x2\xE0\xE0\xE9\xE9\x4\x2\xE8\xE8\xEB\xEB\a\x2"+
		"\x82\x82\x8B\x8B\xE2\xE5\xE7\xE7\xEA\xEA\x3\x2\xF6\xF9(\x2\x18\x18$$\x33"+
		"\x33\x39\x39==\x42\x43GHKXZ[^_\x63\x63\x65\x65hjlsv}\x7F\x7F\x81\x81\x86"+
		"\x86\x88\x89\x8C\x90\x96\x96\x9B\x9C\x9E\x9E\xA5\xA5\xA8\xA9\xAE\xB0\xB2"+
		"\xB5\xB7\xB9\xBB\xBB\xBE\xBF\xC1\xC1\xC3\xC3\xC6\xC8\xCA\xCA\xD1\xD1\xD4"+
		"\xD4\xD8\xDB\xDD\xDD\x12\x2\x4\x4::?@\x43\x43]^\x80\x80\x97\x97\x9F\x9F"+
		"\xA6\xA7\xC3\xC3\xC5\xC5\xCB\xCB\xCD\xCD\xCF\xCF\xD5\xD5\xDC\xDD\r\x2"+
		"\x34\x34\x36\x36kk~~\x82\x82\x8B\x8B\x94\x94\x97\x98\xA4\xA4\xD2\xD2\xDE"+
		"\xDE\f\x2\x3\x3\x6\f\xE\x12\x14\x17\x19\x19\x1B\x1B\x1D\x1E!#%\'\x92\x92"+
		"\t\x2\x5\x5\r\r\x1A\x1A\x1C\x1C&&((\x81\x81\r\x2\x13\x13\x1F >>\x41\x41"+
		"JJ\\\\\x83\x83\x87\x87\xC4\xC4\xC9\xC9\xD6\xD6\x4\x2tt\xD0\xD0\x4\x2`"+
		"`\x9A\x9A\x4\x2\x100\x100\x102\x102\x293\x2l\x3\x2\x2\x2\x4q\x3\x2\x2"+
		"\x2\x6u\x3\x2\x2\x2\by\x3\x2\x2\x2\n{\x3\x2\x2\x2\f}\x3\x2\x2\x2\xE\x86"+
		"\x3\x2\x2\x2\x10\x88\x3\x2\x2\x2\x12\x90\x3\x2\x2\x2\x14\x92\x3\x2\x2"+
		"\x2\x16\x94\x3\x2\x2\x2\x18\xAB\x3\x2\x2\x2\x1A\xC6\x3\x2\x2\x2\x1C\x140"+
		"\x3\x2\x2\x2\x1E\x142\x3\x2\x2\x2 \x144\x3\x2\x2\x2\"\x14E\x3\x2\x2\x2"+
		"$\x156\x3\x2\x2\x2&\x15E\x3\x2\x2\x2(\x196\x3\x2\x2\x2*\x198\x3\x2\x2"+
		"\x2,\x1B7\x3\x2\x2\x2.\x1B9\x3\x2\x2\x2\x30\x1DB\x3\x2\x2\x2\x32\x1DD"+
		"\x3\x2\x2\x2\x34\x1DF\x3\x2\x2\x2\x36\x1E1\x3\x2\x2\x2\x38\x1EF\x3\x2"+
		"\x2\x2:\x1FF\x3\x2\x2\x2<\x201\x3\x2\x2\x2>\x203\x3\x2\x2\x2@\x207\x3"+
		"\x2\x2\x2\x42\x209\x3\x2\x2\x2\x44\x20C\x3\x2\x2\x2\x46\x20F\x3\x2\x2"+
		"\x2H\x213\x3\x2\x2\x2J\x217\x3\x2\x2\x2L\x219\x3\x2\x2\x2N\x21F\x3\x2"+
		"\x2\x2P\x229\x3\x2\x2\x2R\x22B\x3\x2\x2\x2T\x22D\x3\x2\x2\x2V\x22F\x3"+
		"\x2\x2\x2X\x231\x3\x2\x2\x2Z\x235\x3\x2\x2\x2\\\x237\x3\x2\x2\x2^\x239"+
		"\x3\x2\x2\x2`\x23B\x3\x2\x2\x2\x62\x240\x3\x2\x2\x2\x64\x242\x3\x2\x2"+
		"\x2\x66\x244\x3\x2\x2\x2h\x246\x3\x2\x2\x2j\x249\x3\x2\x2\x2lm\x5\x1A"+
		"\xE\x2mn\a\x2\x2\x3n\x3\x3\x2\x2\x2or\x5\x6\x4\x2pr\x5\b\x5\x2qo\x3\x2"+
		"\x2\x2qp\x3\x2\x2\x2r\x5\x3\x2\x2\x2sv\x5\xE\b\x2tv\x5\x10\t\x2us\x3\x2"+
		"\x2\x2ut\x3\x2\x2\x2v\a\x3\x2\x2\x2wz\x5\n\x6\x2xz\x5\f\a\x2yw\x3\x2\x2"+
		"\x2yx\x3\x2\x2\x2z\t\x3\x2\x2\x2{|\x5P)\x2|\v\x3\x2\x2\x2}~\x5P)\x2~\x7F"+
		"\x5\x14\v\x2\x7F\r\x3\x2\x2\x2\x80\x87\a\x101\x2\x2\x81\x87\a\x105\x2"+
		"\x2\x82\x87\x5\\/\x2\x83\x87\x5^\x30\x2\x84\x87\x5\x16\f\x2\x85\x87\a"+
		"\x106\x2\x2\x86\x80\x3\x2\x2\x2\x86\x81\x3\x2\x2\x2\x86\x82\x3\x2\x2\x2"+
		"\x86\x83\x3\x2\x2\x2\x86\x84\x3\x2\x2\x2\x86\x85\x3\x2\x2\x2\x87\xF\x3"+
		"\x2\x2\x2\x88\x89\x5\x12\n\x2\x89\x8A\x5\x14\v\x2\x8A\x11\x3\x2\x2\x2"+
		"\x8B\x91\a\x101\x2\x2\x8C\x91\x5\\/\x2\x8D\x91\x5^\x30\x2\x8E\x91\x5\x16"+
		"\f\x2\x8F\x91\a\x106\x2\x2\x90\x8B\x3\x2\x2\x2\x90\x8C\x3\x2\x2\x2\x90"+
		"\x8D\x3\x2\x2\x2\x90\x8E\x3\x2\x2\x2\x90\x8F\x3\x2\x2\x2\x91\x13\x3\x2"+
		"\x2\x2\x92\x93\t\x2\x2\x2\x93\x15\x3\x2\x2\x2\x94\x95\t\x3\x2\x2\x95\x17"+
		"\x3\x2\x2\x2\x96\xAC\x5`\x31\x2\x97\x99\a\xF3\x2\x2\x98\x9A\x5j\x36\x2"+
		"\x99\x98\x3\x2\x2\x2\x99\x9A\x3\x2\x2\x2\x9A\x9B\x3\x2\x2\x2\x9B\x9D\x5"+
		"`\x31\x2\x9C\x9E\x5j\x36\x2\x9D\x9C\x3\x2\x2\x2\x9D\x9E\x3\x2\x2\x2\x9E"+
		"\x9F\x3\x2\x2\x2\x9F\xA0\a\xF4\x2\x2\xA0\xAC\x3\x2\x2\x2\xA1\xAC\a\x106"+
		"\x2\x2\xA2\xA4\a\xF3\x2\x2\xA3\xA5\x5j\x36\x2\xA4\xA3\x3\x2\x2\x2\xA4"+
		"\xA5\x3\x2\x2\x2\xA5\xA6\x3\x2\x2\x2\xA6\xA8\a\x106\x2\x2\xA7\xA9\x5j"+
		"\x36\x2\xA8\xA7\x3\x2\x2\x2\xA8\xA9\x3\x2\x2\x2\xA9\xAA\x3\x2\x2\x2\xAA"+
		"\xAC\a\xF4\x2\x2\xAB\x96\x3\x2\x2\x2\xAB\x97\x3\x2\x2\x2\xAB\xA1\x3\x2"+
		"\x2\x2\xAB\xA2\x3\x2\x2\x2\xAC\x19\x3\x2\x2\x2\xAD\xAE\b\xE\x1\x2\xAE"+
		"\xB0\a\xE8\x2\x2\xAF\xB1\x5j\x36\x2\xB0\xAF\x3\x2\x2\x2\xB0\xB1\x3\x2"+
		"\x2\x2\xB1\xB2\x3\x2\x2\x2\xB2\xC7\x5\x1A\xE\x10\xB3\xB5\a\x98\x2\x2\xB4"+
		"\xB6\x5j\x36\x2\xB5\xB4\x3\x2\x2\x2\xB5\xB6\x3\x2\x2\x2\xB6\xB7\x3\x2"+
		"\x2\x2\xB7\xC7\x5\x1A\xE\t\xB8\xC7\x5&\x14\x2\xB9\xBB\a\xE6\x2\x2\xBA"+
		"\xBC\x5j\x36\x2\xBB\xBA\x3\x2\x2\x2\xBB\xBC\x3\x2\x2\x2\xBC\xBD\x3\x2"+
		"\x2\x2\xBD\xBF\x5\x1A\xE\x2\xBE\xC0\x5j\x36\x2\xBF\xBE\x3\x2\x2\x2\xBF"+
		"\xC0\x3\x2\x2\x2\xC0\xC1\x3\x2\x2\x2\xC1\xC2\a\xED\x2\x2\xC2\xC7\x3\x2"+
		"\x2\x2\xC3\xC7\x5\"\x12\x2\xC4\xC7\x5$\x13\x2\xC5\xC7\x5\x1C\xF\x2\xC6"+
		"\xAD\x3\x2\x2\x2\xC6\xB3\x3\x2\x2\x2\xC6\xB8\x3\x2\x2\x2\xC6\xB9\x3\x2"+
		"\x2\x2\xC6\xC3\x3\x2\x2\x2\xC6\xC4\x3\x2\x2\x2\xC6\xC5\x3\x2\x2\x2\xC7"+
		"\x136\x3\x2\x2\x2\xC8\xCA\f\x11\x2\x2\xC9\xCB\x5j\x36\x2\xCA\xC9\x3\x2"+
		"\x2\x2\xCA\xCB\x3\x2\x2\x2\xCB\xCC\x3\x2\x2\x2\xCC\xCE\a\xEC\x2\x2\xCD"+
		"\xCF\x5j\x36\x2\xCE\xCD\x3\x2\x2\x2\xCE\xCF\x3\x2\x2\x2\xCF\xD0\x3\x2"+
		"\x2\x2\xD0\x135\x5\x1A\xE\x12\xD1\xD3\f\xF\x2\x2\xD2\xD4\x5j\x36\x2\xD3"+
		"\xD2\x3\x2\x2\x2\xD3\xD4\x3\x2\x2\x2\xD4\xD5\x3\x2\x2\x2\xD5\xD7\t\x4"+
		"\x2\x2\xD6\xD8\x5j\x36\x2\xD7\xD6\x3\x2\x2\x2\xD7\xD8\x3\x2\x2\x2\xD8"+
		"\xD9\x3\x2\x2\x2\xD9\x135\x5\x1A\xE\x10\xDA\xDC\f\xE\x2\x2\xDB\xDD\x5"+
		"j\x36\x2\xDC\xDB\x3\x2\x2\x2\xDC\xDD\x3\x2\x2\x2\xDD\xDE\x3\x2\x2\x2\xDE"+
		"\xE0\a\xE1\x2\x2\xDF\xE1\x5j\x36\x2\xE0\xDF\x3\x2\x2\x2\xE0\xE1\x3\x2"+
		"\x2\x2\xE1\xE2\x3\x2\x2\x2\xE2\x135\x5\x1A\xE\xF\xE3\xE5\f\r\x2\x2\xE4"+
		"\xE6\x5j\x36\x2\xE5\xE4\x3\x2\x2\x2\xE5\xE6\x3\x2\x2\x2\xE6\xE7\x3\x2"+
		"\x2\x2\xE7\xE9\a\x94\x2\x2\xE8\xEA\x5j\x36\x2\xE9\xE8\x3\x2\x2\x2\xE9"+
		"\xEA\x3\x2\x2\x2\xEA\xEB\x3\x2\x2\x2\xEB\x135\x5\x1A\xE\xE\xEC\xEE\f\f"+
		"\x2\x2\xED\xEF\x5j\x36\x2\xEE\xED\x3\x2\x2\x2\xEE\xEF\x3\x2\x2\x2\xEF"+
		"\xF0\x3\x2\x2\x2\xF0\xF2\t\x5\x2\x2\xF1\xF3\x5j\x36\x2\xF2\xF1\x3\x2\x2"+
		"\x2\xF2\xF3\x3\x2\x2\x2\xF3\xF4\x3\x2\x2\x2\xF4\x135\x5\x1A\xE\r\xF5\xF7"+
		"\f\v\x2\x2\xF6\xF8\x5j\x36\x2\xF7\xF6\x3\x2\x2\x2\xF7\xF8\x3\x2\x2\x2"+
		"\xF8\xF9\x3\x2\x2\x2\xF9\xFB\a\x32\x2\x2\xFA\xFC\x5j\x36\x2\xFB\xFA\x3"+
		"\x2\x2\x2\xFB\xFC\x3\x2\x2\x2\xFC\xFD\x3\x2\x2\x2\xFD\x135\x5\x1A\xE\f"+
		"\xFE\x100\f\n\x2\x2\xFF\x101\x5j\x36\x2\x100\xFF\x3\x2\x2\x2\x100\x101"+
		"\x3\x2\x2\x2\x101\x102\x3\x2\x2\x2\x102\x104\t\x6\x2\x2\x103\x105\x5j"+
		"\x36\x2\x104\x103\x3\x2\x2\x2\x104\x105\x3\x2\x2\x2\x105\x106\x3\x2\x2"+
		"\x2\x106\x135\x5\x1A\xE\v\x107\x109\f\b\x2\x2\x108\x10A\x5j\x36\x2\x109"+
		"\x108\x3\x2\x2\x2\x109\x10A\x3\x2\x2\x2\x10A\x10B\x3\x2\x2\x2\x10B\x10D"+
		"\a\x36\x2\x2\x10C\x10E\x5j\x36\x2\x10D\x10C\x3\x2\x2\x2\x10D\x10E\x3\x2"+
		"\x2\x2\x10E\x10F\x3\x2\x2\x2\x10F\x135\x5\x1A\xE\t\x110\x112\f\a\x2\x2"+
		"\x111\x113\x5j\x36\x2\x112\x111\x3\x2\x2\x2\x112\x113\x3\x2\x2\x2\x113"+
		"\x114\x3\x2\x2\x2\x114\x116\a\xA4\x2\x2\x115\x117\x5j\x36\x2\x116\x115"+
		"\x3\x2\x2\x2\x116\x117\x3\x2\x2\x2\x117\x118\x3\x2\x2\x2\x118\x135\x5"+
		"\x1A\xE\b\x119\x11B\f\x6\x2\x2\x11A\x11C\x5j\x36\x2\x11B\x11A\x3\x2\x2"+
		"\x2\x11B\x11C\x3\x2\x2\x2\x11C\x11D\x3\x2\x2\x2\x11D\x11F\a\xDE\x2\x2"+
		"\x11E\x120\x5j\x36\x2\x11F\x11E\x3\x2\x2\x2\x11F\x120\x3\x2\x2\x2\x120"+
		"\x121\x3\x2\x2\x2\x121\x135\x5\x1A\xE\a\x122\x124\f\x5\x2\x2\x123\x125"+
		"\x5j\x36\x2\x124\x123\x3\x2\x2\x2\x124\x125\x3\x2\x2\x2\x125\x126\x3\x2"+
		"\x2\x2\x126\x128\ak\x2\x2\x127\x129\x5j\x36\x2\x128\x127\x3\x2\x2\x2\x128"+
		"\x129\x3\x2\x2\x2\x129\x12A\x3\x2\x2\x2\x12A\x135\x5\x1A\xE\x6\x12B\x12D"+
		"\f\x4\x2\x2\x12C\x12E\x5j\x36\x2\x12D\x12C\x3\x2\x2\x2\x12D\x12E\x3\x2"+
		"\x2\x2\x12E\x12F\x3\x2\x2\x2\x12F\x131\a~\x2\x2\x130\x132\x5j\x36\x2\x131"+
		"\x130\x3\x2\x2\x2\x131\x132\x3\x2\x2\x2\x132\x133\x3\x2\x2\x2\x133\x135"+
		"\x5\x1A\xE\x5\x134\xC8\x3\x2\x2\x2\x134\xD1\x3\x2\x2\x2\x134\xDA\x3\x2"+
		"\x2\x2\x134\xE3\x3\x2\x2\x2\x134\xEC\x3\x2\x2\x2\x134\xF5\x3\x2\x2\x2"+
		"\x134\xFE\x3\x2\x2\x2\x134\x107\x3\x2\x2\x2\x134\x110\x3\x2\x2\x2\x134"+
		"\x119\x3\x2\x2\x2\x134\x122\x3\x2\x2\x2\x134\x12B\x3\x2\x2\x2\x135\x138"+
		"\x3\x2\x2\x2\x136\x134\x3\x2\x2\x2\x136\x137\x3\x2\x2\x2\x137\x1B\x3\x2"+
		"\x2\x2\x138\x136\x3\x2\x2\x2\x139\x141\x5\x1E\x10\x2\x13A\x141\a\xFA\x2"+
		"\x2\x13B\x141\a\xF5\x2\x2\x13C\x13E\x5\x62\x32\x2\x13D\x13F\x5\x14\v\x2"+
		"\x13E\x13D\x3\x2\x2\x2\x13E\x13F\x3\x2\x2\x2\x13F\x141\x3\x2\x2\x2\x140"+
		"\x139\x3\x2\x2\x2\x140\x13A\x3\x2\x2\x2\x140\x13B\x3\x2\x2\x2\x140\x13C"+
		"\x3\x2\x2\x2\x141\x1D\x3\x2\x2\x2\x142\x143\t\a\x2\x2\x143\x1F\x3\x2\x2"+
		"\x2\x144\x146\a\xE6\x2\x2\x145\x147\x5j\x36\x2\x146\x145\x3\x2\x2\x2\x146"+
		"\x147\x3\x2\x2\x2\x147\x148\x3\x2\x2\x2\x148\x14A\x5\x1A\xE\x2\x149\x14B"+
		"\x5j\x36\x2\x14A\x149\x3\x2\x2\x2\x14A\x14B\x3\x2\x2\x2\x14B\x14C\x3\x2"+
		"\x2\x2\x14C\x14D\a\xED\x2\x2\x14D!\x3\x2\x2\x2\x14E\x14F\a\xD2\x2\x2\x14F"+
		"\x150\x5j\x36\x2\x150\x151\x5\x1A\xE\x2\x151\x152\x5j\x36\x2\x152\x153"+
		"\a\x82\x2\x2\x153\x154\x5j\x36\x2\x154\x155\x5H%\x2\x155#\x3\x2\x2\x2"+
		"\x156\x157\a\x97\x2\x2\x157\x158\x5j\x36\x2\x158\x159\x5H%\x2\x159%\x3"+
		"\x2\x2\x2\x15A\x15B\b\x14\x1\x2\x15B\x15F\x5> \x2\x15C\x15F\x5<\x1F\x2"+
		"\x15D\x15F\x5@!\x2\x15E\x15A\x3\x2\x2\x2\x15E\x15C\x3\x2\x2\x2\x15E\x15D"+
		"\x3\x2\x2\x2\x15F\x187\x3\x2\x2\x2\x160\x162\f\v\x2\x2\x161\x163\x5j\x36"+
		"\x2\x162\x161\x3\x2\x2\x2\x162\x163\x3\x2\x2\x2\x163\x164\x3\x2\x2\x2"+
		"\x164\x166\a\xE6\x2\x2\x165\x167\x5j\x36\x2\x166\x165\x3\x2\x2\x2\x166"+
		"\x167\x3\x2\x2\x2\x167\x169\x3\x2\x2\x2\x168\x16A\x5.\x18\x2\x169\x168"+
		"\x3\x2\x2\x2\x169\x16A\x3\x2\x2\x2\x16A\x16C\x3\x2\x2\x2\x16B\x16D\x5"+
		"j\x36\x2\x16C\x16B\x3\x2\x2\x2\x16C\x16D\x3\x2\x2\x2\x16D\x16E\x3\x2\x2"+
		"\x2\x16E\x186\a\xED\x2\x2\x16F\x170\f\n\x2\x2\x170\x171\a-\x2\x2\x171"+
		"\x186\x5\x4\x3\x2\x172\x173\f\t\x2\x2\x173\x175\a\x102\x2\x2\x174\x176"+
		"\x5j\x36\x2\x175\x174\x3\x2\x2\x2\x175\x176\x3\x2\x2\x2\x176\x177\x3\x2"+
		"\x2\x2\x177\x178\a-\x2\x2\x178\x186\x5\x4\x3\x2\x179\x17A\f\b\x2\x2\x17A"+
		"\x17B\a,\x2\x2\x17B\x186\x5\x4\x3\x2\x17C\x17D\f\a\x2\x2\x17D\x17E\a\x102"+
		"\x2\x2\x17E\x17F\a,\x2\x2\x17F\x186\x5\x4\x3\x2\x180\x181\f\x6\x2\x2\x181"+
		"\x182\a\x102\x2\x2\x182\x183\a,\x2\x2\x183\x184\a\x102\x2\x2\x184\x186"+
		"\x5\x4\x3\x2\x185\x160\x3\x2\x2\x2\x185\x16F\x3\x2\x2\x2\x185\x172\x3"+
		"\x2\x2\x2\x185\x179\x3\x2\x2\x2\x185\x17C\x3\x2\x2\x2\x185\x180\x3\x2"+
		"\x2\x2\x186\x189\x3\x2\x2\x2\x187\x185\x3\x2\x2\x2\x187\x188\x3\x2\x2"+
		"\x2\x188\'\x3\x2\x2\x2\x189\x187\x3\x2\x2\x2\x18A\x18B\x5&\x14\x2\x18B"+
		"\x18C\a-\x2\x2\x18C\x18D\x5\x4\x3\x2\x18D\x197\x3\x2\x2\x2\x18E\x18F\x5"+
		"&\x14\x2\x18F\x191\a\x102\x2\x2\x190\x192\x5j\x36\x2\x191\x190\x3\x2\x2"+
		"\x2\x191\x192\x3\x2\x2\x2\x192\x193\x3\x2\x2\x2\x193\x194\a-\x2\x2\x194"+
		"\x195\x5\x4\x3\x2\x195\x197\x3\x2\x2\x2\x196\x18A\x3\x2\x2\x2\x196\x18E"+
		"\x3\x2\x2\x2\x197)\x3\x2\x2\x2\x198\x19A\x5&\x14\x2\x199\x19B\x5j\x36"+
		"\x2\x19A\x199\x3\x2\x2\x2\x19A\x19B\x3\x2\x2\x2\x19B\x19C\x3\x2\x2\x2"+
		"\x19C\x19E\a\xE6\x2\x2\x19D\x19F\x5j\x36\x2\x19E\x19D\x3\x2\x2\x2\x19E"+
		"\x19F\x3\x2\x2\x2\x19F\x1A1\x3\x2\x2\x2\x1A0\x1A2\x5.\x18\x2\x1A1\x1A0"+
		"\x3\x2\x2\x2\x1A1\x1A2\x3\x2\x2\x2\x1A2\x1A4\x3\x2\x2\x2\x1A3\x1A5\x5"+
		"j\x36\x2\x1A4\x1A3\x3\x2\x2\x2\x1A4\x1A5\x3\x2\x2\x2\x1A5\x1A6\x3\x2\x2"+
		"\x2\x1A6\x1A7\a\xED\x2\x2\x1A7+\x3\x2\x2\x2\x1A8\x1A9\x5&\x14\x2\x1A9"+
		"\x1AA\a,\x2\x2\x1AA\x1AB\x5\x4\x3\x2\x1AB\x1B8\x3\x2\x2\x2\x1AC\x1AD\x5"+
		"&\x14\x2\x1AD\x1AE\a\x102\x2\x2\x1AE\x1AF\a,\x2\x2\x1AF\x1B0\x5\x4\x3"+
		"\x2\x1B0\x1B8\x3\x2\x2\x2\x1B1\x1B2\x5&\x14\x2\x1B2\x1B3\a\x102\x2\x2"+
		"\x1B3\x1B4\a,\x2\x2\x1B4\x1B5\a\x102\x2\x2\x1B5\x1B6\x5\x4\x3\x2\x1B6"+
		"\x1B8\x3\x2\x2\x2\x1B7\x1A8\x3\x2\x2\x2\x1B7\x1AC\x3\x2\x2\x2\x1B7\x1B1"+
		"\x3\x2\x2\x2\x1B8-\x3\x2\x2\x2\x1B9\x1BA\x5\x30\x19\x2\x1BA/\x3\x2\x2"+
		"\x2\x1BB\x1BD\x5\x32\x1A\x2\x1BC\x1BB\x3\x2\x2\x2\x1BC\x1BD\x3\x2\x2\x2"+
		"\x1BD\x1BF\x3\x2\x2\x2\x1BE\x1C0\x5j\x36\x2\x1BF\x1BE\x3\x2\x2\x2\x1BF"+
		"\x1C0\x3\x2\x2\x2\x1C0\x1C1\x3\x2\x2\x2\x1C1\x1C3\a)\x2\x2\x1C2\x1C4\x5"+
		"j\x36\x2\x1C3\x1C2\x3\x2\x2\x2\x1C3\x1C4\x3\x2\x2\x2\x1C4\x1C6\x3\x2\x2"+
		"\x2\x1C5\x1BC\x3\x2\x2\x2\x1C6\x1C9\x3\x2\x2\x2\x1C7\x1C5\x3\x2\x2\x2"+
		"\x1C7\x1C8\x3\x2\x2\x2\x1C8\x1CA\x3\x2\x2\x2\x1C9\x1C7\x3\x2\x2\x2\x1CA"+
		"\x1DC\x5\x34\x1B\x2\x1CB\x1CD\x5\x32\x1A\x2\x1CC\x1CB\x3\x2\x2\x2\x1CC"+
		"\x1CD\x3\x2\x2\x2\x1CD\x1CF\x3\x2\x2\x2\x1CE\x1D0\x5j\x36\x2\x1CF\x1CE"+
		"\x3\x2\x2\x2\x1CF\x1D0\x3\x2\x2\x2\x1D0\x1D1\x3\x2\x2\x2\x1D1\x1D3\a)"+
		"\x2\x2\x1D2\x1D4\x5j\x36\x2\x1D3\x1D2\x3\x2\x2\x2\x1D3\x1D4\x3\x2\x2\x2"+
		"\x1D4\x1D6\x3\x2\x2\x2\x1D5\x1CC\x3\x2\x2\x2\x1D6\x1D9\x3\x2\x2\x2\x1D7"+
		"\x1D5\x3\x2\x2\x2\x1D7\x1D8\x3\x2\x2\x2\x1D8\x1DA\x3\x2\x2\x2\x1D9\x1D7"+
		"\x3\x2\x2\x2\x1DA\x1DC\x5\x36\x1C\x2\x1DB\x1C7\x3\x2\x2\x2\x1DB\x1D7\x3"+
		"\x2\x2\x2\x1DC\x31\x3\x2\x2\x2\x1DD\x1DE\x5:\x1E\x2\x1DE\x33\x3\x2\x2"+
		"\x2\x1DF\x1E0\x5:\x1E\x2\x1E0\x35\x3\x2\x2\x2\x1E1\x1EC\x5\x38\x1D\x2"+
		"\x1E2\x1E4\x5j\x36\x2\x1E3\x1E2\x3\x2\x2\x2\x1E3\x1E4\x3\x2\x2\x2\x1E4"+
		"\x1E5\x3\x2\x2\x2\x1E5\x1E7\a)\x2\x2\x1E6\x1E8\x5j\x36\x2\x1E7\x1E6\x3"+
		"\x2\x2\x2\x1E7\x1E8\x3\x2\x2\x2\x1E8\x1E9\x3\x2\x2\x2\x1E9\x1EB\x5\x38"+
		"\x1D\x2\x1EA\x1E3\x3\x2\x2\x2\x1EB\x1EE\x3\x2\x2\x2\x1EC\x1EA\x3\x2\x2"+
		"\x2\x1EC\x1ED\x3\x2\x2\x2\x1ED\x37\x3\x2\x2\x2\x1EE\x1EC\x3\x2\x2\x2\x1EF"+
		"\x1F1\x5\x4\x3\x2\x1F0\x1F2\x5j\x36\x2\x1F1\x1F0\x3\x2\x2\x2\x1F1\x1F2"+
		"\x3\x2\x2\x2\x1F2\x1F3\x3\x2\x2\x2\x1F3\x1F5\a\xDF\x2\x2\x1F4\x1F6\x5"+
		"j\x36\x2\x1F5\x1F4\x3\x2\x2\x2\x1F5\x1F6\x3\x2\x2\x2\x1F6\x1F7\x3\x2\x2"+
		"\x2\x1F7\x1F8\x5:\x1E\x2\x1F8\x39\x3\x2\x2\x2\x1F9\x1FA\a?\x2\x2\x1FA"+
		"\x1FC\x5j\x36\x2\x1FB\x1F9\x3\x2\x2\x2\x1FB\x1FC\x3\x2\x2\x2\x1FC\x1FD"+
		"\x3\x2\x2\x2\x1FD\x200\x5\x1A\xE\x2\x1FE\x200\x5L\'\x2\x1FF\x1FB\x3\x2"+
		"\x2\x2\x1FF\x1FE\x3\x2\x2\x2\x200;\x3\x2\x2\x2\x201\x202\x5\x6\x4\x2\x202"+
		"=\x3\x2\x2\x2\x203\x204\a\x91\x2\x2\x204?\x3\x2\x2\x2\x205\x208\x5\x42"+
		"\"\x2\x206\x208\x5\x44#\x2\x207\x205\x3\x2\x2\x2\x207\x206\x3\x2\x2\x2"+
		"\x208\x41\x3\x2\x2\x2\x209\x20A\a-\x2\x2\x20A\x20B\x5\x4\x3\x2\x20B\x43"+
		"\x3\x2\x2\x2\x20C\x20D\a,\x2\x2\x20D\x20E\x5\x4\x3\x2\x20E\x45\x3\x2\x2"+
		"\x2\x20F\x210\x5\x1A\xE\x2\x210G\x3\x2\x2\x2\x211\x214\x5\x18\r\x2\x212"+
		"\x214\x5J&\x2\x213\x211\x3\x2\x2\x2\x213\x212\x3\x2\x2\x2\x214I\x3\x2"+
		"\x2\x2\x215\x218\x5<\x1F\x2\x216\x218\x5(\x15\x2\x217\x215\x3\x2\x2\x2"+
		"\x217\x216\x3\x2\x2\x2\x218K\x3\x2\x2\x2\x219\x21A\a\x34\x2\x2\x21A\x21B"+
		"\x5j\x36\x2\x21B\x21C\x5N(\x2\x21CM\x3\x2\x2\x2\x21D\x220\x5(\x15\x2\x21E"+
		"\x220\x5<\x1F\x2\x21F\x21D\x3\x2\x2\x2\x21F\x21E\x3\x2\x2\x2\x220O\x3"+
		"\x2\x2\x2\x221\x22A\x5R*\x2\x222\x22A\x5V,\x2\x223\x22A\x5X-\x2\x224\x22A"+
		"\x5^\x30\x2\x225\x22A\x5Z.\x2\x226\x22A\x5\x62\x32\x2\x227\x22A\x5T+\x2"+
		"\x228\x22A\x5`\x31\x2\x229\x221\x3\x2\x2\x2\x229\x222\x3\x2\x2\x2\x229"+
		"\x223\x3\x2\x2\x2\x229\x224\x3\x2\x2\x2\x229\x225\x3\x2\x2\x2\x229\x226"+
		"\x3\x2\x2\x2\x229\x227\x3\x2\x2\x2\x229\x228\x3\x2\x2\x2\x22AQ\x3\x2\x2"+
		"\x2\x22B\x22C\t\b\x2\x2\x22CS\x3\x2\x2\x2\x22D\x22E\a\xB6\x2\x2\x22EU"+
		"\x3\x2\x2\x2\x22F\x230\t\t\x2\x2\x230W\x3\x2\x2\x2\x231\x232\t\n\x2\x2"+
		"\x232Y\x3\x2\x2\x2\x233\x236\a\x91\x2\x2\x234\x236\x5\\/\x2\x235\x233"+
		"\x3\x2\x2\x2\x235\x234\x3\x2\x2\x2\x236[\x3\x2\x2\x2\x237\x238\t\v\x2"+
		"\x2\x238]\x3\x2\x2\x2\x239\x23A\t\f\x2\x2\x23A_\x3\x2\x2\x2\x23B\x23C"+
		"\t\r\x2\x2\x23C\x61\x3\x2\x2\x2\x23D\x241\x5\x64\x33\x2\x23E\x241\x5\x66"+
		"\x34\x2\x23F\x241\x5h\x35\x2\x240\x23D\x3\x2\x2\x2\x240\x23E\x3\x2\x2"+
		"\x2\x240\x23F\x3\x2\x2\x2\x241\x63\x3\x2\x2\x2\x242\x243\t\xE\x2\x2\x243"+
		"\x65\x3\x2\x2\x2\x244\x245\a\x99\x2\x2\x245g\x3\x2\x2\x2\x246\x247\t\xF"+
		"\x2\x2\x247i\x3\x2\x2\x2\x248\x24A\t\x10\x2\x2\x249\x248\x3\x2\x2\x2\x24A"+
		"\x24B\x3\x2\x2\x2\x24B\x249\x3\x2\x2\x2\x24B\x24C\x3\x2\x2\x2\x24Ck\x3"+
		"\x2\x2\x2Vquy\x86\x90\x99\x9D\xA4\xA8\xAB\xB0\xB5\xBB\xBF\xC6\xCA\xCE"+
		"\xD3\xD7\xDC\xE0\xE5\xE9\xEE\xF2\xF7\xFB\x100\x104\x109\x10D\x112\x116"+
		"\x11B\x11F\x124\x128\x12D\x131\x134\x136\x13E\x140\x146\x14A\x15E\x162"+
		"\x166\x169\x16C\x175\x185\x187\x191\x196\x19A\x19E\x1A1\x1A4\x1B7\x1BC"+
		"\x1BF\x1C3\x1C7\x1CC\x1CF\x1D3\x1D7\x1DB\x1E3\x1E7\x1EC\x1F1\x1F5\x1FB"+
		"\x1FF\x207\x213\x217\x21F\x229\x235\x240\x24B";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace Rubberduck.Parsing.Binding
