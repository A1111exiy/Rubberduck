//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.3
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Users\Splinter\Documents\Visual Studio 2015\Projects\RubberduckParserTest\RubberduckParserTest\VBAExpressionParser.g4 by ANTLR 4.3

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

namespace Rubberduck.Parsing.Binding {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.3")]
[System.CLSCompliant(false)]
public partial class VBAExpressionParser : Parser {
	public const int
		PRINT=156, ELSEIF=88, CBYTE=5, CLOSE=65, STATIC=180, MINUS=212, OPTION_EXPLICIT=149, 
		L_SQUARE_BRACKET=223, DOEVENTS=21, HASHENDIF=222, DATELITERAL=230, ERROR=102, 
		NOTHING=141, EACH=86, SUB=184, STOP=182, LPAREN=210, MID=136, CVERR=19, 
		AS=55, END_PROPERTY=93, AT=45, DATABASE=67, GOSUB=115, CSNG=15, HASHCONST=218, 
		POW=216, DOLLAR=47, PROPERTY_LET=159, THEN=187, XOR=202, EXIT_FOR=105, 
		DEFINT=75, HASHIF=219, UNLOCK=192, CALL=62, LOCK_READ=131, SET=176, LOCK_READ_WRITE=133, 
		ABS=1, LSET=134, RAISEEVENT=165, MIDBTYPESUFFIX=32, SEEK=174, LONG=125, 
		CBOOL=4, LIB=128, DIM=83, APPEND=54, OPEN=146, DIV=204, PROPERTY_SET=160, 
		CDBL=8, PERCENT=46, END_SELECT=94, STRING=183, HASHELSEIF=220, SGN=37, 
		REM=169, TO=188, DEFDBL=73, BYVAL=59, FRIEND=110, LOOP=126, CLASS=64, 
		DO=84, VARIANT=194, END_WITH=97, DEFBOOL=70, OPTIONAL=147, ADDRESSOF=50, 
		CONST=66, RSET=173, INTEGER=123, CDEC=9, REMCOMMENT=232, ATTRIBUTE=53, 
		OUTPUT=153, FOR=111, PTRSAFE=161, EQ=206, BOOLEAN=58, CIRCLE=11, END_FUNCTION=91, 
		DEFSNG=80, DEFBYTE=71, NOT=140, CINT=10, END=98, PRESERVE=155, ON_LOCAL_ERROR=145, 
		FLOATLITERAL=228, HASHELSE=221, BINARY=57, LENB=28, RETURN=172, EXCLAMATIONPOINT=42, 
		NEXT=138, GLOBAL=114, INPUTB=24, IDENTIFIER=237, WS=236, EMPTY=89, CURRENCY=17, 
		CCUR=6, MOD=137, WITHEVENTS=200, COLON=40, DEFLNGLNG=77, STEP=181, OPTION_BASE=148, 
		GT=208, PUT=163, WITH=199, CSTR=16, LOCK_WRITE=132, LINE_CONTINUATION=238, 
		TYPEOF=191, DEFVAR=82, DEFLNG=76, UBOUND=38, FALSE=109, ERRORCHAR=240, 
		UNDERSCORE=235, INTEGERLITERAL=229, END_IF=92, LOCK=124, TEXT=186, SINGLEQUOTE=234, 
		MULT=213, SEMICOLON=41, BYTE=61, HEXLITERAL=227, ELSE=87, IF=117, TYPE=190, 
		AMPERSAND=48, DEFLNGPTR=78, ENUM=99, DEFOBJ=79, IN=120, OPTION=34, DOT=43, 
		EXIT_DO=104, GUIDLITERAL=239, IS=122, EQV=100, WEND=196, FUNCTION=112, 
		HASH=44, CASE=63, GEQ=207, GET=113, PUBLIC=162, ON_ERROR=144, EXIT=22, 
		MIDB=31, END_ENUM=90, GOTO=116, INTDIV=205, LONGPTR=30, WIDTH=198, BEGIN=56, 
		EXIT_SUB=108, ASSIGN=203, COMMENT=233, WRITE=201, DOUBLE=85, EXIT_PROPERTY=107, 
		COMMA=39, RANDOM=164, PROPERTY_GET=158, SELECT=175, PRIVATE=157, ERASE=101, 
		TAB=185, BYREF=60, VERSION=195, NEQ=214, END_TYPE=96, NEW=139, ARRAY=3, 
		INPUT=121, SINGLE=178, ALIAS=51, SPC=179, LT=211, RESET=170, END_SUB=95, 
		EVENT=103, READ_WRITE=167, OPTION_COMPARE=150, ME=135, SCALE=36, CDATE=7, 
		MIDTYPESUFFIX=33, NULL=142, NEWLINE=231, TRUE=189, RPAREN=217, IMP=118, 
		STRINGLITERAL=225, OCTLITERAL=226, READ=166, DATE=68, LIKE=129, AND=52, 
		OPTION_PRIVATE_MODULE=151, CLNGLNG=13, PLUS=215, ANY=2, RESUME=171, INT=25, 
		SHARED=177, EXIT_FUNCTION=106, PSET=35, ACCESS=49, LINE_INPUT=130, ON=143, 
		OR=152, PARAMARRAY=154, LBOUND=26, R_SQUARE_BRACKET=224, IMPLEMENTS=119, 
		UNTIL=193, DEBUG=20, DEFCUR=74, CLNGPTR=14, LONGLONG=29, DECLARE=69, DEFDATE=72, 
		FIX=23, LEN=27, REDIM=168, LEQ=209, DEFSTR=81, LET=127, WHILE=197, CVAR=18, 
		CLNG=12, FOREIGNNAME=241, OBJECT=242, COLLECTION=243;
	public static readonly string[] tokenNames = {
		"<INVALID>", "ABS", "ANY", "ARRAY", "CBOOL", "CBYTE", "CCUR", "CDATE", 
		"CDBL", "CDEC", "CINT", "CIRCLE", "CLNG", "CLNGLNG", "CLNGPTR", "CSNG", 
		"CSTR", "CURRENCY", "CVAR", "CVERR", "DEBUG", "DOEVENTS", "EXIT", "FIX", 
		"INPUTB", "INT", "LBOUND", "LEN", "LENB", "LONGLONG", "LONGPTR", "MIDB", 
		"MIDBTYPESUFFIX", "MIDTYPESUFFIX", "OPTION", "PSET", "SCALE", "SGN", "UBOUND", 
		"','", "':'", "';'", "'!'", "'.'", "'#'", "'@'", "'%'", "'$'", "'&'", 
		"ACCESS", "ADDRESSOF", "ALIAS", "AND", "ATTRIBUTE", "APPEND", "AS", "BEGIN", 
		"BINARY", "BOOLEAN", "BYVAL", "BYREF", "BYTE", "CALL", "CASE", "CLASS", 
		"CLOSE", "CONST", "DATABASE", "DATE", "DECLARE", "DEFBOOL", "DEFBYTE", 
		"DEFDATE", "DEFDBL", "DEFCUR", "DEFINT", "DEFLNG", "DEFLNGLNG", "DEFLNGPTR", 
		"DEFOBJ", "DEFSNG", "DEFSTR", "DEFVAR", "DIM", "DO", "DOUBLE", "EACH", 
		"ELSE", "ELSEIF", "EMPTY", "END_ENUM", "END_FUNCTION", "END_IF", "END_PROPERTY", 
		"END_SELECT", "END_SUB", "END_TYPE", "END_WITH", "END", "ENUM", "EQV", 
		"ERASE", "ERROR", "EVENT", "EXIT_DO", "EXIT_FOR", "EXIT_FUNCTION", "EXIT_PROPERTY", 
		"EXIT_SUB", "FALSE", "FRIEND", "FOR", "FUNCTION", "GET", "GLOBAL", "GOSUB", 
		"GOTO", "IF", "IMP", "IMPLEMENTS", "IN", "INPUT", "IS", "INTEGER", "LOCK", 
		"LONG", "LOOP", "LET", "LIB", "LIKE", "LINE_INPUT", "LOCK_READ", "LOCK_WRITE", 
		"LOCK_READ_WRITE", "LSET", "ME", "MID", "MOD", "NEXT", "NEW", "NOT", "NOTHING", 
		"NULL", "ON", "ON_ERROR", "ON_LOCAL_ERROR", "OPEN", "OPTIONAL", "OPTION_BASE", 
		"OPTION_EXPLICIT", "OPTION_COMPARE", "OPTION_PRIVATE_MODULE", "OR", "OUTPUT", 
		"PARAMARRAY", "PRESERVE", "PRINT", "PRIVATE", "PROPERTY_GET", "PROPERTY_LET", 
		"PROPERTY_SET", "PTRSAFE", "PUBLIC", "PUT", "RANDOM", "RAISEEVENT", "READ", 
		"READ_WRITE", "REDIM", "REM", "RESET", "RESUME", "RETURN", "RSET", "SEEK", 
		"SELECT", "SET", "SHARED", "SINGLE", "SPC", "STATIC", "STEP", "STOP", 
		"STRING", "SUB", "TAB", "TEXT", "THEN", "TO", "TRUE", "TYPE", "TYPEOF", 
		"UNLOCK", "UNTIL", "VARIANT", "VERSION", "WEND", "WHILE", "WIDTH", "WITH", 
		"WITHEVENTS", "WRITE", "XOR", "':='", "'/'", "'\\'", "'='", "GEQ", "'>'", 
		"LEQ", "'('", "'<'", "'-'", "'*'", "NEQ", "'+'", "'^'", "')'", "HASHCONST", 
		"HASHIF", "HASHELSEIF", "HASHELSE", "HASHENDIF", "'['", "']'", "STRINGLITERAL", 
		"OCTLITERAL", "HEXLITERAL", "FLOATLITERAL", "INTEGERLITERAL", "DATELITERAL", 
		"NEWLINE", "REMCOMMENT", "COMMENT", "'''", "'_'", "WS", "IDENTIFIER", 
		"LINE_CONTINUATION", "GUIDLITERAL", "ERRORCHAR", "FOREIGNNAME", "OBJECT", 
		"COLLECTION"
	};
	public const int
		RULE_startRule = 0, RULE_unrestrictedName = 1, RULE_name = 2, RULE_reservedIdentifierName = 3, 
		RULE_reservedUntypedName = 4, RULE_reservedTypedName = 5, RULE_untypedName = 6, 
		RULE_typedName = 7, RULE_typedNameValue = 8, RULE_typeSuffix = 9, RULE_optionCompareArgument = 10, 
		RULE_builtInType = 11, RULE_expression = 12, RULE_literalExpression = 13, 
		RULE_numberLiteral = 14, RULE_parenthesizedExpression = 15, RULE_typeOfIsExpression = 16, 
		RULE_newExpression = 17, RULE_lExpression = 18, RULE_memberAccessExpression = 19, 
		RULE_indexExpression = 20, RULE_dictionaryAccessExpression = 21, RULE_argumentList = 22, 
		RULE_positionalOrNamedArgumentList = 23, RULE_positionalArgument = 24, 
		RULE_requiredPositionalArgument = 25, RULE_namedArgumentList = 26, RULE_namedArgument = 27, 
		RULE_argumentExpression = 28, RULE_simpleNameExpression = 29, RULE_instanceExpression = 30, 
		RULE_withExpression = 31, RULE_withMemberAccessExpression = 32, RULE_withDictionaryAccessExpression = 33, 
		RULE_constantExpression = 34, RULE_typeExpression = 35, RULE_definedTypeExpression = 36, 
		RULE_addressOfExpression = 37, RULE_procedurePointerExpression = 38, RULE_reservedIdentifier = 39, 
		RULE_statementKeyword = 40, RULE_remKeyword = 41, RULE_markerKeyword = 42, 
		RULE_operatorIdentifier = 43, RULE_reservedName = 44, RULE_reservedProcedureName = 45, 
		RULE_specialForm = 46, RULE_reservedTypeIdentifier = 47, RULE_uncategorizedKeyword = 48, 
		RULE_literalIdentifier = 49, RULE_booleanLiteralIdentifier = 50, RULE_objectLiteralIdentifier = 51, 
		RULE_variantLiteralIdentifier = 52, RULE_whiteSpace = 53;
	public static readonly string[] ruleNames = {
		"startRule", "unrestrictedName", "name", "reservedIdentifierName", "reservedUntypedName", 
		"reservedTypedName", "untypedName", "typedName", "typedNameValue", "typeSuffix", 
		"optionCompareArgument", "builtInType", "expression", "literalExpression", 
		"numberLiteral", "parenthesizedExpression", "typeOfIsExpression", "newExpression", 
		"lExpression", "memberAccessExpression", "indexExpression", "dictionaryAccessExpression", 
		"argumentList", "positionalOrNamedArgumentList", "positionalArgument", 
		"requiredPositionalArgument", "namedArgumentList", "namedArgument", "argumentExpression", 
		"simpleNameExpression", "instanceExpression", "withExpression", "withMemberAccessExpression", 
		"withDictionaryAccessExpression", "constantExpression", "typeExpression", 
		"definedTypeExpression", "addressOfExpression", "procedurePointerExpression", 
		"reservedIdentifier", "statementKeyword", "remKeyword", "markerKeyword", 
		"operatorIdentifier", "reservedName", "reservedProcedureName", "specialForm", 
		"reservedTypeIdentifier", "uncategorizedKeyword", "literalIdentifier", 
		"booleanLiteralIdentifier", "objectLiteralIdentifier", "variantLiteralIdentifier", 
		"whiteSpace"
	};

	public override string GrammarFileName { get { return "VBAExpressionParser.g4"; } }

	public override string[] TokenNames { get { return tokenNames; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public VBAExpressionParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class StartRuleContext : ParserRuleContext {
		public ITerminalNode Eof() { return GetToken(VBAExpressionParser.Eof, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public StartRuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_startRule; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterStartRule(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitStartRule(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStartRule(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StartRuleContext startRule() {
		StartRuleContext _localctx = new StartRuleContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_startRule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 108; expression(0);
			State = 109; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnrestrictedNameContext : ParserRuleContext {
		public ReservedIdentifierNameContext reservedIdentifierName() {
			return GetRuleContext<ReservedIdentifierNameContext>(0);
		}
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public UnrestrictedNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unrestrictedName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterUnrestrictedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitUnrestrictedName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnrestrictedName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnrestrictedNameContext unrestrictedName() {
		UnrestrictedNameContext _localctx = new UnrestrictedNameContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_unrestrictedName);
		try {
			State = 113;
			switch ( Interpreter.AdaptivePredict(_input,0,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 111; name();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 112; reservedIdentifierName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NameContext : ParserRuleContext {
		public TypedNameContext typedName() {
			return GetRuleContext<TypedNameContext>(0);
		}
		public UntypedNameContext untypedName() {
			return GetRuleContext<UntypedNameContext>(0);
		}
		public NameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NameContext name() {
		NameContext _localctx = new NameContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_name);
		try {
			State = 117;
			switch ( Interpreter.AdaptivePredict(_input,1,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 115; untypedName();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 116; typedName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedIdentifierNameContext : ParserRuleContext {
		public ReservedTypedNameContext reservedTypedName() {
			return GetRuleContext<ReservedTypedNameContext>(0);
		}
		public ReservedUntypedNameContext reservedUntypedName() {
			return GetRuleContext<ReservedUntypedNameContext>(0);
		}
		public ReservedIdentifierNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedIdentifierName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedIdentifierName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedIdentifierName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedIdentifierName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedIdentifierNameContext reservedIdentifierName() {
		ReservedIdentifierNameContext _localctx = new ReservedIdentifierNameContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_reservedIdentifierName);
		try {
			State = 121;
			switch ( Interpreter.AdaptivePredict(_input,2,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 119; reservedUntypedName();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 120; reservedTypedName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedUntypedNameContext : ParserRuleContext {
		public ReservedIdentifierContext reservedIdentifier() {
			return GetRuleContext<ReservedIdentifierContext>(0);
		}
		public ReservedUntypedNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedUntypedName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedUntypedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedUntypedName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedUntypedName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedUntypedNameContext reservedUntypedName() {
		ReservedUntypedNameContext _localctx = new ReservedUntypedNameContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_reservedUntypedName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 123; reservedIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedTypedNameContext : ParserRuleContext {
		public TypeSuffixContext typeSuffix() {
			return GetRuleContext<TypeSuffixContext>(0);
		}
		public ReservedIdentifierContext reservedIdentifier() {
			return GetRuleContext<ReservedIdentifierContext>(0);
		}
		public ReservedTypedNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedTypedName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedTypedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedTypedName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedTypedName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedTypedNameContext reservedTypedName() {
		ReservedTypedNameContext _localctx = new ReservedTypedNameContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_reservedTypedName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 125; reservedIdentifier();
			State = 126; typeSuffix();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UntypedNameContext : ParserRuleContext {
		public UncategorizedKeywordContext uncategorizedKeyword() {
			return GetRuleContext<UncategorizedKeywordContext>(0);
		}
		public ITerminalNode FOREIGNNAME() { return GetToken(VBAExpressionParser.FOREIGNNAME, 0); }
		public SpecialFormContext specialForm() {
			return GetRuleContext<SpecialFormContext>(0);
		}
		public ITerminalNode OBJECT() { return GetToken(VBAExpressionParser.OBJECT, 0); }
		public ITerminalNode ERROR() { return GetToken(VBAExpressionParser.ERROR, 0); }
		public OptionCompareArgumentContext optionCompareArgument() {
			return GetRuleContext<OptionCompareArgumentContext>(0);
		}
		public ITerminalNode IDENTIFIER() { return GetToken(VBAExpressionParser.IDENTIFIER, 0); }
		public ReservedProcedureNameContext reservedProcedureName() {
			return GetRuleContext<ReservedProcedureNameContext>(0);
		}
		public UntypedNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_untypedName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterUntypedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitUntypedName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUntypedName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UntypedNameContext untypedName() {
		UntypedNameContext _localctx = new UntypedNameContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_untypedName);
		try {
			State = 136;
			switch ( Interpreter.AdaptivePredict(_input,3,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 128; Match(IDENTIFIER);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 129; Match(FOREIGNNAME);
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 130; reservedProcedureName();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 131; specialForm();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 132; optionCompareArgument();
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 133; Match(OBJECT);
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 134; uncategorizedKeyword();
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 135; Match(ERROR);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypedNameContext : ParserRuleContext {
		public TypeSuffixContext typeSuffix() {
			return GetRuleContext<TypeSuffixContext>(0);
		}
		public TypedNameValueContext typedNameValue() {
			return GetRuleContext<TypedNameValueContext>(0);
		}
		public TypedNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typedName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterTypedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitTypedName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypedName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypedNameContext typedName() {
		TypedNameContext _localctx = new TypedNameContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_typedName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 138; typedNameValue();
			State = 139; typeSuffix();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypedNameValueContext : ParserRuleContext {
		public UncategorizedKeywordContext uncategorizedKeyword() {
			return GetRuleContext<UncategorizedKeywordContext>(0);
		}
		public SpecialFormContext specialForm() {
			return GetRuleContext<SpecialFormContext>(0);
		}
		public ITerminalNode OBJECT() { return GetToken(VBAExpressionParser.OBJECT, 0); }
		public ITerminalNode ERROR() { return GetToken(VBAExpressionParser.ERROR, 0); }
		public OptionCompareArgumentContext optionCompareArgument() {
			return GetRuleContext<OptionCompareArgumentContext>(0);
		}
		public ITerminalNode IDENTIFIER() { return GetToken(VBAExpressionParser.IDENTIFIER, 0); }
		public ReservedProcedureNameContext reservedProcedureName() {
			return GetRuleContext<ReservedProcedureNameContext>(0);
		}
		public TypedNameValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typedNameValue; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterTypedNameValue(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitTypedNameValue(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypedNameValue(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypedNameValueContext typedNameValue() {
		TypedNameValueContext _localctx = new TypedNameValueContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_typedNameValue);
		try {
			State = 148;
			switch ( Interpreter.AdaptivePredict(_input,4,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 141; Match(IDENTIFIER);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 142; reservedProcedureName();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 143; specialForm();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 144; optionCompareArgument();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 145; Match(OBJECT);
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 146; uncategorizedKeyword();
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 147; Match(ERROR);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeSuffixContext : ParserRuleContext {
		public ITerminalNode AT() { return GetToken(VBAExpressionParser.AT, 0); }
		public ITerminalNode DOLLAR() { return GetToken(VBAExpressionParser.DOLLAR, 0); }
		public ITerminalNode EXCLAMATIONPOINT() { return GetToken(VBAExpressionParser.EXCLAMATIONPOINT, 0); }
		public ITerminalNode AMPERSAND() { return GetToken(VBAExpressionParser.AMPERSAND, 0); }
		public ITerminalNode PERCENT() { return GetToken(VBAExpressionParser.PERCENT, 0); }
		public ITerminalNode POW() { return GetToken(VBAExpressionParser.POW, 0); }
		public ITerminalNode HASH() { return GetToken(VBAExpressionParser.HASH, 0); }
		public TypeSuffixContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeSuffix; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterTypeSuffix(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitTypeSuffix(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeSuffix(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeSuffixContext typeSuffix() {
		TypeSuffixContext _localctx = new TypeSuffixContext(_ctx, State);
		EnterRule(_localctx, 18, RULE_typeSuffix);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 150;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << EXCLAMATIONPOINT) | (1L << HASH) | (1L << AT) | (1L << PERCENT) | (1L << DOLLAR) | (1L << AMPERSAND))) != 0) || _la==POW) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OptionCompareArgumentContext : ParserRuleContext {
		public ITerminalNode TEXT() { return GetToken(VBAExpressionParser.TEXT, 0); }
		public ITerminalNode DATABASE() { return GetToken(VBAExpressionParser.DATABASE, 0); }
		public ITerminalNode BINARY() { return GetToken(VBAExpressionParser.BINARY, 0); }
		public OptionCompareArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_optionCompareArgument; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterOptionCompareArgument(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitOptionCompareArgument(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOptionCompareArgument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OptionCompareArgumentContext optionCompareArgument() {
		OptionCompareArgumentContext _localctx = new OptionCompareArgumentContext(_ctx, State);
		EnterRule(_localctx, 20, RULE_optionCompareArgument);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 152;
			_la = _input.La(1);
			if ( !(_la==BINARY || _la==DATABASE || _la==TEXT) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BuiltInTypeContext : ParserRuleContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode OBJECT() { return GetToken(VBAExpressionParser.OBJECT, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ReservedTypeIdentifierContext reservedTypeIdentifier() {
			return GetRuleContext<ReservedTypeIdentifierContext>(0);
		}
		public ITerminalNode L_SQUARE_BRACKET() { return GetToken(VBAExpressionParser.L_SQUARE_BRACKET, 0); }
		public ITerminalNode R_SQUARE_BRACKET() { return GetToken(VBAExpressionParser.R_SQUARE_BRACKET, 0); }
		public BuiltInTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_builtInType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterBuiltInType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitBuiltInType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltInType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BuiltInTypeContext builtInType() {
		BuiltInTypeContext _localctx = new BuiltInTypeContext(_ctx, State);
		EnterRule(_localctx, 22, RULE_builtInType);
		int _la;
		try {
			State = 175;
			switch ( Interpreter.AdaptivePredict(_input,9,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 154; reservedTypeIdentifier();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 155; Match(L_SQUARE_BRACKET);
				State = 157;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 156; whiteSpace();
					}
				}

				State = 159; reservedTypeIdentifier();
				State = 161;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 160; whiteSpace();
					}
				}

				State = 163; Match(R_SQUARE_BRACKET);
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 165; Match(OBJECT);
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 166; Match(L_SQUARE_BRACKET);
				State = 168;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 167; whiteSpace();
					}
				}

				State = 170; Match(OBJECT);
				State = 172;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 171; whiteSpace();
					}
				}

				State = 174; Match(R_SQUARE_BRACKET);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
	 
		public ExpressionContext() { }
		public virtual void CopyFrom(ExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class UnaryMinusOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public ITerminalNode MINUS() { return GetToken(VBAExpressionParser.MINUS, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public UnaryMinusOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterUnaryMinusOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitUnaryMinusOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryMinusOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NewExprContext : ExpressionContext {
		public NewExpressionContext newExpression() {
			return GetRuleContext<NewExpressionContext>(0);
		}
		public NewExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterNewExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitNewExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNewExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PowOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode POW() { return GetToken(VBAExpressionParser.POW, 0); }
		public PowOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterPowOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitPowOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPowOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AddOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode PLUS() { return GetToken(VBAExpressionParser.PLUS, 0); }
		public ITerminalNode MINUS() { return GetToken(VBAExpressionParser.MINUS, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public AddOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterAddOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitAddOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAddOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TypeOfIsExprContext : ExpressionContext {
		public TypeOfIsExpressionContext typeOfIsExpression() {
			return GetRuleContext<TypeOfIsExpressionContext>(0);
		}
		public TypeOfIsExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterTypeOfIsExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitTypeOfIsExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeOfIsExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class IntDivOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode INTDIV() { return GetToken(VBAExpressionParser.INTDIV, 0); }
		public IntDivOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterIntDivOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitIntDivOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIntDivOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalImpOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode IMP() { return GetToken(VBAExpressionParser.IMP, 0); }
		public LogicalImpOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLogicalImpOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLogicalImpOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalImpOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ConcatOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode AMPERSAND() { return GetToken(VBAExpressionParser.AMPERSAND, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ConcatOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterConcatOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitConcatOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConcatOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ModOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode MOD() { return GetToken(VBAExpressionParser.MOD, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ModOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterModOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitModOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LExprContext : ExpressionContext {
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public LExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MultOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode MULT() { return GetToken(VBAExpressionParser.MULT, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode DIV() { return GetToken(VBAExpressionParser.DIV, 0); }
		public MultOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterMultOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitMultOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalXorOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode XOR() { return GetToken(VBAExpressionParser.XOR, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public LogicalXorOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLogicalXorOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLogicalXorOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalXorOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalAndOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode AND() { return GetToken(VBAExpressionParser.AND, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public LogicalAndOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLogicalAndOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLogicalAndOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalAndOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalOrOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode OR() { return GetToken(VBAExpressionParser.OR, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public LogicalOrOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLogicalOrOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLogicalOrOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalOrOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RelationalOpContext : ExpressionContext {
		public ITerminalNode GEQ() { return GetToken(VBAExpressionParser.GEQ, 0); }
		public ITerminalNode NEQ() { return GetToken(VBAExpressionParser.NEQ, 0); }
		public ITerminalNode IS() { return GetToken(VBAExpressionParser.IS, 0); }
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode LEQ() { return GetToken(VBAExpressionParser.LEQ, 0); }
		public ITerminalNode LT() { return GetToken(VBAExpressionParser.LT, 0); }
		public ITerminalNode GT() { return GetToken(VBAExpressionParser.GT, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode EQ() { return GetToken(VBAExpressionParser.EQ, 0); }
		public ITerminalNode LIKE() { return GetToken(VBAExpressionParser.LIKE, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public RelationalOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterRelationalOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitRelationalOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelationalOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalEqvOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode EQV() { return GetToken(VBAExpressionParser.EQV, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public LogicalEqvOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLogicalEqvOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLogicalEqvOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalEqvOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ParenthesizedExprContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode LPAREN() { return GetToken(VBAExpressionParser.LPAREN, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode RPAREN() { return GetToken(VBAExpressionParser.RPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ParenthesizedExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterParenthesizedExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitParenthesizedExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParenthesizedExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LiteralExprContext : ExpressionContext {
		public LiteralExpressionContext literalExpression() {
			return GetRuleContext<LiteralExpressionContext>(0);
		}
		public LiteralExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLiteralExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLiteralExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteralExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalNotOpContext : ExpressionContext {
		public ITerminalNode NOT() { return GetToken(VBAExpressionParser.NOT, 0); }
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public LogicalNotOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLogicalNotOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLogicalNotOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalNotOp(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		return expression(0);
	}

	private ExpressionContext expression(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		ExpressionContext _localctx = new ExpressionContext(_ctx, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 24;
		EnterRecursionRule(_localctx, 24, RULE_expression, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 202;
			switch (_input.La(1)) {
			case MINUS:
				{
				_localctx = new UnaryMinusOpContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;

				State = 178; Match(MINUS);
				State = 180;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 179; whiteSpace();
					}
				}

				State = 182; expression(14);
				}
				break;
			case NOT:
				{
				_localctx = new LogicalNotOpContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 183; Match(NOT);
				State = 185;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 184; whiteSpace();
					}
				}

				State = 187; expression(7);
				}
				break;
			case ABS:
			case ARRAY:
			case CBOOL:
			case CBYTE:
			case CCUR:
			case CDATE:
			case CDBL:
			case CDEC:
			case CINT:
			case CIRCLE:
			case CLNG:
			case CLNGLNG:
			case CLNGPTR:
			case CSNG:
			case CSTR:
			case CVAR:
			case CVERR:
			case DEBUG:
			case DOEVENTS:
			case FIX:
			case INPUTB:
			case INT:
			case LBOUND:
			case LEN:
			case LENB:
			case MIDB:
			case MIDBTYPESUFFIX:
			case MIDTYPESUFFIX:
			case PSET:
			case SCALE:
			case SGN:
			case UBOUND:
			case EXCLAMATIONPOINT:
			case DOT:
			case ALIAS:
			case ATTRIBUTE:
			case BEGIN:
			case BINARY:
			case CLASS:
			case DATABASE:
			case ERROR:
			case INPUT:
			case LIB:
			case ME:
			case MID:
			case ON:
			case TAB:
			case TEXT:
			case VERSION:
			case IDENTIFIER:
			case FOREIGNNAME:
			case OBJECT:
			case COLLECTION:
				{
				_localctx = new LExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 188; lExpression(0);
				}
				break;
			case LPAREN:
				{
				_localctx = new ParenthesizedExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 189; Match(LPAREN);
				State = 191;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 190; whiteSpace();
					}
				}

				State = 193; expression(0);
				State = 195;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 194; whiteSpace();
					}
				}

				State = 197; Match(RPAREN);
				}
				break;
			case TYPEOF:
				{
				_localctx = new TypeOfIsExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 199; typeOfIsExpression();
				}
				break;
			case NEW:
				{
				_localctx = new NewExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 200; newExpression();
				}
				break;
			case EMPTY:
			case FALSE:
			case NOTHING:
			case NULL:
			case TRUE:
			case STRINGLITERAL:
			case OCTLITERAL:
			case HEXLITERAL:
			case FLOATLITERAL:
			case INTEGERLITERAL:
			case DATELITERAL:
				{
				_localctx = new LiteralExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 201; literalExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			_ctx.stop = _input.Lt(-1);
			State = 314;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,40,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 312;
					switch ( Interpreter.AdaptivePredict(_input,39,_ctx) ) {
					case 1:
						{
						_localctx = new PowOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 204;
						if (!(Precpred(_ctx, 15))) throw new FailedPredicateException(this, "Precpred(_ctx, 15)");
						State = 206;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 205; whiteSpace();
							}
						}

						State = 208; Match(POW);
						State = 210;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 209; whiteSpace();
							}
						}

						State = 212; expression(16);
						}
						break;

					case 2:
						{
						_localctx = new MultOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 213;
						if (!(Precpred(_ctx, 13))) throw new FailedPredicateException(this, "Precpred(_ctx, 13)");
						State = 215;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 214; whiteSpace();
							}
						}

						State = 217;
						_la = _input.La(1);
						if ( !(_la==DIV || _la==MULT) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						State = 219;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 218; whiteSpace();
							}
						}

						State = 221; expression(14);
						}
						break;

					case 3:
						{
						_localctx = new IntDivOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 222;
						if (!(Precpred(_ctx, 12))) throw new FailedPredicateException(this, "Precpred(_ctx, 12)");
						State = 224;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 223; whiteSpace();
							}
						}

						State = 226; Match(INTDIV);
						State = 228;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 227; whiteSpace();
							}
						}

						State = 230; expression(13);
						}
						break;

					case 4:
						{
						_localctx = new ModOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 231;
						if (!(Precpred(_ctx, 11))) throw new FailedPredicateException(this, "Precpred(_ctx, 11)");
						State = 233;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 232; whiteSpace();
							}
						}

						State = 235; Match(MOD);
						State = 237;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 236; whiteSpace();
							}
						}

						State = 239; expression(12);
						}
						break;

					case 5:
						{
						_localctx = new AddOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 240;
						if (!(Precpred(_ctx, 10))) throw new FailedPredicateException(this, "Precpred(_ctx, 10)");
						State = 242;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 241; whiteSpace();
							}
						}

						State = 244;
						_la = _input.La(1);
						if ( !(_la==MINUS || _la==PLUS) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						State = 246;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 245; whiteSpace();
							}
						}

						State = 248; expression(11);
						}
						break;

					case 6:
						{
						_localctx = new ConcatOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 249;
						if (!(Precpred(_ctx, 9))) throw new FailedPredicateException(this, "Precpred(_ctx, 9)");
						State = 251;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 250; whiteSpace();
							}
						}

						State = 253; Match(AMPERSAND);
						State = 255;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 254; whiteSpace();
							}
						}

						State = 257; expression(10);
						}
						break;

					case 7:
						{
						_localctx = new RelationalOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 258;
						if (!(Precpred(_ctx, 8))) throw new FailedPredicateException(this, "Precpred(_ctx, 8)");
						State = 260;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 259; whiteSpace();
							}
						}

						State = 262;
						_la = _input.La(1);
						if ( !(_la==IS || _la==LIKE || ((((_la - 206)) & ~0x3f) == 0 && ((1L << (_la - 206)) & ((1L << (EQ - 206)) | (1L << (GEQ - 206)) | (1L << (GT - 206)) | (1L << (LEQ - 206)) | (1L << (LT - 206)) | (1L << (NEQ - 206)))) != 0)) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						State = 264;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 263; whiteSpace();
							}
						}

						State = 266; expression(9);
						}
						break;

					case 8:
						{
						_localctx = new LogicalAndOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 267;
						if (!(Precpred(_ctx, 6))) throw new FailedPredicateException(this, "Precpred(_ctx, 6)");
						State = 269;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 268; whiteSpace();
							}
						}

						State = 271; Match(AND);
						State = 273;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 272; whiteSpace();
							}
						}

						State = 275; expression(7);
						}
						break;

					case 9:
						{
						_localctx = new LogicalOrOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 276;
						if (!(Precpred(_ctx, 5))) throw new FailedPredicateException(this, "Precpred(_ctx, 5)");
						State = 278;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 277; whiteSpace();
							}
						}

						State = 280; Match(OR);
						State = 282;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 281; whiteSpace();
							}
						}

						State = 284; expression(6);
						}
						break;

					case 10:
						{
						_localctx = new LogicalXorOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 285;
						if (!(Precpred(_ctx, 4))) throw new FailedPredicateException(this, "Precpred(_ctx, 4)");
						State = 287;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 286; whiteSpace();
							}
						}

						State = 289; Match(XOR);
						State = 291;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 290; whiteSpace();
							}
						}

						State = 293; expression(5);
						}
						break;

					case 11:
						{
						_localctx = new LogicalEqvOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 294;
						if (!(Precpred(_ctx, 3))) throw new FailedPredicateException(this, "Precpred(_ctx, 3)");
						State = 296;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 295; whiteSpace();
							}
						}

						State = 298; Match(EQV);
						State = 300;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 299; whiteSpace();
							}
						}

						State = 302; expression(4);
						}
						break;

					case 12:
						{
						_localctx = new LogicalImpOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 303;
						if (!(Precpred(_ctx, 2))) throw new FailedPredicateException(this, "Precpred(_ctx, 2)");
						State = 305;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 304; whiteSpace();
							}
						}

						State = 307; Match(IMP);
						State = 309;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 308; whiteSpace();
							}
						}

						State = 311; expression(3);
						}
						break;
					}
					} 
				}
				State = 316;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,40,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class LiteralExpressionContext : ParserRuleContext {
		public ITerminalNode STRINGLITERAL() { return GetToken(VBAExpressionParser.STRINGLITERAL, 0); }
		public TypeSuffixContext typeSuffix() {
			return GetRuleContext<TypeSuffixContext>(0);
		}
		public ITerminalNode DATELITERAL() { return GetToken(VBAExpressionParser.DATELITERAL, 0); }
		public NumberLiteralContext numberLiteral() {
			return GetRuleContext<NumberLiteralContext>(0);
		}
		public LiteralIdentifierContext literalIdentifier() {
			return GetRuleContext<LiteralIdentifierContext>(0);
		}
		public LiteralExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literalExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLiteralExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLiteralExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteralExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralExpressionContext literalExpression() {
		LiteralExpressionContext _localctx = new LiteralExpressionContext(_ctx, State);
		EnterRule(_localctx, 26, RULE_literalExpression);
		try {
			State = 324;
			switch (_input.La(1)) {
			case OCTLITERAL:
			case HEXLITERAL:
			case FLOATLITERAL:
			case INTEGERLITERAL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 317; numberLiteral();
				}
				break;
			case DATELITERAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 318; Match(DATELITERAL);
				}
				break;
			case STRINGLITERAL:
				EnterOuterAlt(_localctx, 3);
				{
				State = 319; Match(STRINGLITERAL);
				}
				break;
			case EMPTY:
			case FALSE:
			case NOTHING:
			case NULL:
			case TRUE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 320; literalIdentifier();
				State = 322;
				switch ( Interpreter.AdaptivePredict(_input,41,_ctx) ) {
				case 1:
					{
					State = 321; typeSuffix();
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumberLiteralContext : ParserRuleContext {
		public ITerminalNode INTEGERLITERAL() { return GetToken(VBAExpressionParser.INTEGERLITERAL, 0); }
		public ITerminalNode FLOATLITERAL() { return GetToken(VBAExpressionParser.FLOATLITERAL, 0); }
		public ITerminalNode HEXLITERAL() { return GetToken(VBAExpressionParser.HEXLITERAL, 0); }
		public ITerminalNode OCTLITERAL() { return GetToken(VBAExpressionParser.OCTLITERAL, 0); }
		public NumberLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numberLiteral; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterNumberLiteral(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitNumberLiteral(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumberLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumberLiteralContext numberLiteral() {
		NumberLiteralContext _localctx = new NumberLiteralContext(_ctx, State);
		EnterRule(_localctx, 28, RULE_numberLiteral);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 326;
			_la = _input.La(1);
			if ( !(((((_la - 226)) & ~0x3f) == 0 && ((1L << (_la - 226)) & ((1L << (OCTLITERAL - 226)) | (1L << (HEXLITERAL - 226)) | (1L << (FLOATLITERAL - 226)) | (1L << (INTEGERLITERAL - 226)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParenthesizedExpressionContext : ParserRuleContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode LPAREN() { return GetToken(VBAExpressionParser.LPAREN, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode RPAREN() { return GetToken(VBAExpressionParser.RPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ParenthesizedExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parenthesizedExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterParenthesizedExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitParenthesizedExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParenthesizedExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParenthesizedExpressionContext parenthesizedExpression() {
		ParenthesizedExpressionContext _localctx = new ParenthesizedExpressionContext(_ctx, State);
		EnterRule(_localctx, 30, RULE_parenthesizedExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 328; Match(LPAREN);
			State = 330;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 329; whiteSpace();
				}
			}

			State = 332; expression(0);
			State = 334;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 333; whiteSpace();
				}
			}

			State = 336; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeOfIsExpressionContext : ParserRuleContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode IS() { return GetToken(VBAExpressionParser.IS, 0); }
		public ITerminalNode TYPEOF() { return GetToken(VBAExpressionParser.TYPEOF, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public TypeExpressionContext typeExpression() {
			return GetRuleContext<TypeExpressionContext>(0);
		}
		public TypeOfIsExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeOfIsExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterTypeOfIsExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitTypeOfIsExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeOfIsExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeOfIsExpressionContext typeOfIsExpression() {
		TypeOfIsExpressionContext _localctx = new TypeOfIsExpressionContext(_ctx, State);
		EnterRule(_localctx, 32, RULE_typeOfIsExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 338; Match(TYPEOF);
			State = 339; whiteSpace();
			State = 340; expression(0);
			State = 341; whiteSpace();
			State = 342; Match(IS);
			State = 343; whiteSpace();
			State = 344; typeExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NewExpressionContext : ParserRuleContext {
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public ITerminalNode NEW() { return GetToken(VBAExpressionParser.NEW, 0); }
		public TypeExpressionContext typeExpression() {
			return GetRuleContext<TypeExpressionContext>(0);
		}
		public NewExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_newExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterNewExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitNewExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNewExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NewExpressionContext newExpression() {
		NewExpressionContext _localctx = new NewExpressionContext(_ctx, State);
		EnterRule(_localctx, 34, RULE_newExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 346; Match(NEW);
			State = 347; whiteSpace();
			State = 348; typeExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LExpressionContext : ParserRuleContext {
		public LExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lExpression; } }
	 
		public LExpressionContext() { }
		public virtual void CopyFrom(LExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class IndexExprContext : LExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode LPAREN() { return GetToken(VBAExpressionParser.LPAREN, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode RPAREN() { return GetToken(VBAExpressionParser.RPAREN, 0); }
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public ArgumentListContext argumentList() {
			return GetRuleContext<ArgumentListContext>(0);
		}
		public IndexExprContext(LExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterIndexExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitIndexExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndexExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SimpleNameExprContext : LExpressionContext {
		public SimpleNameExpressionContext simpleNameExpression() {
			return GetRuleContext<SimpleNameExpressionContext>(0);
		}
		public SimpleNameExprContext(LExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterSimpleNameExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitSimpleNameExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleNameExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MemberAccessExprContext : LExpressionContext {
		public ITerminalNode DOT() { return GetToken(VBAExpressionParser.DOT, 0); }
		public ITerminalNode LINE_CONTINUATION() { return GetToken(VBAExpressionParser.LINE_CONTINUATION, 0); }
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public MemberAccessExprContext(LExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterMemberAccessExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitMemberAccessExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemberAccessExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class InstanceExprContext : LExpressionContext {
		public InstanceExpressionContext instanceExpression() {
			return GetRuleContext<InstanceExpressionContext>(0);
		}
		public InstanceExprContext(LExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterInstanceExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitInstanceExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInstanceExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class WithExprContext : LExpressionContext {
		public WithExpressionContext withExpression() {
			return GetRuleContext<WithExpressionContext>(0);
		}
		public WithExprContext(LExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterWithExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitWithExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWithExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DictionaryAccessExprContext : LExpressionContext {
		public IReadOnlyList<ITerminalNode> LINE_CONTINUATION() { return GetTokens(VBAExpressionParser.LINE_CONTINUATION); }
		public ITerminalNode EXCLAMATIONPOINT() { return GetToken(VBAExpressionParser.EXCLAMATIONPOINT, 0); }
		public ITerminalNode LINE_CONTINUATION(int i) {
			return GetToken(VBAExpressionParser.LINE_CONTINUATION, i);
		}
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public DictionaryAccessExprContext(LExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterDictionaryAccessExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitDictionaryAccessExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDictionaryAccessExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LExpressionContext lExpression() {
		return lExpression(0);
	}

	private LExpressionContext lExpression(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		LExpressionContext _localctx = new LExpressionContext(_ctx, _parentState);
		LExpressionContext _prevctx = _localctx;
		int _startState = 36;
		EnterRecursionRule(_localctx, 36, RULE_lExpression, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 354;
			switch (_input.La(1)) {
			case ME:
				{
				_localctx = new InstanceExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;

				State = 351; instanceExpression();
				}
				break;
			case ABS:
			case ARRAY:
			case CBOOL:
			case CBYTE:
			case CCUR:
			case CDATE:
			case CDBL:
			case CDEC:
			case CINT:
			case CIRCLE:
			case CLNG:
			case CLNGLNG:
			case CLNGPTR:
			case CSNG:
			case CSTR:
			case CVAR:
			case CVERR:
			case DEBUG:
			case DOEVENTS:
			case FIX:
			case INPUTB:
			case INT:
			case LBOUND:
			case LEN:
			case LENB:
			case MIDB:
			case MIDBTYPESUFFIX:
			case MIDTYPESUFFIX:
			case PSET:
			case SCALE:
			case SGN:
			case UBOUND:
			case ALIAS:
			case ATTRIBUTE:
			case BEGIN:
			case BINARY:
			case CLASS:
			case DATABASE:
			case ERROR:
			case INPUT:
			case LIB:
			case MID:
			case ON:
			case TAB:
			case TEXT:
			case VERSION:
			case IDENTIFIER:
			case FOREIGNNAME:
			case OBJECT:
			case COLLECTION:
				{
				_localctx = new SimpleNameExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 352; simpleNameExpression();
				}
				break;
			case EXCLAMATIONPOINT:
			case DOT:
				{
				_localctx = new WithExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 353; withExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			_ctx.stop = _input.Lt(-1);
			State = 395;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,52,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 393;
					switch ( Interpreter.AdaptivePredict(_input,51,_ctx) ) {
					case 1:
						{
						_localctx = new IndexExprContext(new LExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_lExpression);
						State = 356;
						if (!(Precpred(_ctx, 9))) throw new FailedPredicateException(this, "Precpred(_ctx, 9)");
						State = 358;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 357; whiteSpace();
							}
						}

						State = 360; Match(LPAREN);
						State = 362;
						switch ( Interpreter.AdaptivePredict(_input,47,_ctx) ) {
						case 1:
							{
							State = 361; whiteSpace();
							}
							break;
						}
						State = 365;
						switch ( Interpreter.AdaptivePredict(_input,48,_ctx) ) {
						case 1:
							{
							State = 364; argumentList();
							}
							break;
						}
						State = 368;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 367; whiteSpace();
							}
						}

						State = 370; Match(RPAREN);
						}
						break;

					case 2:
						{
						_localctx = new MemberAccessExprContext(new LExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_lExpression);
						State = 371;
						if (!(Precpred(_ctx, 8))) throw new FailedPredicateException(this, "Precpred(_ctx, 8)");
						State = 372; Match(DOT);
						State = 373; unrestrictedName();
						}
						break;

					case 3:
						{
						_localctx = new MemberAccessExprContext(new LExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_lExpression);
						State = 374;
						if (!(Precpred(_ctx, 7))) throw new FailedPredicateException(this, "Precpred(_ctx, 7)");
						State = 375; Match(LINE_CONTINUATION);
						State = 377;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 376; whiteSpace();
							}
						}

						State = 379; Match(DOT);
						State = 380; unrestrictedName();
						}
						break;

					case 4:
						{
						_localctx = new DictionaryAccessExprContext(new LExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_lExpression);
						State = 381;
						if (!(Precpred(_ctx, 6))) throw new FailedPredicateException(this, "Precpred(_ctx, 6)");
						State = 382; Match(EXCLAMATIONPOINT);
						State = 383; unrestrictedName();
						}
						break;

					case 5:
						{
						_localctx = new DictionaryAccessExprContext(new LExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_lExpression);
						State = 384;
						if (!(Precpred(_ctx, 5))) throw new FailedPredicateException(this, "Precpred(_ctx, 5)");
						State = 385; Match(LINE_CONTINUATION);
						State = 386; Match(EXCLAMATIONPOINT);
						State = 387; unrestrictedName();
						}
						break;

					case 6:
						{
						_localctx = new DictionaryAccessExprContext(new LExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_lExpression);
						State = 388;
						if (!(Precpred(_ctx, 4))) throw new FailedPredicateException(this, "Precpred(_ctx, 4)");
						State = 389; Match(LINE_CONTINUATION);
						State = 390; Match(EXCLAMATIONPOINT);
						State = 391; Match(LINE_CONTINUATION);
						State = 392; unrestrictedName();
						}
						break;
					}
					} 
				}
				State = 397;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,52,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class MemberAccessExpressionContext : ParserRuleContext {
		public ITerminalNode DOT() { return GetToken(VBAExpressionParser.DOT, 0); }
		public ITerminalNode LINE_CONTINUATION() { return GetToken(VBAExpressionParser.LINE_CONTINUATION, 0); }
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public MemberAccessExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_memberAccessExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterMemberAccessExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitMemberAccessExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemberAccessExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MemberAccessExpressionContext memberAccessExpression() {
		MemberAccessExpressionContext _localctx = new MemberAccessExpressionContext(_ctx, State);
		EnterRule(_localctx, 38, RULE_memberAccessExpression);
		int _la;
		try {
			State = 410;
			switch ( Interpreter.AdaptivePredict(_input,54,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 398; lExpression(0);
				State = 399; Match(DOT);
				State = 400; unrestrictedName();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 402; lExpression(0);
				State = 403; Match(LINE_CONTINUATION);
				State = 405;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 404; whiteSpace();
					}
				}

				State = 407; Match(DOT);
				State = 408; unrestrictedName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexExpressionContext : ParserRuleContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode LPAREN() { return GetToken(VBAExpressionParser.LPAREN, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode RPAREN() { return GetToken(VBAExpressionParser.RPAREN, 0); }
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public ArgumentListContext argumentList() {
			return GetRuleContext<ArgumentListContext>(0);
		}
		public IndexExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterIndexExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitIndexExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndexExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IndexExpressionContext indexExpression() {
		IndexExpressionContext _localctx = new IndexExpressionContext(_ctx, State);
		EnterRule(_localctx, 40, RULE_indexExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 412; lExpression(0);
			State = 414;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 413; whiteSpace();
				}
			}

			State = 416; Match(LPAREN);
			State = 418;
			switch ( Interpreter.AdaptivePredict(_input,56,_ctx) ) {
			case 1:
				{
				State = 417; whiteSpace();
				}
				break;
			}
			State = 421;
			switch ( Interpreter.AdaptivePredict(_input,57,_ctx) ) {
			case 1:
				{
				State = 420; argumentList();
				}
				break;
			}
			State = 424;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 423; whiteSpace();
				}
			}

			State = 426; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DictionaryAccessExpressionContext : ParserRuleContext {
		public IReadOnlyList<ITerminalNode> LINE_CONTINUATION() { return GetTokens(VBAExpressionParser.LINE_CONTINUATION); }
		public ITerminalNode EXCLAMATIONPOINT() { return GetToken(VBAExpressionParser.EXCLAMATIONPOINT, 0); }
		public ITerminalNode LINE_CONTINUATION(int i) {
			return GetToken(VBAExpressionParser.LINE_CONTINUATION, i);
		}
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public DictionaryAccessExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dictionaryAccessExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterDictionaryAccessExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitDictionaryAccessExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDictionaryAccessExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DictionaryAccessExpressionContext dictionaryAccessExpression() {
		DictionaryAccessExpressionContext _localctx = new DictionaryAccessExpressionContext(_ctx, State);
		EnterRule(_localctx, 42, RULE_dictionaryAccessExpression);
		try {
			State = 443;
			switch ( Interpreter.AdaptivePredict(_input,59,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 428; lExpression(0);
				State = 429; Match(EXCLAMATIONPOINT);
				State = 430; unrestrictedName();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 432; lExpression(0);
				State = 433; Match(LINE_CONTINUATION);
				State = 434; Match(EXCLAMATIONPOINT);
				State = 435; unrestrictedName();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 437; lExpression(0);
				State = 438; Match(LINE_CONTINUATION);
				State = 439; Match(EXCLAMATIONPOINT);
				State = 440; Match(LINE_CONTINUATION);
				State = 441; unrestrictedName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentListContext : ParserRuleContext {
		public PositionalOrNamedArgumentListContext positionalOrNamedArgumentList() {
			return GetRuleContext<PositionalOrNamedArgumentListContext>(0);
		}
		public ArgumentListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argumentList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterArgumentList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitArgumentList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgumentList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentListContext argumentList() {
		ArgumentListContext _localctx = new ArgumentListContext(_ctx, State);
		EnterRule(_localctx, 44, RULE_argumentList);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 445; positionalOrNamedArgumentList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PositionalOrNamedArgumentListContext : ParserRuleContext {
		public RequiredPositionalArgumentContext requiredPositionalArgument() {
			return GetRuleContext<RequiredPositionalArgumentContext>(0);
		}
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public IReadOnlyList<ITerminalNode> COMMA() { return GetTokens(VBAExpressionParser.COMMA); }
		public IReadOnlyList<PositionalArgumentContext> positionalArgument() {
			return GetRuleContexts<PositionalArgumentContext>();
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public NamedArgumentListContext namedArgumentList() {
			return GetRuleContext<NamedArgumentListContext>(0);
		}
		public ITerminalNode COMMA(int i) {
			return GetToken(VBAExpressionParser.COMMA, i);
		}
		public PositionalArgumentContext positionalArgument(int i) {
			return GetRuleContext<PositionalArgumentContext>(i);
		}
		public PositionalOrNamedArgumentListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_positionalOrNamedArgumentList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterPositionalOrNamedArgumentList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitPositionalOrNamedArgumentList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPositionalOrNamedArgumentList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PositionalOrNamedArgumentListContext positionalOrNamedArgumentList() {
		PositionalOrNamedArgumentListContext _localctx = new PositionalOrNamedArgumentListContext(_ctx, State);
		EnterRule(_localctx, 46, RULE_positionalOrNamedArgumentList);
		int _la;
		try {
			int _alt;
			State = 479;
			switch ( Interpreter.AdaptivePredict(_input,68,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 459;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,63,_ctx);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 448;
						_la = _input.La(1);
						if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ABS) | (1L << ARRAY) | (1L << CBOOL) | (1L << CBYTE) | (1L << CCUR) | (1L << CDATE) | (1L << CDBL) | (1L << CDEC) | (1L << CINT) | (1L << CIRCLE) | (1L << CLNG) | (1L << CLNGLNG) | (1L << CLNGPTR) | (1L << CSNG) | (1L << CSTR) | (1L << CVAR) | (1L << CVERR) | (1L << DEBUG) | (1L << DOEVENTS) | (1L << FIX) | (1L << INPUTB) | (1L << INT) | (1L << LBOUND) | (1L << LEN) | (1L << LENB) | (1L << MIDB) | (1L << MIDBTYPESUFFIX) | (1L << MIDTYPESUFFIX) | (1L << PSET) | (1L << SCALE) | (1L << SGN) | (1L << UBOUND) | (1L << EXCLAMATIONPOINT) | (1L << DOT) | (1L << ADDRESSOF) | (1L << ALIAS) | (1L << ATTRIBUTE) | (1L << BEGIN) | (1L << BINARY) | (1L << BYVAL))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CLASS - 64)) | (1L << (DATABASE - 64)) | (1L << (EMPTY - 64)) | (1L << (ERROR - 64)) | (1L << (FALSE - 64)) | (1L << (INPUT - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (LIB - 128)) | (1L << (ME - 128)) | (1L << (MID - 128)) | (1L << (NEW - 128)) | (1L << (NOT - 128)) | (1L << (NOTHING - 128)) | (1L << (NULL - 128)) | (1L << (ON - 128)) | (1L << (TAB - 128)) | (1L << (TEXT - 128)) | (1L << (TRUE - 128)) | (1L << (TYPEOF - 128)))) != 0) || ((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (VERSION - 195)) | (1L << (LPAREN - 195)) | (1L << (MINUS - 195)) | (1L << (STRINGLITERAL - 195)) | (1L << (OCTLITERAL - 195)) | (1L << (HEXLITERAL - 195)) | (1L << (FLOATLITERAL - 195)) | (1L << (INTEGERLITERAL - 195)) | (1L << (DATELITERAL - 195)) | (1L << (IDENTIFIER - 195)) | (1L << (FOREIGNNAME - 195)) | (1L << (OBJECT - 195)) | (1L << (COLLECTION - 195)))) != 0)) {
							{
							State = 447; positionalArgument();
							}
						}

						State = 451;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 450; whiteSpace();
							}
						}

						State = 453; Match(COMMA);
						State = 455;
						switch ( Interpreter.AdaptivePredict(_input,62,_ctx) ) {
						case 1:
							{
							State = 454; whiteSpace();
							}
							break;
						}
						}
						} 
					}
					State = 461;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,63,_ctx);
				}
				State = 462; requiredPositionalArgument();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 475;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,67,_ctx);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 464;
						_la = _input.La(1);
						if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ABS) | (1L << ARRAY) | (1L << CBOOL) | (1L << CBYTE) | (1L << CCUR) | (1L << CDATE) | (1L << CDBL) | (1L << CDEC) | (1L << CINT) | (1L << CIRCLE) | (1L << CLNG) | (1L << CLNGLNG) | (1L << CLNGPTR) | (1L << CSNG) | (1L << CSTR) | (1L << CVAR) | (1L << CVERR) | (1L << DEBUG) | (1L << DOEVENTS) | (1L << FIX) | (1L << INPUTB) | (1L << INT) | (1L << LBOUND) | (1L << LEN) | (1L << LENB) | (1L << MIDB) | (1L << MIDBTYPESUFFIX) | (1L << MIDTYPESUFFIX) | (1L << PSET) | (1L << SCALE) | (1L << SGN) | (1L << UBOUND) | (1L << EXCLAMATIONPOINT) | (1L << DOT) | (1L << ADDRESSOF) | (1L << ALIAS) | (1L << ATTRIBUTE) | (1L << BEGIN) | (1L << BINARY) | (1L << BYVAL))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CLASS - 64)) | (1L << (DATABASE - 64)) | (1L << (EMPTY - 64)) | (1L << (ERROR - 64)) | (1L << (FALSE - 64)) | (1L << (INPUT - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (LIB - 128)) | (1L << (ME - 128)) | (1L << (MID - 128)) | (1L << (NEW - 128)) | (1L << (NOT - 128)) | (1L << (NOTHING - 128)) | (1L << (NULL - 128)) | (1L << (ON - 128)) | (1L << (TAB - 128)) | (1L << (TEXT - 128)) | (1L << (TRUE - 128)) | (1L << (TYPEOF - 128)))) != 0) || ((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (VERSION - 195)) | (1L << (LPAREN - 195)) | (1L << (MINUS - 195)) | (1L << (STRINGLITERAL - 195)) | (1L << (OCTLITERAL - 195)) | (1L << (HEXLITERAL - 195)) | (1L << (FLOATLITERAL - 195)) | (1L << (INTEGERLITERAL - 195)) | (1L << (DATELITERAL - 195)) | (1L << (IDENTIFIER - 195)) | (1L << (FOREIGNNAME - 195)) | (1L << (OBJECT - 195)) | (1L << (COLLECTION - 195)))) != 0)) {
							{
							State = 463; positionalArgument();
							}
						}

						State = 467;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 466; whiteSpace();
							}
						}

						State = 469; Match(COMMA);
						State = 471;
						switch ( Interpreter.AdaptivePredict(_input,66,_ctx) ) {
						case 1:
							{
							State = 470; whiteSpace();
							}
							break;
						}
						}
						} 
					}
					State = 477;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,67,_ctx);
				}
				State = 478; namedArgumentList();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PositionalArgumentContext : ParserRuleContext {
		public ArgumentExpressionContext argumentExpression() {
			return GetRuleContext<ArgumentExpressionContext>(0);
		}
		public PositionalArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_positionalArgument; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterPositionalArgument(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitPositionalArgument(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPositionalArgument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PositionalArgumentContext positionalArgument() {
		PositionalArgumentContext _localctx = new PositionalArgumentContext(_ctx, State);
		EnterRule(_localctx, 48, RULE_positionalArgument);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 481; argumentExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RequiredPositionalArgumentContext : ParserRuleContext {
		public ArgumentExpressionContext argumentExpression() {
			return GetRuleContext<ArgumentExpressionContext>(0);
		}
		public RequiredPositionalArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_requiredPositionalArgument; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterRequiredPositionalArgument(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitRequiredPositionalArgument(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRequiredPositionalArgument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RequiredPositionalArgumentContext requiredPositionalArgument() {
		RequiredPositionalArgumentContext _localctx = new RequiredPositionalArgumentContext(_ctx, State);
		EnterRule(_localctx, 50, RULE_requiredPositionalArgument);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 483; argumentExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NamedArgumentListContext : ParserRuleContext {
		public IReadOnlyList<NamedArgumentContext> namedArgument() {
			return GetRuleContexts<NamedArgumentContext>();
		}
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public IReadOnlyList<ITerminalNode> COMMA() { return GetTokens(VBAExpressionParser.COMMA); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public NamedArgumentContext namedArgument(int i) {
			return GetRuleContext<NamedArgumentContext>(i);
		}
		public ITerminalNode COMMA(int i) {
			return GetToken(VBAExpressionParser.COMMA, i);
		}
		public NamedArgumentListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_namedArgumentList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterNamedArgumentList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitNamedArgumentList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNamedArgumentList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NamedArgumentListContext namedArgumentList() {
		NamedArgumentListContext _localctx = new NamedArgumentListContext(_ctx, State);
		EnterRule(_localctx, 52, RULE_namedArgumentList);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 485; namedArgument();
			State = 496;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,71,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 487;
					_la = _input.La(1);
					if (_la==WS || _la==LINE_CONTINUATION) {
						{
						State = 486; whiteSpace();
						}
					}

					State = 489; Match(COMMA);
					State = 491;
					_la = _input.La(1);
					if (_la==WS || _la==LINE_CONTINUATION) {
						{
						State = 490; whiteSpace();
						}
					}

					State = 493; namedArgument();
					}
					} 
				}
				State = 498;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,71,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NamedArgumentContext : ParserRuleContext {
		public ITerminalNode ASSIGN() { return GetToken(VBAExpressionParser.ASSIGN, 0); }
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ArgumentExpressionContext argumentExpression() {
			return GetRuleContext<ArgumentExpressionContext>(0);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public NamedArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_namedArgument; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterNamedArgument(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitNamedArgument(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNamedArgument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NamedArgumentContext namedArgument() {
		NamedArgumentContext _localctx = new NamedArgumentContext(_ctx, State);
		EnterRule(_localctx, 54, RULE_namedArgument);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 499; unrestrictedName();
			State = 501;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 500; whiteSpace();
				}
			}

			State = 503; Match(ASSIGN);
			State = 505;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 504; whiteSpace();
				}
			}

			State = 507; argumentExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentExpressionContext : ParserRuleContext {
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public AddressOfExpressionContext addressOfExpression() {
			return GetRuleContext<AddressOfExpressionContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode BYVAL() { return GetToken(VBAExpressionParser.BYVAL, 0); }
		public ArgumentExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argumentExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterArgumentExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitArgumentExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgumentExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentExpressionContext argumentExpression() {
		ArgumentExpressionContext _localctx = new ArgumentExpressionContext(_ctx, State);
		EnterRule(_localctx, 56, RULE_argumentExpression);
		int _la;
		try {
			State = 515;
			switch (_input.La(1)) {
			case ABS:
			case ARRAY:
			case CBOOL:
			case CBYTE:
			case CCUR:
			case CDATE:
			case CDBL:
			case CDEC:
			case CINT:
			case CIRCLE:
			case CLNG:
			case CLNGLNG:
			case CLNGPTR:
			case CSNG:
			case CSTR:
			case CVAR:
			case CVERR:
			case DEBUG:
			case DOEVENTS:
			case FIX:
			case INPUTB:
			case INT:
			case LBOUND:
			case LEN:
			case LENB:
			case MIDB:
			case MIDBTYPESUFFIX:
			case MIDTYPESUFFIX:
			case PSET:
			case SCALE:
			case SGN:
			case UBOUND:
			case EXCLAMATIONPOINT:
			case DOT:
			case ALIAS:
			case ATTRIBUTE:
			case BEGIN:
			case BINARY:
			case BYVAL:
			case CLASS:
			case DATABASE:
			case EMPTY:
			case ERROR:
			case FALSE:
			case INPUT:
			case LIB:
			case ME:
			case MID:
			case NEW:
			case NOT:
			case NOTHING:
			case NULL:
			case ON:
			case TAB:
			case TEXT:
			case TRUE:
			case TYPEOF:
			case VERSION:
			case LPAREN:
			case MINUS:
			case STRINGLITERAL:
			case OCTLITERAL:
			case HEXLITERAL:
			case FLOATLITERAL:
			case INTEGERLITERAL:
			case DATELITERAL:
			case IDENTIFIER:
			case FOREIGNNAME:
			case OBJECT:
			case COLLECTION:
				EnterOuterAlt(_localctx, 1);
				{
				State = 511;
				_la = _input.La(1);
				if (_la==BYVAL) {
					{
					State = 509; Match(BYVAL);
					State = 510; whiteSpace();
					}
				}

				State = 513; expression(0);
				}
				break;
			case ADDRESSOF:
				EnterOuterAlt(_localctx, 2);
				{
				State = 514; addressOfExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleNameExpressionContext : ParserRuleContext {
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public SimpleNameExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleNameExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterSimpleNameExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitSimpleNameExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleNameExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SimpleNameExpressionContext simpleNameExpression() {
		SimpleNameExpressionContext _localctx = new SimpleNameExpressionContext(_ctx, State);
		EnterRule(_localctx, 58, RULE_simpleNameExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 517; name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InstanceExpressionContext : ParserRuleContext {
		public ITerminalNode ME() { return GetToken(VBAExpressionParser.ME, 0); }
		public InstanceExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_instanceExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterInstanceExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitInstanceExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInstanceExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InstanceExpressionContext instanceExpression() {
		InstanceExpressionContext _localctx = new InstanceExpressionContext(_ctx, State);
		EnterRule(_localctx, 60, RULE_instanceExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 519; Match(ME);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithExpressionContext : ParserRuleContext {
		public WithDictionaryAccessExpressionContext withDictionaryAccessExpression() {
			return GetRuleContext<WithDictionaryAccessExpressionContext>(0);
		}
		public WithMemberAccessExpressionContext withMemberAccessExpression() {
			return GetRuleContext<WithMemberAccessExpressionContext>(0);
		}
		public WithExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterWithExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitWithExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWithExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WithExpressionContext withExpression() {
		WithExpressionContext _localctx = new WithExpressionContext(_ctx, State);
		EnterRule(_localctx, 62, RULE_withExpression);
		try {
			State = 523;
			switch (_input.La(1)) {
			case DOT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 521; withMemberAccessExpression();
				}
				break;
			case EXCLAMATIONPOINT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 522; withDictionaryAccessExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithMemberAccessExpressionContext : ParserRuleContext {
		public ITerminalNode DOT() { return GetToken(VBAExpressionParser.DOT, 0); }
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public WithMemberAccessExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withMemberAccessExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterWithMemberAccessExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitWithMemberAccessExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWithMemberAccessExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WithMemberAccessExpressionContext withMemberAccessExpression() {
		WithMemberAccessExpressionContext _localctx = new WithMemberAccessExpressionContext(_ctx, State);
		EnterRule(_localctx, 64, RULE_withMemberAccessExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 525; Match(DOT);
			State = 526; unrestrictedName();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithDictionaryAccessExpressionContext : ParserRuleContext {
		public ITerminalNode EXCLAMATIONPOINT() { return GetToken(VBAExpressionParser.EXCLAMATIONPOINT, 0); }
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public WithDictionaryAccessExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withDictionaryAccessExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterWithDictionaryAccessExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitWithDictionaryAccessExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWithDictionaryAccessExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WithDictionaryAccessExpressionContext withDictionaryAccessExpression() {
		WithDictionaryAccessExpressionContext _localctx = new WithDictionaryAccessExpressionContext(_ctx, State);
		EnterRule(_localctx, 66, RULE_withDictionaryAccessExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 528; Match(EXCLAMATIONPOINT);
			State = 529; unrestrictedName();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstantExpressionContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ConstantExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constantExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterConstantExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitConstantExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstantExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstantExpressionContext constantExpression() {
		ConstantExpressionContext _localctx = new ConstantExpressionContext(_ctx, State);
		EnterRule(_localctx, 68, RULE_constantExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 531; expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeExpressionContext : ParserRuleContext {
		public DefinedTypeExpressionContext definedTypeExpression() {
			return GetRuleContext<DefinedTypeExpressionContext>(0);
		}
		public BuiltInTypeContext builtInType() {
			return GetRuleContext<BuiltInTypeContext>(0);
		}
		public TypeExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterTypeExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitTypeExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeExpressionContext typeExpression() {
		TypeExpressionContext _localctx = new TypeExpressionContext(_ctx, State);
		EnterRule(_localctx, 70, RULE_typeExpression);
		try {
			State = 535;
			switch ( Interpreter.AdaptivePredict(_input,77,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 533; builtInType();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 534; definedTypeExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DefinedTypeExpressionContext : ParserRuleContext {
		public MemberAccessExpressionContext memberAccessExpression() {
			return GetRuleContext<MemberAccessExpressionContext>(0);
		}
		public SimpleNameExpressionContext simpleNameExpression() {
			return GetRuleContext<SimpleNameExpressionContext>(0);
		}
		public DefinedTypeExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_definedTypeExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterDefinedTypeExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitDefinedTypeExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDefinedTypeExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DefinedTypeExpressionContext definedTypeExpression() {
		DefinedTypeExpressionContext _localctx = new DefinedTypeExpressionContext(_ctx, State);
		EnterRule(_localctx, 72, RULE_definedTypeExpression);
		try {
			State = 539;
			switch ( Interpreter.AdaptivePredict(_input,78,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 537; simpleNameExpression();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 538; memberAccessExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AddressOfExpressionContext : ParserRuleContext {
		public ITerminalNode ADDRESSOF() { return GetToken(VBAExpressionParser.ADDRESSOF, 0); }
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public ProcedurePointerExpressionContext procedurePointerExpression() {
			return GetRuleContext<ProcedurePointerExpressionContext>(0);
		}
		public AddressOfExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_addressOfExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterAddressOfExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitAddressOfExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAddressOfExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AddressOfExpressionContext addressOfExpression() {
		AddressOfExpressionContext _localctx = new AddressOfExpressionContext(_ctx, State);
		EnterRule(_localctx, 74, RULE_addressOfExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 541; Match(ADDRESSOF);
			State = 542; whiteSpace();
			State = 543; procedurePointerExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProcedurePointerExpressionContext : ParserRuleContext {
		public MemberAccessExpressionContext memberAccessExpression() {
			return GetRuleContext<MemberAccessExpressionContext>(0);
		}
		public SimpleNameExpressionContext simpleNameExpression() {
			return GetRuleContext<SimpleNameExpressionContext>(0);
		}
		public ProcedurePointerExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedurePointerExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterProcedurePointerExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitProcedurePointerExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProcedurePointerExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProcedurePointerExpressionContext procedurePointerExpression() {
		ProcedurePointerExpressionContext _localctx = new ProcedurePointerExpressionContext(_ctx, State);
		EnterRule(_localctx, 76, RULE_procedurePointerExpression);
		try {
			State = 547;
			switch ( Interpreter.AdaptivePredict(_input,79,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 545; memberAccessExpression();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 546; simpleNameExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedIdentifierContext : ParserRuleContext {
		public MarkerKeywordContext markerKeyword() {
			return GetRuleContext<MarkerKeywordContext>(0);
		}
		public SpecialFormContext specialForm() {
			return GetRuleContext<SpecialFormContext>(0);
		}
		public ReservedTypeIdentifierContext reservedTypeIdentifier() {
			return GetRuleContext<ReservedTypeIdentifierContext>(0);
		}
		public OperatorIdentifierContext operatorIdentifier() {
			return GetRuleContext<OperatorIdentifierContext>(0);
		}
		public RemKeywordContext remKeyword() {
			return GetRuleContext<RemKeywordContext>(0);
		}
		public ReservedNameContext reservedName() {
			return GetRuleContext<ReservedNameContext>(0);
		}
		public StatementKeywordContext statementKeyword() {
			return GetRuleContext<StatementKeywordContext>(0);
		}
		public LiteralIdentifierContext literalIdentifier() {
			return GetRuleContext<LiteralIdentifierContext>(0);
		}
		public ReservedIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedIdentifierContext reservedIdentifier() {
		ReservedIdentifierContext _localctx = new ReservedIdentifierContext(_ctx, State);
		EnterRule(_localctx, 78, RULE_reservedIdentifier);
		try {
			State = 557;
			switch ( Interpreter.AdaptivePredict(_input,80,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 549; statementKeyword();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 550; markerKeyword();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 551; operatorIdentifier();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 552; specialForm();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 553; reservedName();
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 554; literalIdentifier();
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 555; remKeyword();
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 556; reservedTypeIdentifier();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementKeywordContext : ParserRuleContext {
		public ITerminalNode CASE() { return GetToken(VBAExpressionParser.CASE, 0); }
		public ITerminalNode DEFOBJ() { return GetToken(VBAExpressionParser.DEFOBJ, 0); }
		public ITerminalNode ELSE() { return GetToken(VBAExpressionParser.ELSE, 0); }
		public ITerminalNode LOCK_WRITE() { return GetToken(VBAExpressionParser.LOCK_WRITE, 0); }
		public ITerminalNode IF() { return GetToken(VBAExpressionParser.IF, 0); }
		public ITerminalNode RESET() { return GetToken(VBAExpressionParser.RESET, 0); }
		public ITerminalNode ERASE() { return GetToken(VBAExpressionParser.ERASE, 0); }
		public ITerminalNode WRITE(int i) {
			return GetToken(VBAExpressionParser.WRITE, i);
		}
		public ITerminalNode END_SELECT() { return GetToken(VBAExpressionParser.END_SELECT, 0); }
		public ITerminalNode ON_ERROR() { return GetToken(VBAExpressionParser.ON_ERROR, 0); }
		public ITerminalNode END_IF() { return GetToken(VBAExpressionParser.END_IF, 0); }
		public ITerminalNode RAISEEVENT() { return GetToken(VBAExpressionParser.RAISEEVENT, 0); }
		public ITerminalNode STOP() { return GetToken(VBAExpressionParser.STOP, 0); }
		public ITerminalNode SHARED() { return GetToken(VBAExpressionParser.SHARED, 0); }
		public ITerminalNode APPEND() { return GetToken(VBAExpressionParser.APPEND, 0); }
		public ITerminalNode PRIVATE() { return GetToken(VBAExpressionParser.PRIVATE, 0); }
		public ITerminalNode DEFBYTE() { return GetToken(VBAExpressionParser.DEFBYTE, 0); }
		public ITerminalNode DEFSNG() { return GetToken(VBAExpressionParser.DEFSNG, 0); }
		public ITerminalNode GOSUB() { return GetToken(VBAExpressionParser.GOSUB, 0); }
		public ITerminalNode RETURN() { return GetToken(VBAExpressionParser.RETURN, 0); }
		public ITerminalNode ENUM() { return GetToken(VBAExpressionParser.ENUM, 0); }
		public ITerminalNode LOCK() { return GetToken(VBAExpressionParser.LOCK, 0); }
		public ITerminalNode GLOBAL() { return GetToken(VBAExpressionParser.GLOBAL, 0); }
		public ITerminalNode WEND() { return GetToken(VBAExpressionParser.WEND, 0); }
		public ITerminalNode DEFSTR() { return GetToken(VBAExpressionParser.DEFSTR, 0); }
		public ITerminalNode DEFLNGLNG() { return GetToken(VBAExpressionParser.DEFLNGLNG, 0); }
		public ITerminalNode DEFVAR() { return GetToken(VBAExpressionParser.DEFVAR, 0); }
		public ITerminalNode EXIT_DO() { return GetToken(VBAExpressionParser.EXIT_DO, 0); }
		public ITerminalNode EVENT() { return GetToken(VBAExpressionParser.EVENT, 0); }
		public ITerminalNode CONST() { return GetToken(VBAExpressionParser.CONST, 0); }
		public ITerminalNode ELSEIF() { return GetToken(VBAExpressionParser.ELSEIF, 0); }
		public ITerminalNode PRINT() { return GetToken(VBAExpressionParser.PRINT, 0); }
		public ITerminalNode DEFINT() { return GetToken(VBAExpressionParser.DEFINT, 0); }
		public ITerminalNode SUB() { return GetToken(VBAExpressionParser.SUB, 0); }
		public ITerminalNode FOR() { return GetToken(VBAExpressionParser.FOR, 0); }
		public ITerminalNode LSET() { return GetToken(VBAExpressionParser.LSET, 0); }
		public ITerminalNode WIDTH() { return GetToken(VBAExpressionParser.WIDTH, 0); }
		public ITerminalNode INPUT() { return GetToken(VBAExpressionParser.INPUT, 0); }
		public ITerminalNode STEP() { return GetToken(VBAExpressionParser.STEP, 0); }
		public ITerminalNode SEEK() { return GetToken(VBAExpressionParser.SEEK, 0); }
		public ITerminalNode BINARY() { return GetToken(VBAExpressionParser.BINARY, 0); }
		public ITerminalNode RANDOM() { return GetToken(VBAExpressionParser.RANDOM, 0); }
		public ITerminalNode LOOP() { return GetToken(VBAExpressionParser.LOOP, 0); }
		public ITerminalNode DEFCUR() { return GetToken(VBAExpressionParser.DEFCUR, 0); }
		public ITerminalNode PUBLIC() { return GetToken(VBAExpressionParser.PUBLIC, 0); }
		public ITerminalNode DEFDATE() { return GetToken(VBAExpressionParser.DEFDATE, 0); }
		public ITerminalNode PUT() { return GetToken(VBAExpressionParser.PUT, 0); }
		public ITerminalNode LET() { return GetToken(VBAExpressionParser.LET, 0); }
		public ITerminalNode FRIEND() { return GetToken(VBAExpressionParser.FRIEND, 0); }
		public ITerminalNode TYPE() { return GetToken(VBAExpressionParser.TYPE, 0); }
		public ITerminalNode ERROR() { return GetToken(VBAExpressionParser.ERROR, 0); }
		public ITerminalNode CALL() { return GetToken(VBAExpressionParser.CALL, 0); }
		public ITerminalNode READ() { return GetToken(VBAExpressionParser.READ, 0); }
		public ITerminalNode DEFBOOL() { return GetToken(VBAExpressionParser.DEFBOOL, 0); }
		public ITerminalNode OPEN() { return GetToken(VBAExpressionParser.OPEN, 0); }
		public ITerminalNode STATIC() { return GetToken(VBAExpressionParser.STATIC, 0); }
		public ITerminalNode LOCK_READ() { return GetToken(VBAExpressionParser.LOCK_READ, 0); }
		public ITerminalNode DO() { return GetToken(VBAExpressionParser.DO, 0); }
		public ITerminalNode DIM() { return GetToken(VBAExpressionParser.DIM, 0); }
		public ITerminalNode OPTION() { return GetToken(VBAExpressionParser.OPTION, 0); }
		public ITerminalNode CLOSE() { return GetToken(VBAExpressionParser.CLOSE, 0); }
		public ITerminalNode OUTPUT() { return GetToken(VBAExpressionParser.OUTPUT, 0); }
		public ITerminalNode LINE_INPUT() { return GetToken(VBAExpressionParser.LINE_INPUT, 0); }
		public ITerminalNode DEFLNG() { return GetToken(VBAExpressionParser.DEFLNG, 0); }
		public ITerminalNode IMPLEMENTS() { return GetToken(VBAExpressionParser.IMPLEMENTS, 0); }
		public ITerminalNode ON() { return GetToken(VBAExpressionParser.ON, 0); }
		public ITerminalNode WITH() { return GetToken(VBAExpressionParser.WITH, 0); }
		public ITerminalNode ACCESS() { return GetToken(VBAExpressionParser.ACCESS, 0); }
		public ITerminalNode EXIT_SUB() { return GetToken(VBAExpressionParser.EXIT_SUB, 0); }
		public ITerminalNode DECLARE() { return GetToken(VBAExpressionParser.DECLARE, 0); }
		public ITerminalNode LOCK_READ_WRITE() { return GetToken(VBAExpressionParser.LOCK_READ_WRITE, 0); }
		public ITerminalNode RESUME() { return GetToken(VBAExpressionParser.RESUME, 0); }
		public IReadOnlyList<ITerminalNode> WRITE() { return GetTokens(VBAExpressionParser.WRITE); }
		public ITerminalNode DEFLNGPTR() { return GetToken(VBAExpressionParser.DEFLNGPTR, 0); }
		public ITerminalNode WHILE() { return GetToken(VBAExpressionParser.WHILE, 0); }
		public ITerminalNode EXIT() { return GetToken(VBAExpressionParser.EXIT, 0); }
		public ITerminalNode GET() { return GetToken(VBAExpressionParser.GET, 0); }
		public ITerminalNode EXIT_FOR() { return GetToken(VBAExpressionParser.EXIT_FOR, 0); }
		public ITerminalNode DEFDBL() { return GetToken(VBAExpressionParser.DEFDBL, 0); }
		public ITerminalNode NEXT() { return GetToken(VBAExpressionParser.NEXT, 0); }
		public ITerminalNode FUNCTION() { return GetToken(VBAExpressionParser.FUNCTION, 0); }
		public ITerminalNode END_WITH() { return GetToken(VBAExpressionParser.END_WITH, 0); }
		public ITerminalNode RSET() { return GetToken(VBAExpressionParser.RSET, 0); }
		public ITerminalNode GOTO() { return GetToken(VBAExpressionParser.GOTO, 0); }
		public ITerminalNode REDIM() { return GetToken(VBAExpressionParser.REDIM, 0); }
		public ITerminalNode EXIT_PROPERTY() { return GetToken(VBAExpressionParser.EXIT_PROPERTY, 0); }
		public ITerminalNode END() { return GetToken(VBAExpressionParser.END, 0); }
		public ITerminalNode SELECT() { return GetToken(VBAExpressionParser.SELECT, 0); }
		public ITerminalNode EXIT_FUNCTION() { return GetToken(VBAExpressionParser.EXIT_FUNCTION, 0); }
		public ITerminalNode READ_WRITE() { return GetToken(VBAExpressionParser.READ_WRITE, 0); }
		public ITerminalNode UNLOCK() { return GetToken(VBAExpressionParser.UNLOCK, 0); }
		public ITerminalNode SET() { return GetToken(VBAExpressionParser.SET, 0); }
		public StatementKeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statementKeyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterStatementKeyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitStatementKeyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatementKeyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementKeywordContext statementKeyword() {
		StatementKeywordContext _localctx = new StatementKeywordContext(_ctx, State);
		EnterRule(_localctx, 80, RULE_statementKeyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 559;
			_la = _input.La(1);
			if ( !(((((_la - 22)) & ~0x3f) == 0 && ((1L << (_la - 22)) & ((1L << (EXIT - 22)) | (1L << (OPTION - 22)) | (1L << (ACCESS - 22)) | (1L << (APPEND - 22)) | (1L << (BINARY - 22)) | (1L << (CALL - 22)) | (1L << (CASE - 22)) | (1L << (CLOSE - 22)) | (1L << (CONST - 22)) | (1L << (DECLARE - 22)) | (1L << (DEFBOOL - 22)) | (1L << (DEFBYTE - 22)) | (1L << (DEFDATE - 22)) | (1L << (DEFDBL - 22)) | (1L << (DEFCUR - 22)) | (1L << (DEFINT - 22)) | (1L << (DEFLNG - 22)) | (1L << (DEFLNGLNG - 22)) | (1L << (DEFLNGPTR - 22)) | (1L << (DEFOBJ - 22)) | (1L << (DEFSNG - 22)) | (1L << (DEFSTR - 22)) | (1L << (DEFVAR - 22)) | (1L << (DIM - 22)) | (1L << (DO - 22)))) != 0) || ((((_la - 87)) & ~0x3f) == 0 && ((1L << (_la - 87)) & ((1L << (ELSE - 87)) | (1L << (ELSEIF - 87)) | (1L << (END_IF - 87)) | (1L << (END_SELECT - 87)) | (1L << (END_WITH - 87)) | (1L << (END - 87)) | (1L << (ENUM - 87)) | (1L << (ERASE - 87)) | (1L << (ERROR - 87)) | (1L << (EVENT - 87)) | (1L << (EXIT_DO - 87)) | (1L << (EXIT_FOR - 87)) | (1L << (EXIT_FUNCTION - 87)) | (1L << (EXIT_PROPERTY - 87)) | (1L << (EXIT_SUB - 87)) | (1L << (FRIEND - 87)) | (1L << (FOR - 87)) | (1L << (FUNCTION - 87)) | (1L << (GET - 87)) | (1L << (GLOBAL - 87)) | (1L << (GOSUB - 87)) | (1L << (GOTO - 87)) | (1L << (IF - 87)) | (1L << (IMPLEMENTS - 87)) | (1L << (INPUT - 87)) | (1L << (LOCK - 87)) | (1L << (LOOP - 87)) | (1L << (LET - 87)) | (1L << (LINE_INPUT - 87)) | (1L << (LOCK_READ - 87)) | (1L << (LOCK_WRITE - 87)) | (1L << (LOCK_READ_WRITE - 87)) | (1L << (LSET - 87)) | (1L << (NEXT - 87)) | (1L << (ON - 87)) | (1L << (ON_ERROR - 87)) | (1L << (OPEN - 87)))) != 0) || ((((_la - 153)) & ~0x3f) == 0 && ((1L << (_la - 153)) & ((1L << (OUTPUT - 153)) | (1L << (PRINT - 153)) | (1L << (PRIVATE - 153)) | (1L << (PUBLIC - 153)) | (1L << (PUT - 153)) | (1L << (RANDOM - 153)) | (1L << (RAISEEVENT - 153)) | (1L << (READ - 153)) | (1L << (READ_WRITE - 153)) | (1L << (REDIM - 153)) | (1L << (RESET - 153)) | (1L << (RESUME - 153)) | (1L << (RETURN - 153)) | (1L << (RSET - 153)) | (1L << (SEEK - 153)) | (1L << (SELECT - 153)) | (1L << (SET - 153)) | (1L << (SHARED - 153)) | (1L << (STATIC - 153)) | (1L << (STEP - 153)) | (1L << (STOP - 153)) | (1L << (SUB - 153)) | (1L << (TYPE - 153)) | (1L << (UNLOCK - 153)) | (1L << (WEND - 153)) | (1L << (WHILE - 153)) | (1L << (WIDTH - 153)) | (1L << (WITH - 153)) | (1L << (WRITE - 153)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RemKeywordContext : ParserRuleContext {
		public ITerminalNode REM() { return GetToken(VBAExpressionParser.REM, 0); }
		public RemKeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_remKeyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterRemKeyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitRemKeyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRemKeyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RemKeywordContext remKeyword() {
		RemKeywordContext _localctx = new RemKeywordContext(_ctx, State);
		EnterRule(_localctx, 82, RULE_remKeyword);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 561; Match(REM);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MarkerKeywordContext : ParserRuleContext {
		public ITerminalNode CASE() { return GetToken(VBAExpressionParser.CASE, 0); }
		public ITerminalNode ELSE() { return GetToken(VBAExpressionParser.ELSE, 0); }
		public ITerminalNode THEN() { return GetToken(VBAExpressionParser.THEN, 0); }
		public ITerminalNode WRITE() { return GetToken(VBAExpressionParser.WRITE, 0); }
		public ITerminalNode PRESERVE() { return GetToken(VBAExpressionParser.PRESERVE, 0); }
		public ITerminalNode SPC() { return GetToken(VBAExpressionParser.SPC, 0); }
		public ITerminalNode TO() { return GetToken(VBAExpressionParser.TO, 0); }
		public ITerminalNode EACH() { return GetToken(VBAExpressionParser.EACH, 0); }
		public ITerminalNode SHARED() { return GetToken(VBAExpressionParser.SHARED, 0); }
		public ITerminalNode ANY() { return GetToken(VBAExpressionParser.ANY, 0); }
		public ITerminalNode NEW() { return GetToken(VBAExpressionParser.NEW, 0); }
		public ITerminalNode AS() { return GetToken(VBAExpressionParser.AS, 0); }
		public ITerminalNode BYVAL() { return GetToken(VBAExpressionParser.BYVAL, 0); }
		public ITerminalNode IN() { return GetToken(VBAExpressionParser.IN, 0); }
		public ITerminalNode TAB() { return GetToken(VBAExpressionParser.TAB, 0); }
		public ITerminalNode BYREF() { return GetToken(VBAExpressionParser.BYREF, 0); }
		public ITerminalNode OPTIONAL() { return GetToken(VBAExpressionParser.OPTIONAL, 0); }
		public ITerminalNode UNTIL() { return GetToken(VBAExpressionParser.UNTIL, 0); }
		public ITerminalNode PARAMARRAY() { return GetToken(VBAExpressionParser.PARAMARRAY, 0); }
		public ITerminalNode WITHEVENTS() { return GetToken(VBAExpressionParser.WITHEVENTS, 0); }
		public MarkerKeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_markerKeyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterMarkerKeyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitMarkerKeyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMarkerKeyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MarkerKeywordContext markerKeyword() {
		MarkerKeywordContext _localctx = new MarkerKeywordContext(_ctx, State);
		EnterRule(_localctx, 84, RULE_markerKeyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 563;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ANY) | (1L << AS) | (1L << BYVAL) | (1L << BYREF) | (1L << CASE))) != 0) || ((((_la - 86)) & ~0x3f) == 0 && ((1L << (_la - 86)) & ((1L << (EACH - 86)) | (1L << (ELSE - 86)) | (1L << (IN - 86)) | (1L << (NEW - 86)) | (1L << (OPTIONAL - 86)))) != 0) || ((((_la - 154)) & ~0x3f) == 0 && ((1L << (_la - 154)) & ((1L << (PARAMARRAY - 154)) | (1L << (PRESERVE - 154)) | (1L << (SHARED - 154)) | (1L << (SPC - 154)) | (1L << (TAB - 154)) | (1L << (THEN - 154)) | (1L << (TO - 154)) | (1L << (UNTIL - 154)) | (1L << (WITHEVENTS - 154)) | (1L << (WRITE - 154)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OperatorIdentifierContext : ParserRuleContext {
		public ITerminalNode NOT() { return GetToken(VBAExpressionParser.NOT, 0); }
		public ITerminalNode IS() { return GetToken(VBAExpressionParser.IS, 0); }
		public ITerminalNode XOR() { return GetToken(VBAExpressionParser.XOR, 0); }
		public ITerminalNode EQV() { return GetToken(VBAExpressionParser.EQV, 0); }
		public ITerminalNode ADDRESSOF() { return GetToken(VBAExpressionParser.ADDRESSOF, 0); }
		public ITerminalNode AND() { return GetToken(VBAExpressionParser.AND, 0); }
		public ITerminalNode TYPEOF() { return GetToken(VBAExpressionParser.TYPEOF, 0); }
		public ITerminalNode LIKE() { return GetToken(VBAExpressionParser.LIKE, 0); }
		public ITerminalNode MOD() { return GetToken(VBAExpressionParser.MOD, 0); }
		public ITerminalNode OR() { return GetToken(VBAExpressionParser.OR, 0); }
		public ITerminalNode IMP() { return GetToken(VBAExpressionParser.IMP, 0); }
		public ITerminalNode NEW() { return GetToken(VBAExpressionParser.NEW, 0); }
		public OperatorIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_operatorIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterOperatorIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitOperatorIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOperatorIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OperatorIdentifierContext operatorIdentifier() {
		OperatorIdentifierContext _localctx = new OperatorIdentifierContext(_ctx, State);
		EnterRule(_localctx, 86, RULE_operatorIdentifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 565;
			_la = _input.La(1);
			if ( !(_la==ADDRESSOF || _la==AND || ((((_la - 100)) & ~0x3f) == 0 && ((1L << (_la - 100)) & ((1L << (EQV - 100)) | (1L << (IMP - 100)) | (1L << (IS - 100)) | (1L << (LIKE - 100)) | (1L << (MOD - 100)) | (1L << (NEW - 100)) | (1L << (NOT - 100)) | (1L << (OR - 100)))) != 0) || _la==TYPEOF || _la==XOR) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedNameContext : ParserRuleContext {
		public ITerminalNode ME() { return GetToken(VBAExpressionParser.ME, 0); }
		public ReservedProcedureNameContext reservedProcedureName() {
			return GetRuleContext<ReservedProcedureNameContext>(0);
		}
		public ReservedNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedNameContext reservedName() {
		ReservedNameContext _localctx = new ReservedNameContext(_ctx, State);
		EnterRule(_localctx, 88, RULE_reservedName);
		try {
			State = 569;
			switch (_input.La(1)) {
			case ME:
				EnterOuterAlt(_localctx, 1);
				{
				State = 567; Match(ME);
				}
				break;
			case ABS:
			case CBOOL:
			case CBYTE:
			case CCUR:
			case CDATE:
			case CDBL:
			case CDEC:
			case CINT:
			case CLNG:
			case CLNGLNG:
			case CLNGPTR:
			case CSNG:
			case CSTR:
			case CVAR:
			case CVERR:
			case DEBUG:
			case DOEVENTS:
			case FIX:
			case INT:
			case LEN:
			case LENB:
			case MIDB:
			case MIDBTYPESUFFIX:
			case MIDTYPESUFFIX:
			case PSET:
			case SCALE:
			case SGN:
			case MID:
				EnterOuterAlt(_localctx, 2);
				{
				State = 568; reservedProcedureName();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedProcedureNameContext : ParserRuleContext {
		public ITerminalNode CSTR() { return GetToken(VBAExpressionParser.CSTR, 0); }
		public ITerminalNode CLNGLNG() { return GetToken(VBAExpressionParser.CLNGLNG, 0); }
		public ITerminalNode CDATE() { return GetToken(VBAExpressionParser.CDATE, 0); }
		public ITerminalNode CINT() { return GetToken(VBAExpressionParser.CINT, 0); }
		public ITerminalNode ABS() { return GetToken(VBAExpressionParser.ABS, 0); }
		public ITerminalNode INT() { return GetToken(VBAExpressionParser.INT, 0); }
		public ITerminalNode LENB() { return GetToken(VBAExpressionParser.LENB, 0); }
		public ITerminalNode SCALE() { return GetToken(VBAExpressionParser.SCALE, 0); }
		public ITerminalNode MIDTYPESUFFIX() { return GetToken(VBAExpressionParser.MIDTYPESUFFIX, 0); }
		public ITerminalNode DEBUG() { return GetToken(VBAExpressionParser.DEBUG, 0); }
		public ITerminalNode CLNGPTR() { return GetToken(VBAExpressionParser.CLNGPTR, 0); }
		public ITerminalNode DOEVENTS() { return GetToken(VBAExpressionParser.DOEVENTS, 0); }
		public ITerminalNode MID() { return GetToken(VBAExpressionParser.MID, 0); }
		public ITerminalNode CDEC() { return GetToken(VBAExpressionParser.CDEC, 0); }
		public ITerminalNode MIDB() { return GetToken(VBAExpressionParser.MIDB, 0); }
		public ITerminalNode CSNG() { return GetToken(VBAExpressionParser.CSNG, 0); }
		public ITerminalNode LEN() { return GetToken(VBAExpressionParser.LEN, 0); }
		public ITerminalNode CCUR() { return GetToken(VBAExpressionParser.CCUR, 0); }
		public ITerminalNode CBOOL() { return GetToken(VBAExpressionParser.CBOOL, 0); }
		public ITerminalNode MIDBTYPESUFFIX() { return GetToken(VBAExpressionParser.MIDBTYPESUFFIX, 0); }
		public ITerminalNode SGN() { return GetToken(VBAExpressionParser.SGN, 0); }
		public ITerminalNode CBYTE() { return GetToken(VBAExpressionParser.CBYTE, 0); }
		public ITerminalNode PSET() { return GetToken(VBAExpressionParser.PSET, 0); }
		public ITerminalNode CVERR() { return GetToken(VBAExpressionParser.CVERR, 0); }
		public ITerminalNode FIX() { return GetToken(VBAExpressionParser.FIX, 0); }
		public ITerminalNode CDBL() { return GetToken(VBAExpressionParser.CDBL, 0); }
		public ITerminalNode CVAR() { return GetToken(VBAExpressionParser.CVAR, 0); }
		public ITerminalNode CLNG() { return GetToken(VBAExpressionParser.CLNG, 0); }
		public ReservedProcedureNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedProcedureName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedProcedureName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedProcedureName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedProcedureName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedProcedureNameContext reservedProcedureName() {
		ReservedProcedureNameContext _localctx = new ReservedProcedureNameContext(_ctx, State);
		EnterRule(_localctx, 90, RULE_reservedProcedureName);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 571;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ABS) | (1L << CBOOL) | (1L << CBYTE) | (1L << CCUR) | (1L << CDATE) | (1L << CDBL) | (1L << CDEC) | (1L << CINT) | (1L << CLNG) | (1L << CLNGLNG) | (1L << CLNGPTR) | (1L << CSNG) | (1L << CSTR) | (1L << CVAR) | (1L << CVERR) | (1L << DEBUG) | (1L << DOEVENTS) | (1L << FIX) | (1L << INT) | (1L << LEN) | (1L << LENB) | (1L << MIDB) | (1L << MIDBTYPESUFFIX) | (1L << MIDTYPESUFFIX) | (1L << PSET) | (1L << SCALE) | (1L << SGN))) != 0) || _la==MID) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SpecialFormContext : ParserRuleContext {
		public ITerminalNode INPUTB() { return GetToken(VBAExpressionParser.INPUTB, 0); }
		public ITerminalNode SCALE() { return GetToken(VBAExpressionParser.SCALE, 0); }
		public ITerminalNode ARRAY() { return GetToken(VBAExpressionParser.ARRAY, 0); }
		public ITerminalNode LBOUND() { return GetToken(VBAExpressionParser.LBOUND, 0); }
		public ITerminalNode UBOUND() { return GetToken(VBAExpressionParser.UBOUND, 0); }
		public ITerminalNode INPUT() { return GetToken(VBAExpressionParser.INPUT, 0); }
		public ITerminalNode CIRCLE() { return GetToken(VBAExpressionParser.CIRCLE, 0); }
		public SpecialFormContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_specialForm; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterSpecialForm(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitSpecialForm(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSpecialForm(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SpecialFormContext specialForm() {
		SpecialFormContext _localctx = new SpecialFormContext(_ctx, State);
		EnterRule(_localctx, 92, RULE_specialForm);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 573;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ARRAY) | (1L << CIRCLE) | (1L << INPUTB) | (1L << LBOUND) | (1L << SCALE) | (1L << UBOUND))) != 0) || _la==INPUT) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedTypeIdentifierContext : ParserRuleContext {
		public ITerminalNode INTEGER() { return GetToken(VBAExpressionParser.INTEGER, 0); }
		public ITerminalNode LONGLONG() { return GetToken(VBAExpressionParser.LONGLONG, 0); }
		public ITerminalNode LONG() { return GetToken(VBAExpressionParser.LONG, 0); }
		public ITerminalNode VARIANT() { return GetToken(VBAExpressionParser.VARIANT, 0); }
		public ITerminalNode LONGPTR() { return GetToken(VBAExpressionParser.LONGPTR, 0); }
		public ITerminalNode BYTE() { return GetToken(VBAExpressionParser.BYTE, 0); }
		public ITerminalNode STRING() { return GetToken(VBAExpressionParser.STRING, 0); }
		public ITerminalNode BOOLEAN() { return GetToken(VBAExpressionParser.BOOLEAN, 0); }
		public ITerminalNode DATE() { return GetToken(VBAExpressionParser.DATE, 0); }
		public ITerminalNode CURRENCY() { return GetToken(VBAExpressionParser.CURRENCY, 0); }
		public ITerminalNode DOUBLE() { return GetToken(VBAExpressionParser.DOUBLE, 0); }
		public ITerminalNode SINGLE() { return GetToken(VBAExpressionParser.SINGLE, 0); }
		public ReservedTypeIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedTypeIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedTypeIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedTypeIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedTypeIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedTypeIdentifierContext reservedTypeIdentifier() {
		ReservedTypeIdentifierContext _localctx = new ReservedTypeIdentifierContext(_ctx, State);
		EnterRule(_localctx, 94, RULE_reservedTypeIdentifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 575;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << CURRENCY) | (1L << LONGLONG) | (1L << LONGPTR) | (1L << BOOLEAN) | (1L << BYTE))) != 0) || ((((_la - 68)) & ~0x3f) == 0 && ((1L << (_la - 68)) & ((1L << (DATE - 68)) | (1L << (DOUBLE - 68)) | (1L << (INTEGER - 68)) | (1L << (LONG - 68)))) != 0) || ((((_la - 178)) & ~0x3f) == 0 && ((1L << (_la - 178)) & ((1L << (SINGLE - 178)) | (1L << (STRING - 178)) | (1L << (VARIANT - 178)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UncategorizedKeywordContext : ParserRuleContext {
		public ITerminalNode TAB() { return GetToken(VBAExpressionParser.TAB, 0); }
		public ITerminalNode LIB() { return GetToken(VBAExpressionParser.LIB, 0); }
		public ITerminalNode VERSION() { return GetToken(VBAExpressionParser.VERSION, 0); }
		public ITerminalNode ON() { return GetToken(VBAExpressionParser.ON, 0); }
		public ITerminalNode COLLECTION() { return GetToken(VBAExpressionParser.COLLECTION, 0); }
		public ITerminalNode ALIAS() { return GetToken(VBAExpressionParser.ALIAS, 0); }
		public ITerminalNode ATTRIBUTE() { return GetToken(VBAExpressionParser.ATTRIBUTE, 0); }
		public ITerminalNode BEGIN() { return GetToken(VBAExpressionParser.BEGIN, 0); }
		public ITerminalNode CLASS() { return GetToken(VBAExpressionParser.CLASS, 0); }
		public UncategorizedKeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_uncategorizedKeyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterUncategorizedKeyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitUncategorizedKeyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUncategorizedKeyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UncategorizedKeywordContext uncategorizedKeyword() {
		UncategorizedKeywordContext _localctx = new UncategorizedKeywordContext(_ctx, State);
		EnterRule(_localctx, 96, RULE_uncategorizedKeyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 577;
			_la = _input.La(1);
			if ( !(((((_la - 51)) & ~0x3f) == 0 && ((1L << (_la - 51)) & ((1L << (ALIAS - 51)) | (1L << (ATTRIBUTE - 51)) | (1L << (BEGIN - 51)) | (1L << (CLASS - 51)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (LIB - 128)) | (1L << (ON - 128)) | (1L << (TAB - 128)))) != 0) || _la==VERSION || _la==COLLECTION) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralIdentifierContext : ParserRuleContext {
		public ObjectLiteralIdentifierContext objectLiteralIdentifier() {
			return GetRuleContext<ObjectLiteralIdentifierContext>(0);
		}
		public BooleanLiteralIdentifierContext booleanLiteralIdentifier() {
			return GetRuleContext<BooleanLiteralIdentifierContext>(0);
		}
		public VariantLiteralIdentifierContext variantLiteralIdentifier() {
			return GetRuleContext<VariantLiteralIdentifierContext>(0);
		}
		public LiteralIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literalIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLiteralIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLiteralIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteralIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralIdentifierContext literalIdentifier() {
		LiteralIdentifierContext _localctx = new LiteralIdentifierContext(_ctx, State);
		EnterRule(_localctx, 98, RULE_literalIdentifier);
		try {
			State = 582;
			switch (_input.La(1)) {
			case FALSE:
			case TRUE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 579; booleanLiteralIdentifier();
				}
				break;
			case NOTHING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 580; objectLiteralIdentifier();
				}
				break;
			case EMPTY:
			case NULL:
				EnterOuterAlt(_localctx, 3);
				{
				State = 581; variantLiteralIdentifier();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BooleanLiteralIdentifierContext : ParserRuleContext {
		public ITerminalNode FALSE() { return GetToken(VBAExpressionParser.FALSE, 0); }
		public ITerminalNode TRUE() { return GetToken(VBAExpressionParser.TRUE, 0); }
		public BooleanLiteralIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_booleanLiteralIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterBooleanLiteralIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitBooleanLiteralIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBooleanLiteralIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BooleanLiteralIdentifierContext booleanLiteralIdentifier() {
		BooleanLiteralIdentifierContext _localctx = new BooleanLiteralIdentifierContext(_ctx, State);
		EnterRule(_localctx, 100, RULE_booleanLiteralIdentifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 584;
			_la = _input.La(1);
			if ( !(_la==FALSE || _la==TRUE) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectLiteralIdentifierContext : ParserRuleContext {
		public ITerminalNode NOTHING() { return GetToken(VBAExpressionParser.NOTHING, 0); }
		public ObjectLiteralIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectLiteralIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterObjectLiteralIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitObjectLiteralIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObjectLiteralIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ObjectLiteralIdentifierContext objectLiteralIdentifier() {
		ObjectLiteralIdentifierContext _localctx = new ObjectLiteralIdentifierContext(_ctx, State);
		EnterRule(_localctx, 102, RULE_objectLiteralIdentifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 586; Match(NOTHING);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariantLiteralIdentifierContext : ParserRuleContext {
		public ITerminalNode NULL() { return GetToken(VBAExpressionParser.NULL, 0); }
		public ITerminalNode EMPTY() { return GetToken(VBAExpressionParser.EMPTY, 0); }
		public VariantLiteralIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variantLiteralIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterVariantLiteralIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitVariantLiteralIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariantLiteralIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VariantLiteralIdentifierContext variantLiteralIdentifier() {
		VariantLiteralIdentifierContext _localctx = new VariantLiteralIdentifierContext(_ctx, State);
		EnterRule(_localctx, 104, RULE_variantLiteralIdentifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 588;
			_la = _input.La(1);
			if ( !(_la==EMPTY || _la==NULL) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhiteSpaceContext : ParserRuleContext {
		public ITerminalNode WS(int i) {
			return GetToken(VBAExpressionParser.WS, i);
		}
		public IReadOnlyList<ITerminalNode> WS() { return GetTokens(VBAExpressionParser.WS); }
		public IReadOnlyList<ITerminalNode> LINE_CONTINUATION() { return GetTokens(VBAExpressionParser.LINE_CONTINUATION); }
		public ITerminalNode LINE_CONTINUATION(int i) {
			return GetToken(VBAExpressionParser.LINE_CONTINUATION, i);
		}
		public WhiteSpaceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whiteSpace; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterWhiteSpace(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitWhiteSpace(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhiteSpace(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WhiteSpaceContext whiteSpace() {
		WhiteSpaceContext _localctx = new WhiteSpaceContext(_ctx, State);
		EnterRule(_localctx, 106, RULE_whiteSpace);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 591;
			_errHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 590;
					_la = _input.La(1);
					if ( !(_la==WS || _la==LINE_CONTINUATION) ) {
					_errHandler.RecoverInline(this);
					}
					Consume();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 593;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,83,_ctx);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 12: return expression_sempred((ExpressionContext)_localctx, predIndex);

		case 18: return lExpression_sempred((LExpressionContext)_localctx, predIndex);
		}
		return true;
	}
	private bool expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(_ctx, 15);

		case 1: return Precpred(_ctx, 13);

		case 2: return Precpred(_ctx, 12);

		case 3: return Precpred(_ctx, 11);

		case 4: return Precpred(_ctx, 10);

		case 5: return Precpred(_ctx, 9);

		case 6: return Precpred(_ctx, 8);

		case 7: return Precpred(_ctx, 6);

		case 8: return Precpred(_ctx, 5);

		case 9: return Precpred(_ctx, 4);

		case 10: return Precpred(_ctx, 3);

		case 11: return Precpred(_ctx, 2);
		}
		return true;
	}
	private bool lExpression_sempred(LExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 16: return Precpred(_ctx, 5);

		case 17: return Precpred(_ctx, 4);

		case 12: return Precpred(_ctx, 9);

		case 13: return Precpred(_ctx, 8);

		case 14: return Precpred(_ctx, 7);

		case 15: return Precpred(_ctx, 6);
		}
		return true;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3\xF5\x256\x4\x2"+
		"\t\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4"+
		"\t\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10"+
		"\t\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15"+
		"\x4\x16\t\x16\x4\x17\t\x17\x4\x18\t\x18\x4\x19\t\x19\x4\x1A\t\x1A\x4\x1B"+
		"\t\x1B\x4\x1C\t\x1C\x4\x1D\t\x1D\x4\x1E\t\x1E\x4\x1F\t\x1F\x4 \t \x4!"+
		"\t!\x4\"\t\"\x4#\t#\x4$\t$\x4%\t%\x4&\t&\x4\'\t\'\x4(\t(\x4)\t)\x4*\t"+
		"*\x4+\t+\x4,\t,\x4-\t-\x4.\t.\x4/\t/\x4\x30\t\x30\x4\x31\t\x31\x4\x32"+
		"\t\x32\x4\x33\t\x33\x4\x34\t\x34\x4\x35\t\x35\x4\x36\t\x36\x4\x37\t\x37"+
		"\x3\x2\x3\x2\x3\x2\x3\x3\x3\x3\x5\x3t\n\x3\x3\x4\x3\x4\x5\x4x\n\x4\x3"+
		"\x5\x3\x5\x5\x5|\n\x5\x3\x6\x3\x6\x3\a\x3\a\x3\a\x3\b\x3\b\x3\b\x3\b\x3"+
		"\b\x3\b\x3\b\x3\b\x5\b\x8B\n\b\x3\t\x3\t\x3\t\x3\n\x3\n\x3\n\x3\n\x3\n"+
		"\x3\n\x3\n\x5\n\x97\n\n\x3\v\x3\v\x3\f\x3\f\x3\r\x3\r\x3\r\x5\r\xA0\n"+
		"\r\x3\r\x3\r\x5\r\xA4\n\r\x3\r\x3\r\x3\r\x3\r\x3\r\x5\r\xAB\n\r\x3\r\x3"+
		"\r\x5\r\xAF\n\r\x3\r\x5\r\xB2\n\r\x3\xE\x3\xE\x3\xE\x5\xE\xB7\n\xE\x3"+
		"\xE\x3\xE\x3\xE\x5\xE\xBC\n\xE\x3\xE\x3\xE\x3\xE\x3\xE\x5\xE\xC2\n\xE"+
		"\x3\xE\x3\xE\x5\xE\xC6\n\xE\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE\x5\xE\xCD\n"+
		"\xE\x3\xE\x3\xE\x5\xE\xD1\n\xE\x3\xE\x3\xE\x5\xE\xD5\n\xE\x3\xE\x3\xE"+
		"\x3\xE\x5\xE\xDA\n\xE\x3\xE\x3\xE\x5\xE\xDE\n\xE\x3\xE\x3\xE\x3\xE\x5"+
		"\xE\xE3\n\xE\x3\xE\x3\xE\x5\xE\xE7\n\xE\x3\xE\x3\xE\x3\xE\x5\xE\xEC\n"+
		"\xE\x3\xE\x3\xE\x5\xE\xF0\n\xE\x3\xE\x3\xE\x3\xE\x5\xE\xF5\n\xE\x3\xE"+
		"\x3\xE\x5\xE\xF9\n\xE\x3\xE\x3\xE\x3\xE\x5\xE\xFE\n\xE\x3\xE\x3\xE\x5"+
		"\xE\x102\n\xE\x3\xE\x3\xE\x3\xE\x5\xE\x107\n\xE\x3\xE\x3\xE\x5\xE\x10B"+
		"\n\xE\x3\xE\x3\xE\x3\xE\x5\xE\x110\n\xE\x3\xE\x3\xE\x5\xE\x114\n\xE\x3"+
		"\xE\x3\xE\x3\xE\x5\xE\x119\n\xE\x3\xE\x3\xE\x5\xE\x11D\n\xE\x3\xE\x3\xE"+
		"\x3\xE\x5\xE\x122\n\xE\x3\xE\x3\xE\x5\xE\x126\n\xE\x3\xE\x3\xE\x3\xE\x5"+
		"\xE\x12B\n\xE\x3\xE\x3\xE\x5\xE\x12F\n\xE\x3\xE\x3\xE\x3\xE\x5\xE\x134"+
		"\n\xE\x3\xE\x3\xE\x5\xE\x138\n\xE\x3\xE\a\xE\x13B\n\xE\f\xE\xE\xE\x13E"+
		"\v\xE\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x5\xF\x145\n\xF\x5\xF\x147\n\xF\x3"+
		"\x10\x3\x10\x3\x11\x3\x11\x5\x11\x14D\n\x11\x3\x11\x3\x11\x5\x11\x151"+
		"\n\x11\x3\x11\x3\x11\x3\x12\x3\x12\x3\x12\x3\x12\x3\x12\x3\x12\x3\x12"+
		"\x3\x12\x3\x13\x3\x13\x3\x13\x3\x13\x3\x14\x3\x14\x3\x14\x3\x14\x5\x14"+
		"\x165\n\x14\x3\x14\x3\x14\x5\x14\x169\n\x14\x3\x14\x3\x14\x5\x14\x16D"+
		"\n\x14\x3\x14\x5\x14\x170\n\x14\x3\x14\x5\x14\x173\n\x14\x3\x14\x3\x14"+
		"\x3\x14\x3\x14\x3\x14\x3\x14\x3\x14\x5\x14\x17C\n\x14\x3\x14\x3\x14\x3"+
		"\x14\x3\x14\x3\x14\x3\x14\x3\x14\x3\x14\x3\x14\x3\x14\x3\x14\x3\x14\x3"+
		"\x14\x3\x14\a\x14\x18C\n\x14\f\x14\xE\x14\x18F\v\x14\x3\x15\x3\x15\x3"+
		"\x15\x3\x15\x3\x15\x3\x15\x3\x15\x5\x15\x198\n\x15\x3\x15\x3\x15\x3\x15"+
		"\x5\x15\x19D\n\x15\x3\x16\x3\x16\x5\x16\x1A1\n\x16\x3\x16\x3\x16\x5\x16"+
		"\x1A5\n\x16\x3\x16\x5\x16\x1A8\n\x16\x3\x16\x5\x16\x1AB\n\x16\x3\x16\x3"+
		"\x16\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3"+
		"\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x5\x17\x1BE\n\x17\x3\x18\x3\x18"+
		"\x3\x19\x5\x19\x1C3\n\x19\x3\x19\x5\x19\x1C6\n\x19\x3\x19\x3\x19\x5\x19"+
		"\x1CA\n\x19\a\x19\x1CC\n\x19\f\x19\xE\x19\x1CF\v\x19\x3\x19\x3\x19\x5"+
		"\x19\x1D3\n\x19\x3\x19\x5\x19\x1D6\n\x19\x3\x19\x3\x19\x5\x19\x1DA\n\x19"+
		"\a\x19\x1DC\n\x19\f\x19\xE\x19\x1DF\v\x19\x3\x19\x5\x19\x1E2\n\x19\x3"+
		"\x1A\x3\x1A\x3\x1B\x3\x1B\x3\x1C\x3\x1C\x5\x1C\x1EA\n\x1C\x3\x1C\x3\x1C"+
		"\x5\x1C\x1EE\n\x1C\x3\x1C\a\x1C\x1F1\n\x1C\f\x1C\xE\x1C\x1F4\v\x1C\x3"+
		"\x1D\x3\x1D\x5\x1D\x1F8\n\x1D\x3\x1D\x3\x1D\x5\x1D\x1FC\n\x1D\x3\x1D\x3"+
		"\x1D\x3\x1E\x3\x1E\x5\x1E\x202\n\x1E\x3\x1E\x3\x1E\x5\x1E\x206\n\x1E\x3"+
		"\x1F\x3\x1F\x3 \x3 \x3!\x3!\x5!\x20E\n!\x3\"\x3\"\x3\"\x3#\x3#\x3#\x3"+
		"$\x3$\x3%\x3%\x5%\x21A\n%\x3&\x3&\x5&\x21E\n&\x3\'\x3\'\x3\'\x3\'\x3("+
		"\x3(\x5(\x226\n(\x3)\x3)\x3)\x3)\x3)\x3)\x3)\x3)\x5)\x230\n)\x3*\x3*\x3"+
		"+\x3+\x3,\x3,\x3-\x3-\x3.\x3.\x5.\x23C\n.\x3/\x3/\x3\x30\x3\x30\x3\x31"+
		"\x3\x31\x3\x32\x3\x32\x3\x33\x3\x33\x3\x33\x5\x33\x249\n\x33\x3\x34\x3"+
		"\x34\x3\x35\x3\x35\x3\x36\x3\x36\x3\x37\x6\x37\x252\n\x37\r\x37\xE\x37"+
		"\x253\x3\x37\x2\x2\x4\x1A&\x38\x2\x2\x4\x2\x6\x2\b\x2\n\x2\f\x2\xE\x2"+
		"\x10\x2\x12\x2\x14\x2\x16\x2\x18\x2\x1A\x2\x1C\x2\x1E\x2 \x2\"\x2$\x2"+
		"&\x2(\x2*\x2,\x2.\x2\x30\x2\x32\x2\x34\x2\x36\x2\x38\x2:\x2<\x2>\x2@\x2"+
		"\x42\x2\x44\x2\x46\x2H\x2J\x2L\x2N\x2P\x2R\x2T\x2V\x2X\x2Z\x2\\\x2^\x2"+
		"`\x2\x62\x2\x64\x2\x66\x2h\x2j\x2l\x2\x2\x12\x5\x2,,.\x32\xDA\xDA\x5\x2"+
		";;\x45\x45\xBC\xBC\x4\x2\xCE\xCE\xD7\xD7\x4\x2\xD6\xD6\xD9\xD9\a\x2||"+
		"\x83\x83\xD0\xD3\xD5\xD5\xD8\xD8\x3\x2\xE4\xE7\"\x2\x18\x18$$\x33\x33"+
		"\x38\x38;;@\x41\x43\x44GVYZ^^``\x63\x65gnpwyy{{~~\x80\x81\x84\x88\x8C"+
		"\x8C\x91\x92\x94\x94\x9B\x9B\x9E\x9F\xA4\xAA\xAC\xB3\xB6\xB8\xBA\xBA\xC0"+
		"\xC0\xC2\xC2\xC6\xC9\xCB\xCB\x11\x2\x4\x4\x39\x39=>\x41\x41XYzz\x8D\x8D"+
		"\x95\x95\x9C\x9D\xB3\xB3\xB5\xB5\xBB\xBB\xBD\xBE\xC3\xC3\xCA\xCB\r\x2"+
		"\x34\x34\x36\x36\x66\x66xx||\x83\x83\x8B\x8B\x8D\x8E\x9A\x9A\xC1\xC1\xCC"+
		"\xCC\f\x2\x3\x3\x6\f\xE\x12\x14\x17\x19\x19\x1B\x1B\x1D\x1E!#%\'\x8A\x8A"+
		"\t\x2\x5\x5\r\r\x1A\x1A\x1C\x1C&&(({{\r\x2\x13\x13\x1F <<??\x46\x46WW"+
		"}}\x7F\x7F\xB4\xB4\xB9\xB9\xC4\xC4\v\x2\x35\x35\x37\x37::\x42\x42\x82"+
		"\x82\x91\x91\xBB\xBB\xC5\xC5\xF5\xF5\x4\x2oo\xBF\xBF\x4\x2[[\x90\x90\x4"+
		"\x2\xEE\xEE\xF0\xF0\x29E\x2n\x3\x2\x2\x2\x4s\x3\x2\x2\x2\x6w\x3\x2\x2"+
		"\x2\b{\x3\x2\x2\x2\n}\x3\x2\x2\x2\f\x7F\x3\x2\x2\x2\xE\x8A\x3\x2\x2\x2"+
		"\x10\x8C\x3\x2\x2\x2\x12\x96\x3\x2\x2\x2\x14\x98\x3\x2\x2\x2\x16\x9A\x3"+
		"\x2\x2\x2\x18\xB1\x3\x2\x2\x2\x1A\xCC\x3\x2\x2\x2\x1C\x146\x3\x2\x2\x2"+
		"\x1E\x148\x3\x2\x2\x2 \x14A\x3\x2\x2\x2\"\x154\x3\x2\x2\x2$\x15C\x3\x2"+
		"\x2\x2&\x164\x3\x2\x2\x2(\x19C\x3\x2\x2\x2*\x19E\x3\x2\x2\x2,\x1BD\x3"+
		"\x2\x2\x2.\x1BF\x3\x2\x2\x2\x30\x1E1\x3\x2\x2\x2\x32\x1E3\x3\x2\x2\x2"+
		"\x34\x1E5\x3\x2\x2\x2\x36\x1E7\x3\x2\x2\x2\x38\x1F5\x3\x2\x2\x2:\x205"+
		"\x3\x2\x2\x2<\x207\x3\x2\x2\x2>\x209\x3\x2\x2\x2@\x20D\x3\x2\x2\x2\x42"+
		"\x20F\x3\x2\x2\x2\x44\x212\x3\x2\x2\x2\x46\x215\x3\x2\x2\x2H\x219\x3\x2"+
		"\x2\x2J\x21D\x3\x2\x2\x2L\x21F\x3\x2\x2\x2N\x225\x3\x2\x2\x2P\x22F\x3"+
		"\x2\x2\x2R\x231\x3\x2\x2\x2T\x233\x3\x2\x2\x2V\x235\x3\x2\x2\x2X\x237"+
		"\x3\x2\x2\x2Z\x23B\x3\x2\x2\x2\\\x23D\x3\x2\x2\x2^\x23F\x3\x2\x2\x2`\x241"+
		"\x3\x2\x2\x2\x62\x243\x3\x2\x2\x2\x64\x248\x3\x2\x2\x2\x66\x24A\x3\x2"+
		"\x2\x2h\x24C\x3\x2\x2\x2j\x24E\x3\x2\x2\x2l\x251\x3\x2\x2\x2no\x5\x1A"+
		"\xE\x2op\a\x2\x2\x3p\x3\x3\x2\x2\x2qt\x5\x6\x4\x2rt\x5\b\x5\x2sq\x3\x2"+
		"\x2\x2sr\x3\x2\x2\x2t\x5\x3\x2\x2\x2ux\x5\xE\b\x2vx\x5\x10\t\x2wu\x3\x2"+
		"\x2\x2wv\x3\x2\x2\x2x\a\x3\x2\x2\x2y|\x5\n\x6\x2z|\x5\f\a\x2{y\x3\x2\x2"+
		"\x2{z\x3\x2\x2\x2|\t\x3\x2\x2\x2}~\x5P)\x2~\v\x3\x2\x2\x2\x7F\x80\x5P"+
		")\x2\x80\x81\x5\x14\v\x2\x81\r\x3\x2\x2\x2\x82\x8B\a\xEF\x2\x2\x83\x8B"+
		"\a\xF3\x2\x2\x84\x8B\x5\\/\x2\x85\x8B\x5^\x30\x2\x86\x8B\x5\x16\f\x2\x87"+
		"\x8B\a\xF4\x2\x2\x88\x8B\x5\x62\x32\x2\x89\x8B\ah\x2\x2\x8A\x82\x3\x2"+
		"\x2\x2\x8A\x83\x3\x2\x2\x2\x8A\x84\x3\x2\x2\x2\x8A\x85\x3\x2\x2\x2\x8A"+
		"\x86\x3\x2\x2\x2\x8A\x87\x3\x2\x2\x2\x8A\x88\x3\x2\x2\x2\x8A\x89\x3\x2"+
		"\x2\x2\x8B\xF\x3\x2\x2\x2\x8C\x8D\x5\x12\n\x2\x8D\x8E\x5\x14\v\x2\x8E"+
		"\x11\x3\x2\x2\x2\x8F\x97\a\xEF\x2\x2\x90\x97\x5\\/\x2\x91\x97\x5^\x30"+
		"\x2\x92\x97\x5\x16\f\x2\x93\x97\a\xF4\x2\x2\x94\x97\x5\x62\x32\x2\x95"+
		"\x97\ah\x2\x2\x96\x8F\x3\x2\x2\x2\x96\x90\x3\x2\x2\x2\x96\x91\x3\x2\x2"+
		"\x2\x96\x92\x3\x2\x2\x2\x96\x93\x3\x2\x2\x2\x96\x94\x3\x2\x2\x2\x96\x95"+
		"\x3\x2\x2\x2\x97\x13\x3\x2\x2\x2\x98\x99\t\x2\x2\x2\x99\x15\x3\x2\x2\x2"+
		"\x9A\x9B\t\x3\x2\x2\x9B\x17\x3\x2\x2\x2\x9C\xB2\x5`\x31\x2\x9D\x9F\a\xE1"+
		"\x2\x2\x9E\xA0\x5l\x37\x2\x9F\x9E\x3\x2\x2\x2\x9F\xA0\x3\x2\x2\x2\xA0"+
		"\xA1\x3\x2\x2\x2\xA1\xA3\x5`\x31\x2\xA2\xA4\x5l\x37\x2\xA3\xA2\x3\x2\x2"+
		"\x2\xA3\xA4\x3\x2\x2\x2\xA4\xA5\x3\x2\x2\x2\xA5\xA6\a\xE2\x2\x2\xA6\xB2"+
		"\x3\x2\x2\x2\xA7\xB2\a\xF4\x2\x2\xA8\xAA\a\xE1\x2\x2\xA9\xAB\x5l\x37\x2"+
		"\xAA\xA9\x3\x2\x2\x2\xAA\xAB\x3\x2\x2\x2\xAB\xAC\x3\x2\x2\x2\xAC\xAE\a"+
		"\xF4\x2\x2\xAD\xAF\x5l\x37\x2\xAE\xAD\x3\x2\x2\x2\xAE\xAF\x3\x2\x2\x2"+
		"\xAF\xB0\x3\x2\x2\x2\xB0\xB2\a\xE2\x2\x2\xB1\x9C\x3\x2\x2\x2\xB1\x9D\x3"+
		"\x2\x2\x2\xB1\xA7\x3\x2\x2\x2\xB1\xA8\x3\x2\x2\x2\xB2\x19\x3\x2\x2\x2"+
		"\xB3\xB4\b\xE\x1\x2\xB4\xB6\a\xD6\x2\x2\xB5\xB7\x5l\x37\x2\xB6\xB5\x3"+
		"\x2\x2\x2\xB6\xB7\x3\x2\x2\x2\xB7\xB8\x3\x2\x2\x2\xB8\xCD\x5\x1A\xE\x10"+
		"\xB9\xBB\a\x8E\x2\x2\xBA\xBC\x5l\x37\x2\xBB\xBA\x3\x2\x2\x2\xBB\xBC\x3"+
		"\x2\x2\x2\xBC\xBD\x3\x2\x2\x2\xBD\xCD\x5\x1A\xE\t\xBE\xCD\x5&\x14\x2\xBF"+
		"\xC1\a\xD4\x2\x2\xC0\xC2\x5l\x37\x2\xC1\xC0\x3\x2\x2\x2\xC1\xC2\x3\x2"+
		"\x2\x2\xC2\xC3\x3\x2\x2\x2\xC3\xC5\x5\x1A\xE\x2\xC4\xC6\x5l\x37\x2\xC5"+
		"\xC4\x3\x2\x2\x2\xC5\xC6\x3\x2\x2\x2\xC6\xC7\x3\x2\x2\x2\xC7\xC8\a\xDB"+
		"\x2\x2\xC8\xCD\x3\x2\x2\x2\xC9\xCD\x5\"\x12\x2\xCA\xCD\x5$\x13\x2\xCB"+
		"\xCD\x5\x1C\xF\x2\xCC\xB3\x3\x2\x2\x2\xCC\xB9\x3\x2\x2\x2\xCC\xBE\x3\x2"+
		"\x2\x2\xCC\xBF\x3\x2\x2\x2\xCC\xC9\x3\x2\x2\x2\xCC\xCA\x3\x2\x2\x2\xCC"+
		"\xCB\x3\x2\x2\x2\xCD\x13C\x3\x2\x2\x2\xCE\xD0\f\x11\x2\x2\xCF\xD1\x5l"+
		"\x37\x2\xD0\xCF\x3\x2\x2\x2\xD0\xD1\x3\x2\x2\x2\xD1\xD2\x3\x2\x2\x2\xD2"+
		"\xD4\a\xDA\x2\x2\xD3\xD5\x5l\x37\x2\xD4\xD3\x3\x2\x2\x2\xD4\xD5\x3\x2"+
		"\x2\x2\xD5\xD6\x3\x2\x2\x2\xD6\x13B\x5\x1A\xE\x12\xD7\xD9\f\xF\x2\x2\xD8"+
		"\xDA\x5l\x37\x2\xD9\xD8\x3\x2\x2\x2\xD9\xDA\x3\x2\x2\x2\xDA\xDB\x3\x2"+
		"\x2\x2\xDB\xDD\t\x4\x2\x2\xDC\xDE\x5l\x37\x2\xDD\xDC\x3\x2\x2\x2\xDD\xDE"+
		"\x3\x2\x2\x2\xDE\xDF\x3\x2\x2\x2\xDF\x13B\x5\x1A\xE\x10\xE0\xE2\f\xE\x2"+
		"\x2\xE1\xE3\x5l\x37\x2\xE2\xE1\x3\x2\x2\x2\xE2\xE3\x3\x2\x2\x2\xE3\xE4"+
		"\x3\x2\x2\x2\xE4\xE6\a\xCF\x2\x2\xE5\xE7\x5l\x37\x2\xE6\xE5\x3\x2\x2\x2"+
		"\xE6\xE7\x3\x2\x2\x2\xE7\xE8\x3\x2\x2\x2\xE8\x13B\x5\x1A\xE\xF\xE9\xEB"+
		"\f\r\x2\x2\xEA\xEC\x5l\x37\x2\xEB\xEA\x3\x2\x2\x2\xEB\xEC\x3\x2\x2\x2"+
		"\xEC\xED\x3\x2\x2\x2\xED\xEF\a\x8B\x2\x2\xEE\xF0\x5l\x37\x2\xEF\xEE\x3"+
		"\x2\x2\x2\xEF\xF0\x3\x2\x2\x2\xF0\xF1\x3\x2\x2\x2\xF1\x13B\x5\x1A\xE\xE"+
		"\xF2\xF4\f\f\x2\x2\xF3\xF5\x5l\x37\x2\xF4\xF3\x3\x2\x2\x2\xF4\xF5\x3\x2"+
		"\x2\x2\xF5\xF6\x3\x2\x2\x2\xF6\xF8\t\x5\x2\x2\xF7\xF9\x5l\x37\x2\xF8\xF7"+
		"\x3\x2\x2\x2\xF8\xF9\x3\x2\x2\x2\xF9\xFA\x3\x2\x2\x2\xFA\x13B\x5\x1A\xE"+
		"\r\xFB\xFD\f\v\x2\x2\xFC\xFE\x5l\x37\x2\xFD\xFC\x3\x2\x2\x2\xFD\xFE\x3"+
		"\x2\x2\x2\xFE\xFF\x3\x2\x2\x2\xFF\x101\a\x32\x2\x2\x100\x102\x5l\x37\x2"+
		"\x101\x100\x3\x2\x2\x2\x101\x102\x3\x2\x2\x2\x102\x103\x3\x2\x2\x2\x103"+
		"\x13B\x5\x1A\xE\f\x104\x106\f\n\x2\x2\x105\x107\x5l\x37\x2\x106\x105\x3"+
		"\x2\x2\x2\x106\x107\x3\x2\x2\x2\x107\x108\x3\x2\x2\x2\x108\x10A\t\x6\x2"+
		"\x2\x109\x10B\x5l\x37\x2\x10A\x109\x3\x2\x2\x2\x10A\x10B\x3\x2\x2\x2\x10B"+
		"\x10C\x3\x2\x2\x2\x10C\x13B\x5\x1A\xE\v\x10D\x10F\f\b\x2\x2\x10E\x110"+
		"\x5l\x37\x2\x10F\x10E\x3\x2\x2\x2\x10F\x110\x3\x2\x2\x2\x110\x111\x3\x2"+
		"\x2\x2\x111\x113\a\x36\x2\x2\x112\x114\x5l\x37\x2\x113\x112\x3\x2\x2\x2"+
		"\x113\x114\x3\x2\x2\x2\x114\x115\x3\x2\x2\x2\x115\x13B\x5\x1A\xE\t\x116"+
		"\x118\f\a\x2\x2\x117\x119\x5l\x37\x2\x118\x117\x3\x2\x2\x2\x118\x119\x3"+
		"\x2\x2\x2\x119\x11A\x3\x2\x2\x2\x11A\x11C\a\x9A\x2\x2\x11B\x11D\x5l\x37"+
		"\x2\x11C\x11B\x3\x2\x2\x2\x11C\x11D\x3\x2\x2\x2\x11D\x11E\x3\x2\x2\x2"+
		"\x11E\x13B\x5\x1A\xE\b\x11F\x121\f\x6\x2\x2\x120\x122\x5l\x37\x2\x121"+
		"\x120\x3\x2\x2\x2\x121\x122\x3\x2\x2\x2\x122\x123\x3\x2\x2\x2\x123\x125"+
		"\a\xCC\x2\x2\x124\x126\x5l\x37\x2\x125\x124\x3\x2\x2\x2\x125\x126\x3\x2"+
		"\x2\x2\x126\x127\x3\x2\x2\x2\x127\x13B\x5\x1A\xE\a\x128\x12A\f\x5\x2\x2"+
		"\x129\x12B\x5l\x37\x2\x12A\x129\x3\x2\x2\x2\x12A\x12B\x3\x2\x2\x2\x12B"+
		"\x12C\x3\x2\x2\x2\x12C\x12E\a\x66\x2\x2\x12D\x12F\x5l\x37\x2\x12E\x12D"+
		"\x3\x2\x2\x2\x12E\x12F\x3\x2\x2\x2\x12F\x130\x3\x2\x2\x2\x130\x13B\x5"+
		"\x1A\xE\x6\x131\x133\f\x4\x2\x2\x132\x134\x5l\x37\x2\x133\x132\x3\x2\x2"+
		"\x2\x133\x134\x3\x2\x2\x2\x134\x135\x3\x2\x2\x2\x135\x137\ax\x2\x2\x136"+
		"\x138\x5l\x37\x2\x137\x136\x3\x2\x2\x2\x137\x138\x3\x2\x2\x2\x138\x139"+
		"\x3\x2\x2\x2\x139\x13B\x5\x1A\xE\x5\x13A\xCE\x3\x2\x2\x2\x13A\xD7\x3\x2"+
		"\x2\x2\x13A\xE0\x3\x2\x2\x2\x13A\xE9\x3\x2\x2\x2\x13A\xF2\x3\x2\x2\x2"+
		"\x13A\xFB\x3\x2\x2\x2\x13A\x104\x3\x2\x2\x2\x13A\x10D\x3\x2\x2\x2\x13A"+
		"\x116\x3\x2\x2\x2\x13A\x11F\x3\x2\x2\x2\x13A\x128\x3\x2\x2\x2\x13A\x131"+
		"\x3\x2\x2\x2\x13B\x13E\x3\x2\x2\x2\x13C\x13A\x3\x2\x2\x2\x13C\x13D\x3"+
		"\x2\x2\x2\x13D\x1B\x3\x2\x2\x2\x13E\x13C\x3\x2\x2\x2\x13F\x147\x5\x1E"+
		"\x10\x2\x140\x147\a\xE8\x2\x2\x141\x147\a\xE3\x2\x2\x142\x144\x5\x64\x33"+
		"\x2\x143\x145\x5\x14\v\x2\x144\x143\x3\x2\x2\x2\x144\x145\x3\x2\x2\x2"+
		"\x145\x147\x3\x2\x2\x2\x146\x13F\x3\x2\x2\x2\x146\x140\x3\x2\x2\x2\x146"+
		"\x141\x3\x2\x2\x2\x146\x142\x3\x2\x2\x2\x147\x1D\x3\x2\x2\x2\x148\x149"+
		"\t\a\x2\x2\x149\x1F\x3\x2\x2\x2\x14A\x14C\a\xD4\x2\x2\x14B\x14D\x5l\x37"+
		"\x2\x14C\x14B\x3\x2\x2\x2\x14C\x14D\x3\x2\x2\x2\x14D\x14E\x3\x2\x2\x2"+
		"\x14E\x150\x5\x1A\xE\x2\x14F\x151\x5l\x37\x2\x150\x14F\x3\x2\x2\x2\x150"+
		"\x151\x3\x2\x2\x2\x151\x152\x3\x2\x2\x2\x152\x153\a\xDB\x2\x2\x153!\x3"+
		"\x2\x2\x2\x154\x155\a\xC1\x2\x2\x155\x156\x5l\x37\x2\x156\x157\x5\x1A"+
		"\xE\x2\x157\x158\x5l\x37\x2\x158\x159\a|\x2\x2\x159\x15A\x5l\x37\x2\x15A"+
		"\x15B\x5H%\x2\x15B#\x3\x2\x2\x2\x15C\x15D\a\x8D\x2\x2\x15D\x15E\x5l\x37"+
		"\x2\x15E\x15F\x5H%\x2\x15F%\x3\x2\x2\x2\x160\x161\b\x14\x1\x2\x161\x165"+
		"\x5> \x2\x162\x165\x5<\x1F\x2\x163\x165\x5@!\x2\x164\x160\x3\x2\x2\x2"+
		"\x164\x162\x3\x2\x2\x2\x164\x163\x3\x2\x2\x2\x165\x18D\x3\x2\x2\x2\x166"+
		"\x168\f\v\x2\x2\x167\x169\x5l\x37\x2\x168\x167\x3\x2\x2\x2\x168\x169\x3"+
		"\x2\x2\x2\x169\x16A\x3\x2\x2\x2\x16A\x16C\a\xD4\x2\x2\x16B\x16D\x5l\x37"+
		"\x2\x16C\x16B\x3\x2\x2\x2\x16C\x16D\x3\x2\x2\x2\x16D\x16F\x3\x2\x2\x2"+
		"\x16E\x170\x5.\x18\x2\x16F\x16E\x3\x2\x2\x2\x16F\x170\x3\x2\x2\x2\x170"+
		"\x172\x3\x2\x2\x2\x171\x173\x5l\x37\x2\x172\x171\x3\x2\x2\x2\x172\x173"+
		"\x3\x2\x2\x2\x173\x174\x3\x2\x2\x2\x174\x18C\a\xDB\x2\x2\x175\x176\f\n"+
		"\x2\x2\x176\x177\a-\x2\x2\x177\x18C\x5\x4\x3\x2\x178\x179\f\t\x2\x2\x179"+
		"\x17B\a\xF0\x2\x2\x17A\x17C\x5l\x37\x2\x17B\x17A\x3\x2\x2\x2\x17B\x17C"+
		"\x3\x2\x2\x2\x17C\x17D\x3\x2\x2\x2\x17D\x17E\a-\x2\x2\x17E\x18C\x5\x4"+
		"\x3\x2\x17F\x180\f\b\x2\x2\x180\x181\a,\x2\x2\x181\x18C\x5\x4\x3\x2\x182"+
		"\x183\f\a\x2\x2\x183\x184\a\xF0\x2\x2\x184\x185\a,\x2\x2\x185\x18C\x5"+
		"\x4\x3\x2\x186\x187\f\x6\x2\x2\x187\x188\a\xF0\x2\x2\x188\x189\a,\x2\x2"+
		"\x189\x18A\a\xF0\x2\x2\x18A\x18C\x5\x4\x3\x2\x18B\x166\x3\x2\x2\x2\x18B"+
		"\x175\x3\x2\x2\x2\x18B\x178\x3\x2\x2\x2\x18B\x17F\x3\x2\x2\x2\x18B\x182"+
		"\x3\x2\x2\x2\x18B\x186\x3\x2\x2\x2\x18C\x18F\x3\x2\x2\x2\x18D\x18B\x3"+
		"\x2\x2\x2\x18D\x18E\x3\x2\x2\x2\x18E\'\x3\x2\x2\x2\x18F\x18D\x3\x2\x2"+
		"\x2\x190\x191\x5&\x14\x2\x191\x192\a-\x2\x2\x192\x193\x5\x4\x3\x2\x193"+
		"\x19D\x3\x2\x2\x2\x194\x195\x5&\x14\x2\x195\x197\a\xF0\x2\x2\x196\x198"+
		"\x5l\x37\x2\x197\x196\x3\x2\x2\x2\x197\x198\x3\x2\x2\x2\x198\x199\x3\x2"+
		"\x2\x2\x199\x19A\a-\x2\x2\x19A\x19B\x5\x4\x3\x2\x19B\x19D\x3\x2\x2\x2"+
		"\x19C\x190\x3\x2\x2\x2\x19C\x194\x3\x2\x2\x2\x19D)\x3\x2\x2\x2\x19E\x1A0"+
		"\x5&\x14\x2\x19F\x1A1\x5l\x37\x2\x1A0\x19F\x3\x2\x2\x2\x1A0\x1A1\x3\x2"+
		"\x2\x2\x1A1\x1A2\x3\x2\x2\x2\x1A2\x1A4\a\xD4\x2\x2\x1A3\x1A5\x5l\x37\x2"+
		"\x1A4\x1A3\x3\x2\x2\x2\x1A4\x1A5\x3\x2\x2\x2\x1A5\x1A7\x3\x2\x2\x2\x1A6"+
		"\x1A8\x5.\x18\x2\x1A7\x1A6\x3\x2\x2\x2\x1A7\x1A8\x3\x2\x2\x2\x1A8\x1AA"+
		"\x3\x2\x2\x2\x1A9\x1AB\x5l\x37\x2\x1AA\x1A9\x3\x2\x2\x2\x1AA\x1AB\x3\x2"+
		"\x2\x2\x1AB\x1AC\x3\x2\x2\x2\x1AC\x1AD\a\xDB\x2\x2\x1AD+\x3\x2\x2\x2\x1AE"+
		"\x1AF\x5&\x14\x2\x1AF\x1B0\a,\x2\x2\x1B0\x1B1\x5\x4\x3\x2\x1B1\x1BE\x3"+
		"\x2\x2\x2\x1B2\x1B3\x5&\x14\x2\x1B3\x1B4\a\xF0\x2\x2\x1B4\x1B5\a,\x2\x2"+
		"\x1B5\x1B6\x5\x4\x3\x2\x1B6\x1BE\x3\x2\x2\x2\x1B7\x1B8\x5&\x14\x2\x1B8"+
		"\x1B9\a\xF0\x2\x2\x1B9\x1BA\a,\x2\x2\x1BA\x1BB\a\xF0\x2\x2\x1BB\x1BC\x5"+
		"\x4\x3\x2\x1BC\x1BE\x3\x2\x2\x2\x1BD\x1AE\x3\x2\x2\x2\x1BD\x1B2\x3\x2"+
		"\x2\x2\x1BD\x1B7\x3\x2\x2\x2\x1BE-\x3\x2\x2\x2\x1BF\x1C0\x5\x30\x19\x2"+
		"\x1C0/\x3\x2\x2\x2\x1C1\x1C3\x5\x32\x1A\x2\x1C2\x1C1\x3\x2\x2\x2\x1C2"+
		"\x1C3\x3\x2\x2\x2\x1C3\x1C5\x3\x2\x2\x2\x1C4\x1C6\x5l\x37\x2\x1C5\x1C4"+
		"\x3\x2\x2\x2\x1C5\x1C6\x3\x2\x2\x2\x1C6\x1C7\x3\x2\x2\x2\x1C7\x1C9\a)"+
		"\x2\x2\x1C8\x1CA\x5l\x37\x2\x1C9\x1C8\x3\x2\x2\x2\x1C9\x1CA\x3\x2\x2\x2"+
		"\x1CA\x1CC\x3\x2\x2\x2\x1CB\x1C2\x3\x2\x2\x2\x1CC\x1CF\x3\x2\x2\x2\x1CD"+
		"\x1CB\x3\x2\x2\x2\x1CD\x1CE\x3\x2\x2\x2\x1CE\x1D0\x3\x2\x2\x2\x1CF\x1CD"+
		"\x3\x2\x2\x2\x1D0\x1E2\x5\x34\x1B\x2\x1D1\x1D3\x5\x32\x1A\x2\x1D2\x1D1"+
		"\x3\x2\x2\x2\x1D2\x1D3\x3\x2\x2\x2\x1D3\x1D5\x3\x2\x2\x2\x1D4\x1D6\x5"+
		"l\x37\x2\x1D5\x1D4\x3\x2\x2\x2\x1D5\x1D6\x3\x2\x2\x2\x1D6\x1D7\x3\x2\x2"+
		"\x2\x1D7\x1D9\a)\x2\x2\x1D8\x1DA\x5l\x37\x2\x1D9\x1D8\x3\x2\x2\x2\x1D9"+
		"\x1DA\x3\x2\x2\x2\x1DA\x1DC\x3\x2\x2\x2\x1DB\x1D2\x3\x2\x2\x2\x1DC\x1DF"+
		"\x3\x2\x2\x2\x1DD\x1DB\x3\x2\x2\x2\x1DD\x1DE\x3\x2\x2\x2\x1DE\x1E0\x3"+
		"\x2\x2\x2\x1DF\x1DD\x3\x2\x2\x2\x1E0\x1E2\x5\x36\x1C\x2\x1E1\x1CD\x3\x2"+
		"\x2\x2\x1E1\x1DD\x3\x2\x2\x2\x1E2\x31\x3\x2\x2\x2\x1E3\x1E4\x5:\x1E\x2"+
		"\x1E4\x33\x3\x2\x2\x2\x1E5\x1E6\x5:\x1E\x2\x1E6\x35\x3\x2\x2\x2\x1E7\x1F2"+
		"\x5\x38\x1D\x2\x1E8\x1EA\x5l\x37\x2\x1E9\x1E8\x3\x2\x2\x2\x1E9\x1EA\x3"+
		"\x2\x2\x2\x1EA\x1EB\x3\x2\x2\x2\x1EB\x1ED\a)\x2\x2\x1EC\x1EE\x5l\x37\x2"+
		"\x1ED\x1EC\x3\x2\x2\x2\x1ED\x1EE\x3\x2\x2\x2\x1EE\x1EF\x3\x2\x2\x2\x1EF"+
		"\x1F1\x5\x38\x1D\x2\x1F0\x1E9\x3\x2\x2\x2\x1F1\x1F4\x3\x2\x2\x2\x1F2\x1F0"+
		"\x3\x2\x2\x2\x1F2\x1F3\x3\x2\x2\x2\x1F3\x37\x3\x2\x2\x2\x1F4\x1F2\x3\x2"+
		"\x2\x2\x1F5\x1F7\x5\x4\x3\x2\x1F6\x1F8\x5l\x37\x2\x1F7\x1F6\x3\x2\x2\x2"+
		"\x1F7\x1F8\x3\x2\x2\x2\x1F8\x1F9\x3\x2\x2\x2\x1F9\x1FB\a\xCD\x2\x2\x1FA"+
		"\x1FC\x5l\x37\x2\x1FB\x1FA\x3\x2\x2\x2\x1FB\x1FC\x3\x2\x2\x2\x1FC\x1FD"+
		"\x3\x2\x2\x2\x1FD\x1FE\x5:\x1E\x2\x1FE\x39\x3\x2\x2\x2\x1FF\x200\a=\x2"+
		"\x2\x200\x202\x5l\x37\x2\x201\x1FF\x3\x2\x2\x2\x201\x202\x3\x2\x2\x2\x202"+
		"\x203\x3\x2\x2\x2\x203\x206\x5\x1A\xE\x2\x204\x206\x5L\'\x2\x205\x201"+
		"\x3\x2\x2\x2\x205\x204\x3\x2\x2\x2\x206;\x3\x2\x2\x2\x207\x208\x5\x6\x4"+
		"\x2\x208=\x3\x2\x2\x2\x209\x20A\a\x89\x2\x2\x20A?\x3\x2\x2\x2\x20B\x20E"+
		"\x5\x42\"\x2\x20C\x20E\x5\x44#\x2\x20D\x20B\x3\x2\x2\x2\x20D\x20C\x3\x2"+
		"\x2\x2\x20E\x41\x3\x2\x2\x2\x20F\x210\a-\x2\x2\x210\x211\x5\x4\x3\x2\x211"+
		"\x43\x3\x2\x2\x2\x212\x213\a,\x2\x2\x213\x214\x5\x4\x3\x2\x214\x45\x3"+
		"\x2\x2\x2\x215\x216\x5\x1A\xE\x2\x216G\x3\x2\x2\x2\x217\x21A\x5\x18\r"+
		"\x2\x218\x21A\x5J&\x2\x219\x217\x3\x2\x2\x2\x219\x218\x3\x2\x2\x2\x21A"+
		"I\x3\x2\x2\x2\x21B\x21E\x5<\x1F\x2\x21C\x21E\x5(\x15\x2\x21D\x21B\x3\x2"+
		"\x2\x2\x21D\x21C\x3\x2\x2\x2\x21EK\x3\x2\x2\x2\x21F\x220\a\x34\x2\x2\x220"+
		"\x221\x5l\x37\x2\x221\x222\x5N(\x2\x222M\x3\x2\x2\x2\x223\x226\x5(\x15"+
		"\x2\x224\x226\x5<\x1F\x2\x225\x223\x3\x2\x2\x2\x225\x224\x3\x2\x2\x2\x226"+
		"O\x3\x2\x2\x2\x227\x230\x5R*\x2\x228\x230\x5V,\x2\x229\x230\x5X-\x2\x22A"+
		"\x230\x5^\x30\x2\x22B\x230\x5Z.\x2\x22C\x230\x5\x64\x33\x2\x22D\x230\x5"+
		"T+\x2\x22E\x230\x5`\x31\x2\x22F\x227\x3\x2\x2\x2\x22F\x228\x3\x2\x2\x2"+
		"\x22F\x229\x3\x2\x2\x2\x22F\x22A\x3\x2\x2\x2\x22F\x22B\x3\x2\x2\x2\x22F"+
		"\x22C\x3\x2\x2\x2\x22F\x22D\x3\x2\x2\x2\x22F\x22E\x3\x2\x2\x2\x230Q\x3"+
		"\x2\x2\x2\x231\x232\t\b\x2\x2\x232S\x3\x2\x2\x2\x233\x234\a\xAB\x2\x2"+
		"\x234U\x3\x2\x2\x2\x235\x236\t\t\x2\x2\x236W\x3\x2\x2\x2\x237\x238\t\n"+
		"\x2\x2\x238Y\x3\x2\x2\x2\x239\x23C\a\x89\x2\x2\x23A\x23C\x5\\/\x2\x23B"+
		"\x239\x3\x2\x2\x2\x23B\x23A\x3\x2\x2\x2\x23C[\x3\x2\x2\x2\x23D\x23E\t"+
		"\v\x2\x2\x23E]\x3\x2\x2\x2\x23F\x240\t\f\x2\x2\x240_\x3\x2\x2\x2\x241"+
		"\x242\t\r\x2\x2\x242\x61\x3\x2\x2\x2\x243\x244\t\xE\x2\x2\x244\x63\x3"+
		"\x2\x2\x2\x245\x249\x5\x66\x34\x2\x246\x249\x5h\x35\x2\x247\x249\x5j\x36"+
		"\x2\x248\x245\x3\x2\x2\x2\x248\x246\x3\x2\x2\x2\x248\x247\x3\x2\x2\x2"+
		"\x249\x65\x3\x2\x2\x2\x24A\x24B\t\xF\x2\x2\x24Bg\x3\x2\x2\x2\x24C\x24D"+
		"\a\x8F\x2\x2\x24Di\x3\x2\x2\x2\x24E\x24F\t\x10\x2\x2\x24Fk\x3\x2\x2\x2"+
		"\x250\x252\t\x11\x2\x2\x251\x250\x3\x2\x2\x2\x252\x253\x3\x2\x2\x2\x253"+
		"\x251\x3\x2\x2\x2\x253\x254\x3\x2\x2\x2\x254m\x3\x2\x2\x2Vsw{\x8A\x96"+
		"\x9F\xA3\xAA\xAE\xB1\xB6\xBB\xC1\xC5\xCC\xD0\xD4\xD9\xDD\xE2\xE6\xEB\xEF"+
		"\xF4\xF8\xFD\x101\x106\x10A\x10F\x113\x118\x11C\x121\x125\x12A\x12E\x133"+
		"\x137\x13A\x13C\x144\x146\x14C\x150\x164\x168\x16C\x16F\x172\x17B\x18B"+
		"\x18D\x197\x19C\x1A0\x1A4\x1A7\x1AA\x1BD\x1C2\x1C5\x1C9\x1CD\x1D2\x1D5"+
		"\x1D9\x1DD\x1E1\x1E9\x1ED\x1F2\x1F7\x1FB\x201\x205\x20D\x219\x21D\x225"+
		"\x22F\x23B\x248\x253";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace Rubberduck.Parsing.Binding
