<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ConstantNotUsedInspection" xml:space="preserve">
    <value>Rubberduck nemůže najít žádnou referenci ke konstantě. Zvažte odstranění nepoužitých deklarací.</value>
  </data>
  <data name="DefaultProjectNameInspection" xml:space="preserve">
    <value>Zvažte pojmenování vašeho VBA projektu.</value>
  </data>
  <data name="AssignedByValParameterInspection" xml:space="preserve">
    <value>Parametr je předán jako hodnota, ale je mu přidělena nová hodnota/reference. Zvažte vytvoření lokální kopie, pokud volaná funkce nemá znát onu novou hodnotu. Pokud má volaná funkce pracovat s novou hodnotou, parametr by měl být předán jako 'ByRef' a vy máte bug.</value>
  </data>
  <data name="EmptyStringLiteralInspection" xml:space="preserve">
    <value>Vestavěná konstanta 'vbNullString' je pointer na prázdný řetězec, který si bere 0 bytů paměti, což jednoznačně vyjadřuje úmysl prázdného řetězce.</value>
  </data>
  <data name="EncapsulatePublicFieldInspection" xml:space="preserve">
    <value>Zvažte místo toho odkrytí property.</value>
  </data>
  <data name="ImplicitActiveSheetReferenceInspection" xml:space="preserve">
    <value>Implicitní reference na aktivní sešit dělá kód slabým a obtížnějším pro debugování. Zvažte explicitní zapisování referencí tam, kde to máte v úmyslu a upřednostňujte zpracování referencí objektů. Ignorujte, pokud volaný člen referujte k Typu, který Rubberduck nedokáže zpracovat.</value>
  </data>
  <data name="ImplicitActiveWorkbookReferenceInspection" xml:space="preserve">
    <value>Implicitní reference na aktivní 'workbooku' dělá kód slabým a obtížnějším pro debugování. Zvažte explicitní zapisování referencí tam, kde to máte v úmyslu a upřednostňujte zpracování referencí objektů. Ignorujte, pokud volaný člen referujte k Typu, který Rubberduck nedokáže zpracovat.</value>
  </data>
  <data name="ImplicitByRefModifierInspection" xml:space="preserve">
    <value>Pokud není specifikováno jinak, parametry jsou předány referencemi, což může být matoucí a náchylné k bugům. Preferujte předání parametrů jako hodnotu a specifikujte ByRef explicitně jen tehdy, pokud potřebujete předat parametr jako referenci.</value>
  </data>
  <data name="ImplicitPublicMemberInspection" xml:space="preserve">
    <value>Členové modulu jsou ve výchozím nastavení veřejní, což může být oproti očekávání. Zvažte použití explicitních přístupových modifikátorů, aby se kód zbavil nejednoznačosti.</value>
  </data>
  <data name="ImplicitVariantReturnTypeInspection" xml:space="preserve">
    <value>Pokud není specifikováno jinak, členové vrátí implicitně hodnotu typu 'Variant'. Zvažte zápis explicitního vrácení typu 'Variant', pokud není znám typ vracející hodnoty, nebo ho explicitně specifikujte.</value>
  </data>
  <data name="MoveFieldCloserToUsageInspection" xml:space="preserve">
    <value>Proměnná na úrovni modulu, která je použita jen v jedné proceduře, by měla být deklarovaná v oné proceduře.</value>
  </data>
  <data name="MultipleDeclarationsInspection" xml:space="preserve">
    <value>Deklarování více proměnných v té samé instrukci je legální, ale nemělo by se to používat často. Zvažte deklaraci proměnných blíže k jejich použití, v jedné instrukci na jednu deklaraci.</value>
  </data>
  <data name="MultipleFolderAnnotationsInspection" xml:space="preserve">
    <value>Rubberduck používá v kódu modulu pouze první '@Folder' anotaci; zvažte odstranění nadbytečných.</value>
  </data>
  <data name="NonReturningFunctionInspection" xml:space="preserve">
    <value>Zde se jedná nejspíše o bug. Návratná hodnota funkce nebo property getteru musí být přidělena před jejím skončením, jinak program nebude pracovat s očekávanými výsledky. Jestliže nemá funkce smysluplnou návratnou hodnotu, zvažte místo toho její deklaraci jako proceduru 'Sub'.</value>
  </data>
  <data name="ObsoleteCallStatementInspection" xml:space="preserve">
    <value>Výraz 'Call' pro volání procedur není zapotřebí a v jazyku existuje pouze pro podporu starých verzí jazyka, které jej potřebují; zde ho však můžete odstranit a volat věci implicitně.</value>
  </data>
  <data name="ObsoleteCommentSyntaxInspection" xml:space="preserve">
    <value>Výraz 'Rem' v jazyku existuje pouze pro podporu starých verzí jazyka, které jej potřebují; zde ho však můžete bez starostí přepsat na apostrof/jednoduchou uvozovku.</value>
  </data>
  <data name="ObsoleteGlobalInspection" xml:space="preserve">
    <value>Výraz 'Global' v jazyku existuje pouze pro podporu starých verzí jazyka, které jej potřebují; zde ho můžete bez starostí přepsat na modifikátor 'Public'.</value>
  </data>
  <data name="ObsoleteLetStatementInspection" xml:space="preserve">
    <value>Výraz 'Let' v jazyku existuje pouze pro podporu starých verzí jazyka, které jej potřebují; zde ho můžete bez starostí smazat, protože moderní VBA nepotřebuje klíčové slovo pro přidělení hodnot.</value>
  </data>
  <data name="VariableNotUsedInspection" xml:space="preserve">
    <value>Neexistují žádné reference k proměnné</value>
  </data>
  <data name="ParameterNotUsedInspection" xml:space="preserve">
    <value>Parametr je předán členu, který jej nevyužívá. Zvažte odstranění tohoto parametru.</value>
  </data>
  <data name="ParameterCanBeByValInspection" xml:space="preserve">
    <value>Parametr, který je předán jako reference 'ByRef' a není mu přidělena nová hodnota/reference, může být místo toho předán jako hodnota 'ByVal'.</value>
  </data>
  <data name="OptionExplicitInspection" xml:space="preserve">
    <value>VBA s úsměvem na tváři zkompiluje typovou chybu: použijte 'Option Explicit', abyste předešli úspěšné kompilaci programu s chybami.</value>
  </data>
  <data name="OptionBaseInspection" xml:space="preserve">
    <value>Pole typicky začínají nulou. Tato volba změní výchozí spodní hranici pro implicitně definované pole. To může zavést "mimo-o-jednu" typ chyby, pokud na to člověk nedá pozor.</value>
  </data>
  <data name="ProcedureNotUsedInspection" xml:space="preserve">
    <value>Rubberduck nebyl schopen najít žádné volání pro tuto proceduru. Tuto inspekci můžete ignorovat, pokud je procedura přiřazena některému makro tlačítku, použita jako 'user-defined' funkce (UDF) nebo obstarává událost aplikace, o které Rubberduck neví. Pokud se nejedná o žádnou z těchto věcí, zvažte odstranění procedury.</value>
  </data>
  <data name="UnassignedVariableUsageInspection" xml:space="preserve">
    <value>Zde se jedná nejspíše o bug. Proměnná je referována, avšak nikdy jí není nic přiděleno.</value>
  </data>
  <data name="MultilineParameterInspection" xml:space="preserve">
    <value>Rozdělení deklarace parametru na více řádků velmi zraňuje čitelnost. I když je parametr dlouhý, zvažte jeho deklaraci na jeden řádek. </value>
  </data>
</root>