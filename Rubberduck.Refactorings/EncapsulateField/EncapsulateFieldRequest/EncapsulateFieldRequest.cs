using Rubberduck.Parsing.Symbols;

namespace Rubberduck.Refactorings.EncapsulateField
{
    /// <summary>
    /// <c>EncapsulateFieldRequest</c> aggregates attributes necessary for the <c>EncapsulateFieldUseBackingFieldRefactoringAction</c>.
    /// </summary>
    /// <remarks>
    /// <c>EncapsulateFieldRequest</c> provides the data needed to encapsulate a field.
    /// There is no validation or conflict checking performed for non-UserDefinedTypes.
    /// The caller can specify a readonly Property and select an <c>IdentifierName</c> for
    /// the Property.  If the target is a UserDefinedType Field and the UserDefinedType is Private,
    /// then the propertyIdentifier parameter is ignored and PropertyIdentifiers for each UserDefinedTypeMember
    /// are generated by the refactoring action.
    /// </remarks>
    public class EncapsulateFieldRequest
    {
        public EncapsulateFieldRequest(VariableDeclaration target, bool isReadOnly = false, string propertyIdentifier = null)
        {
            Declaration = target;
            IsReadOnly = isReadOnly;
            PropertyIdentifier = propertyIdentifier;
        }

        public VariableDeclaration Declaration { get; }
        public string PropertyIdentifier { set; get; }
        public bool IsReadOnly { set; get; }

        public IEncapsulateFieldCandidate ApplyRequest(IEncapsulateFieldCandidate candidate)
        {
            candidate.EncapsulateFlag = true;
            candidate.IsReadOnly = IsReadOnly;
            if (PropertyIdentifier != null)
            {
                candidate.PropertyIdentifier = PropertyIdentifier;
            }
            return candidate;
        }
    }
}
